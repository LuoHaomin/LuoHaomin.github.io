# MLSYS微调优化
## 1. 大语言模型（LLM）的部署过程

大语言模型（LLM）从基础的语言能力到能够理解并执行复杂任务，通常会经历一个多阶段的部署过程。这个过程涵盖了从模型学习通用知识到适应特定用户偏好的精细化调整。

### 1.1 预训练 (Pre-Training)

*   **定义与目标**：
    *   预训练是LLM部署过程的**第一步**，通过**大规模无监督学习**进行。
    *   模型在**海量文本数据**上进行训练，学习语言的结构、知识和模式。
    *   核心目标是通过语言建模任务（例如，预测下一个词）使模型**掌握通用的语言理解能力**。
*   **模型能力**：
    *   预训练后的模型能够生成**合理的文本段落**。
    *   但此时模型对特定任务或用户指令的理解和响应能力**仍然有限**。它能“说”出通顺的语言，但还不懂得如何“做”任务。

### 1.2 监督微调 (Supervised Fine-Tuning, SFT)

*   **定义与目标**：
    *   监督微调是LLM部署过程的**第二步**，它使用**监督学习**方法。
    *   其目的是**引导模型执行更为具体的任务**，使其能够更好地理解和响应用户指令。
    *   核心目标是让模型“**学会做任务**”、“**变得像示范一样**”。
*   **训练过程**：
    *   通过监督学习调整模型参数，使其能更准确地执行特定任务。
*   **应用示例**：
    *   如回答问题（Question Answering）、代码生成、文本摘要等。
    *   相关的技术包括**Instruct Tuning**（指令微调）、**InstructGPT**等。

### 1.3 偏好优化 (Preference Optimization)

*   **定义与目标**：
    *   偏好优化是LLM部署过程的**第三步**，通常通过**强化学习**或其他高级技术进行。
    *   其目的是**进一步调整模型的生成行为**，使其更符合用户的期望和人类偏好。
    *   核心目标是让模型“**选择更好的回答**”，即生成不仅正确，而且更“好”的输出。
*   **模型能力**：
    *   经过偏好优化后的模型在对话、回答问题、内容生成时**更符合人类期望**。
    *   它有助于**减少不合适或不受欢迎的输出**。
*   **应用示例**：
    *   著名的应用包括**RLHF (Reinforcement Learning from Human Feedback)**、**ChatGPT**、**Claude**等。

## 2. 指令微调 (Instruction Tuning)

### 2.1 指令微调的定义与目标

*   **定义**：
    *   指令微调是指使用**指令性数据**对大语言模型进行微调的过程。
    *   **指令性任务数据**包括各种明确的指令、提示和目标，这些数据要求模型执行特定的功能或生成特定的输出。
*   **训练过程**：
    *   通过指令性任务数据，训练模型**理解输入指令的含义**，并生成相应的输出。
*   **核心目标**：
    *   将模型从单纯的“**吐字**”（即生成语法正确但没有明确意图的文本）转变为“**能够完成任务**”（即根据指令执行特定功能）。
    *   通过指令微调，可以增强模型的**理解能力**和**执行能力**，使其更好地适应各种实际应用场景。

### 2.2 指令微调数据示例

*   指令微调的数据通常是**高质量的“指令-响应”对**。这些数据可能来源于人工标注、现有数据集转换或自生成等方式。
*   值得注意的是，指令微调后的语言模型表现出**零样本学习（Zero-shot learning）**的能力。这意味着模型在没有见过特定任务的示例数据时，也能通过理解指令来完成该任务。
*   **参考文献**：
    *   “Finetuned language models are zero-shot learners.” (Wei, Bosma, Zhao, Guu, et. al, 2021) 进一步证实了指令微调对于实现零样本学习的重要性。

## 3. 参数高效微调 (Parameter Efficient Fine-Tuning, PEFT)

### 3.1 全参数微调的挑战

大语言模型（LLM）通常拥有数十亿甚至上千亿的参数。对这些模型进行**全参数微调 (Full Fine-tuning)** 意味着训练过程中需要更新模型的所有参数。虽然全参数微调通常能达到最好的效果，但它带来了显著的挑战：
*   **计算成本极高：** 需要大量的计算资源（如GPU）和时间。
*   **存储成本高：** 每个微调任务都需要保存一份完整的模型副本，占用巨大的存储空间。
*   **工作内存需求大：** 训练过程中需要将整个模型参数加载到内存中，对显存要求极高。
*   **部署复杂：** 部署多个微调模型副本会带来巨大的基础设施开销。

### 3.2 PEFT 的目标与方法

**参数高效微调 (Parameter Efficient Fine-Tuning, PEFT)** 的核心目标是：在**只更新少量模型参数**的情况下，实现与更新整个模型相近的微调性能。这意味着通过更少的计算、更少的工作内存和更少的存储，就能高效地将预训练模型适应到特定任务。

PEFT 的主要方法包括：

#### 3.2.1 Soft Prompts

Soft Prompts 方法通过在预训练模型的输入中添加可学习的部分 prompts（提示），用于指导模型生成特定于任务的输出。这种方法的优势在于，它只微调这些额外的、小部分的提示参数，而不是模型的原始权重，从而实现高效的适应。

##### 3.2.1.1 Soft Prompt 方法原理

*   **传统 Prompt 的局限：** 传统的 Prompt 依赖人工设计，例如：“Classify the sentiment of this sentence: [输入文本]”。这种人工设计的提示效果可能不稳定，且需要领域专家经验。
*   **Soft Prompt 的引入：** Soft Prompt 方法定义了一组**可训练的 Soft Prompt 嵌入向量**，例如 \(P_1, P_2, ..., P_n\)。
*   **拼接与输入：** 这些 Soft Prompt 嵌入向量与输入文本的 Token 嵌入拼接后，一起输入到模型中，形成新的输入序列，例如：`[P1, P2, ..., Pn, Token1, Token2, ...]`。
*   **训练机制：** 在训练过程中，**只优化**这组 Soft Prompt 嵌入向量 \(P_1, P_2, ..., P_n\)，而不是模型本身的参数。模型的原始权重保持冻结。
*   **效果：** 经过训练的 Soft Prompt 会自动调整输入，使得模型更倾向于正确地识别和完成特定任务（如情感识别）。它让模型学会使用一种“模型语言”进行提示。

##### 3.2.1.2 Prompt Tuning

*   **机制：** Prompt Tuning 是 Soft Prompts 的一种实现。它在**输入侧**增加一段**可训练的 embedding**。
*   **输入结构：** 模型的输入变为：`[SOFT_PROMPT_1 ... SOFT_PROMPT_k] + original tokens`。其中 `SOFT_PROMPT_i` 是可训练的嵌入向量。
*   **特点：** 这种方法简单，只在输入层进行修改，训练参数量极小。

##### 3.2.1.3 Prefix Tuning

*   **机制：** Prefix Tuning 是一种在 Transformer **每一层**的输入都增加一个“可训练的前缀 embedding”的方法。
*   **前缀处理：** 这个前缀 embedding（通常约几十个 token）会经过一个小的多层感知机（MLP）进行投影。
*   **KV Cache：** 投影后的结果会生成 Transformer 每一层 KV cache 的附加内容。重要的是，**各层的前缀参数是独立不共享的**。
*   **输入结构：** 模型的输入变为：`[PREFIX...][x1 x2 x3 ...]`。
*   **KV Cache 结构：** 经过 Prefix Tuning 后，Transformer 层的 KV cache 结构是 `prefix` + `normal tokens`。
*   **特点：** 相比 Prompt Tuning，Prefix Tuning 影响模型内部更深层的表示，可能带来更好的性能，但参数量略大。

#### 3.2.2 Frozen Layers

*   **迁移学习的基本思想：** Frozen Layers 是迁移学习的一种基本方法，尤其在计算机视觉（CV）领域的多层卷积神经网络（CNN）中被广泛应用。
*   **实现方式：** 在微调过程中，**冻结模型的前面几层参数（使其梯度不更新）**，只更新模型后面层的参数。
*   **原理：** 这种方法的理论基础是，模型的不同层学习到特征的抽象程度不同。通常，前面层学习到的是更通用的、低级的特征（如边缘、纹理），而后面层学习到的是更高级、任务特定的特征。因此，冻结通用特征层，只微调任务特定层，可以高效地适应新任务。
*   **CV 经典模型借鉴：** 类似于 CV 中冻结预训练的 ResNet 或 VGG 的大部分层，只微调顶部的分类器层。

#### 3.2.3 Adapters

*   **机制：** Adapter 方法通过在预训练模型的内部**插入一个或多个轻量级的适配层**（Adapter）来实现参数高效微调。
*   **原始模型：** 预训练模型的原始参数在微调过程中保持**固定**。
*   **训练过程：** 微调过程**只更新 Adapter 部分的参数**。
*   **Adapter 结构：** Adapter 通常是一个带有**小隐藏层大小**的多层感知机 (MLP)。它通常是一个残差连接结构，即 `output = input + Adapter(input)`。
    *   `【若需查看原始图片详情，请参考原文中的“Adapter: MLP with small hidden size”示意图】`。该图展示了一个Adapter模块，它接收来自Transformer层的主路径输出，经过一个Down Projection、一个激活函数和一个Up Projection后，将结果通过残差连接加回到主路径。中间的隐藏层维度通常比主路径的维度小很多。
*   **参数量：** Adapter 的参数量通常只占模型总量的**1%左右**，因此非常高效。
*   **局限性：** 将 Adapter **串行**地插入到模型的管道中，可能会导致**信息瓶颈**，从而在某些情况下影响模型的性能，尤其是在Adapter数量较多或设计不当时。

#### 3.2.4 低秩适配 (Low-Rank Adaptation, LoRA)

##### 3.2.4.1 LoRA 核心思想

*   **冗余观察：** 大语言模型在完成训练之后，其模型参数常常存在巨大的**冗余**。
*   **低秩分解：** LoRA 的核心思想是，对大语言模型中的**部分权重矩阵**进行**低秩分解**。
*   **只更新低秩矩阵：** 通过这种方法，微调时只需要更新这些**低秩矩阵**，而**无需更新整个权重矩阵**。
*   **插入适配层：** 具体实现是在原始的预训练模型中，通过插入可训练的低秩适配层来调整模型，同时保持原始参数不变。
*   **公式表示：**
    *   常规的前向传播是：\(h = Wx\)
    *   带有 LoRA 的前向传播变为：\(h = Wx + BAx = (W + BA)x\)
    *   这里 \(W\) 是原始的预训练权重矩阵（冻结），\(x\) 是输入。
    *   \(B\) 和 \(A\) 是两个低秩矩阵，其中 \(A\) 的维度是 \(r \times d_{in}\)，\(B\) 的维度是 \(d_{out} \times r\)，且 \(r\) (秩) 远小于 \(min(d_{in}, d_{out})\)。
    *   `【若需查看原始图片详情，请参考原文中的 LoRA 示意图】`。该图展示了 \(W\) 矩阵与输入 \(x\) 相乘，同时有一个旁路分支，输入 \(x\) 先与 \(A\) 矩阵相乘，再与 \(B\) 矩阵相乘，最后将 \(BAx\) 的结果加到 \(Wx\) 上。这形象地说明了 LoRA 如何通过在现有权重矩阵旁边增加一个低秩更新分支来工作。

##### 3.2.4.2 LoRA 初始化

*   **保证初始状态：** LoRA 的设计保证了在初始化时，微调后的模型与原模型功能**一致**。
*   **初始化策略：** 通常将矩阵 \(A\) 初始化为随机高斯分布的小值，而矩阵 \(B\) 初始化为零矩阵。
*   **效果：** 这样 \(BA\) 的乘积在训练开始时是零矩阵，即 \(W_{LoRA} = W + BA = W + 0 = W\)，确保了初始状态与原始模型相同，避免了不必要的扰动。

##### 3.2.4.3 LoRA 的热替换能力

*   **灵活性：** LoRA 的一个显著优点是其极高的灵活性，可以在一个预训练模型上**轻松地替换不同的 Adapter**。
*   **多任务支持：** 这使得一个基础大模型能够灵活支持多个不同的微调任务。例如，同一个基础模型可以加载针对问答、代码生成或文本摘要的不同 LoRA Adapter，而无需存储多个完整的模型副本。
*   **部署优势：** 这种能力极大简化了多任务模型的部署和管理。

##### 3.2.4.4 LoRA 对推理延迟和计算量的影响

*   **训练完成后的合并：** 当 LoRA 微调完成后，\(BA\) 的部分可以直接加回到原始参数矩阵 \(W\) 中，形成一个新的有效权重矩阵 \(W_{LoRA} = W + BA\)。
*   **推理阶段：** 在推理阶段，只需要使用这个合并后的 \(W_{LoRA}\) 矩阵，与常规的 \(W\) 矩阵操作完全一致。
*   **零影响：** 因此，LoRA 在推理时**不影响延迟和计算量**。这与 Adapters 方法形成对比，Adapters 在推理时通常需要额外的计算步骤。

##### 3.2.4.5 LoRA 在 Transformer 中的应用

*   **可替换算子：** LoRA 可以替换 Transformer 模型中**任何线性矩阵运算算子 (Linear)**。
*   **常见应用位置：**
    *   Attention 机制中的 **Q (Query), K (Key), V (Value) projection 层**。
    *   Attention 机制中的 **output projection 层**。
    *   前馈网络 (FFN) 或多层感知机 (MLP) 中的 **linear1 / linear2 层**。
    *   Embedding 层（较少使用，因为 embedding 矩阵通常很大，低秩近似效果可能不佳）。
*   **示例配置：** 例如，`LoraConfig(target_modules=["q_proj", "k_proj", "v_proj"])` 指示 LoRA 应用于 Q, K, V 投影层。

##### 3.2.4.6 mLoRA: 基于管道并行化的多 LoRA 微调

mLoRA 是一种针对在多 GPU 环境下同时微调多个 LoRA 任务而设计的系统，旨在提高 GPU 利用率和吞吐量。

*   **多 LoRA 任务：** mLoRA 允许多个 LoRA 任务在不同的 GPU 上同时进行微调。
*   **内存复用：** 由于所有 LoRA 任务共享同一个基础模型（预训练模型），因此可以通过在一个基础模型上微调来增加**内存复用**，从而提高效率。

###### 3.2.4.6.1 LoRAPP 优化

*   **管道并行挑战：** 传统的管道并行（如 PipeDream）解决了管道并行中的“气泡时间 (Bubble time)”问题，但常常会导致异步更新，不适用于需要同步梯度的场景。
*   **LoRA 的特殊性：** 在 mLoRA 中，不同的 LoRA finetuning 任务更新的是各自不同的 LoRA 组件（即各自的 \(A\) 和 \(B\) 矩阵），这些组件之间**相互没有影响**。
*   **LoRAPP 方案：** 利用 LoRA 任务的这种独立性，LoRAPP 直接采用 PipeDream 的做法进行设备间的任务调度，将每个 LoRA 微调看作一个 “microbatch”。这允许在不同 GPU 上同时处理不同 LoRA 任务的不同阶段，实现高效的管道并行。

###### 3.2.4.6.2 BatchLoRA 优化

*   **基础模型复用：** 不同的 LoRA 任务共享相同的基础模型参数。
*   **Batching：** 基于此，不同的 LoRA 任务的数据可以在基础模型部分组成一个大的**Batch**进行工作。这意味着在计算基础模型的共享前向/后向时，可以将来自不同 LoRA 任务的数据批量处理。
*   **提高 GPU 利用率：** 这种 BatchLoRA 机制显著增加了 GPU 的利用率，因为它减少了基础模型计算的重复开销。

###### 3.2.4.6.3 两者结合

mLoRA 将 LoRAPP 和 BatchLoRA 两种优化结合起来：
*   **Microbatch 内：** 每个 microbatch 使用 BatchLoRA 尽可能多地塞入任务数据，以增加内存和 GPU 利用率。
*   **Microbatch 间：** microbatch 之间采用 PipeDream 的 1F1B (One Forward One Backward) 方式进行更新，实现零气泡 (zero bubble)，进一步提高管道效率。

###### 3.2.4.6.4 LoRA 任务数量与吞吐量

`【若需查看原始图片详情，请参考原文中的“Throughput comparisons among different parallelism strategies with varying numbers of simultaneously trained LoRA adapters.”图】`。该图通常会展示随着同时训练的 LoRA Adapter 数量增加，不同并行策略（如仅 BatchLoRA、仅 LoRAPP、mLoRA 等）的吞吐量（例如，每秒处理的样本数或 token 数）。通常，结合了 LoRAPP 和 BatchLoRA 的 mLoRA 策略，其吞吐量会随着 LoRA 任务数量的增加而显著提升，表明其能更高效地处理并行微调场景。

### 4. 偏好优化 (Preference Optimization)

#### 4.1 偏好优化的目的与数据特点
*   **目的：** 偏好优化旨在让模型生成的文本**更符合人类偏好和期望**。这是在大语言模型部署过程中，继预训练和监督微调之后，进一步提升模型实用性和用户满意度的关键步骤。
*   **数据特点：**
    *   与监督微调所使用的带有标准答案（标签）的平均数据集不同，偏好优化的训练数据一般**没有标准答案**。
    *   它通常只包含**相对的评分或排名**，即表达了某个输出比另一个输出“更好”的偏好信息。
    *   **例如：** 在代码数据集中，我们希望模型能够更多地学习优秀编程者编写的代码，而不仅仅是任何一段能够运行的代码。

#### 4.2 偏好优化方法概述
为实现模型生成行为与人类偏好的对齐，业界发展了多种偏好优化方法：
*   **基于人类反馈的强化学习 (RLHF, Reinforcement Learning from Human Feedback)：** 这是当前最主流和成功的方法之一，通过人类对模型输出的偏好反馈来训练奖励模型，并进一步使用强化学习优化语言模型。
*   **基于人类提供的规则列表的自我训练机制 (如 Constitutional AI)：** 通过设定一系列原则或规则，引导模型进行自我评估和修正，使其输出符合预设的规范。
*   **基于重新标注的有监督方法 (HIR)：** 对现有数据进行重新标注，使其包含偏好信息，然后进行监督学习。
*   **直接偏好优化 (DPO, Direct Preference Optimization)：** 一种更直接的偏好学习方法，它通过一个单一的优化目标来直接学习偏好，而无需训练单独的奖励模型。
*   **强化自训练 (ReST)：** 模型通过自我生成数据和评估来提升性能，形成一个自给自足的训练循环。
*   **基于人工智能反馈的强化学习 (RLAIF)：** 使用另一个AI模型作为奖励函数来提供反馈，而非直接依赖人类反馈。

#### 4.3 强化学习 (Reinforcement Learning, RL) 基础
*   **定义：** 强化学习是一种机器学习范式，智能体（Agent）通过**与环境（Environment）进行交互**，并根据环境的**奖励（Reward）反馈**，不断调整自身行为（Actions），以期找到一种策略，从而获得**最大化的累积奖励**。
*   **核心组成要素：**
    *   **智能体 (Agent)：** 学习者或决策者，在大语言模型场景中即为大语言模型本身。
    *   **环境 (Environment)：** 智能体所处的外部世界，可以是一个模拟器、真实世界，或在偏好优化中指代人类反馈系统。
    *   **动作 (Actions)：** 智能体在环境中可以执行的操作，对于大语言模型而言，就是生成文本。
    *   **环境状态 (Environment State)：** 环境在某一时刻的状况。
    *   **奖励 (Reward)：** 环境对智能体执行动作后给出的反馈信号，用于评估动作的好坏。正奖励鼓励智能体的行为，负奖励则抑制。
*   **工作机制：** 智能体观察环境状态，选择并执行一个动作。环境接收动作后，更新到新的状态，并给予智能体一个奖励。智能体根据这个奖励来调整其内部策略或模型参数，以期望在未来获得更高的累积奖励。这个过程是一个持续的**试错与学习循环**。
*   **应用示例：** 围棋游戏（AlphaGo）、机器臂控制、自动驾驶等。
*   **图片内容描述：** 原始文档中的“什么是强化学习 (Reinforcement Learning, RL) ？”示意图清晰地描绘了强化学习的循环过程：
    1.  智能体首先从环境中获取当前的**环境状态**。
    2.  根据当前状态，智能体决定并**执行动作**。
    3.  环境收到动作后，会产生一个**环境奖励**，并更新到**新的环境状态**。
    4.  智能体根据收到的奖励信号来**更新模型**（即调整其策略），以在未来的交互中获得更多奖励。
    5.  这个循环持续进行，智能体通过不断与环境互动和学习，最终掌握最优策略。
    `【若需查看原始图片详情，请参考原文中的“什么是强化学习 (Reinforcement Learning, RL) ？”示意图】`

#### 4.4 基于人类反馈的强化学习 (RLHF)
RLHF 是偏好优化的核心方法，它通过引入人类的偏好反馈来指导大语言模型的学习，使其生成更符合人类期望的内容。

##### 4.4.1 RLHF 的挑战与瓶颈
*   **瓶颈：** 在传统的强化学习设置中，如果直接使用人类作为奖励的提供者，那么**人类将成为整个微调训练的瓶颈**。这是因为强化学习通常需要大量的环境交互和实时反馈，而人类提供反馈的速度和效率远低于模型训练所需。
*   **解决方案思路：** 为解决这一问题，核心思路是训练一个能够**预测人类判断的“人类”模型**，即**奖励模型 (Reward Model)**，来代替人类进行高效的打分。
*   **历史成功案例：** [Christiano 等人] (2017) 在 MuJoCo 和 Atari 游戏中成功训练了一个能够遵循人类偏好的模型，而所需的真实人类环境交互数据标注量不到 1%，这证明了奖励模型的可行性。

##### 4.4.2 奖励模型 (Reward Model)
*   **作用：** 奖励模型 (Reward Model, RM) 是RLHF中的核心组件，它的目标是**学习人类的偏好**，并能够对语言模型的生成结果进行打分，以量化其符合人类偏好的程度。在强化学习阶段，它充当了**奖励函数**，为语言模型提供训练信号。

###### 4.4.2.1 奖励模型的训练数据：人类偏好数据
*   **数据来源：** 奖励模型的训练依赖于**人类偏好数据**。
*   **数据收集方式：** 通常，人类被要求对语言模型生成的**多个回答进行比较、排名或直接打分**。这些评估会基于多种指标，包括但不限于：
    *   **有用性 (Helpfulness)**：回答是否能有效解决问题或提供所需信息。
    *   **无害性 (Harmlessness)**：回答是否避免了不当、歧视或有害内容。
    *   **真实性 (Truthfulness)**：回答是否准确和可信。
    *   **连贯性 (Coherence)**：回答的逻辑性和流畅性。
    *   **图片内容描述：** 原始文档中的“奖励模型的训练数据：人类偏好数据”图示通常会展示一个流程：对于同一个“问题/指令”，语言模型会生成多个“LLM人类回答”候选。然后，人类评估员会对这些回答进行比较和排序，或者直接给出“反馈分数”，指出哪个回答更符合他们的偏好。这些带有偏好信息的数据集被用来训练奖励模型。
    `【若需查看原始图片详情，请参考原文中的“奖励模型的训练数据：人类偏好数据”示意图】`
*   **重要性：** 预训练模型和监督微调后的模型，其输出往往难以在上述多维度上同时满足人类的高要求，因此需要奖励模型来引导其向符合人类偏好的方向优化。

###### 4.4.2.2 奖励模型的作用
*   **替代人类反馈：** 一旦奖励模型训练完成，它就能高效地为语言模型生成的所有输出提供奖励分数，从而实现强化学习的**规模化训练**，避免了对人类的实时依赖。
*   **引导模型行为：** 强化学习算法会利用这些奖励分数作为信号，更新语言模型的参数，使其倾向于生成高分（即更符合人类偏好）的文本。

##### 4.4.3 RLHF 训练过程
RLHF 的整个训练过程通常包含三个关键阶段：

1.  **监督微调 (SFT, Supervised Fine-Tuning)：**
    *   **目的：** 使用人工标注的高质量数据（例如：`prompt` → 理想输出）对预训练的大语言模型进行微调。
    *   **作用：** 使模型能够更好地理解指令，并生成**合理且符合语法规范的初始输出**，将模型从“吐字”阶段调整到“能够完成任务”的合理初始状态，确保模型不会生成不着边际的内容。

2.  **训练奖励模型 (Reward Model, RM)：**
    *   **目的：** 利用SFT阶段的模型生成的数据，结合人类偏好标注，训练一个独立的奖励模型。
    *   **过程：** 人类对SFT模型生成的多个输出进行打分或排名，奖励模型学习预测**“人类更喜欢哪个输出”**，从而捕捉人类的偏好模式。

3.  **强化学习 (Reinforcement Learning)：**
    *   **目的：** 使用训练好的奖励模型作为奖励函数，通过强化学习算法（如PPO, Proximal Policy Optimization）进一步微调语言模型。
    *   **过程：** 语言模型在接收到奖励模型的反馈（分数）后，会调整自身参数，使其倾向于生成获得高分（即更符合人类偏好）的文本。这是一个**循环迭代**的过程，不断优化模型，使其输出越来越符合人类期望。
    *   **图片内容描述：** 原始文档中的“RLHF训练过程”图示概括了这三个步骤的流程：
        *   **SFT**：一个预训练模型通过人工标注数据进行监督微调，得到一个基础模型。
        *   **训练奖励模型**：SFT后的模型生成多个回答，人类对这些回答进行偏好排序，利用这些人类偏好数据训练一个独立的奖励模型。
        *   **强化学习**：SFT后的模型作为智能体，与训练好的奖励模型（作为奖励函数）和PPO等强化学习算法结合，形成一个强化学习循环。奖励模型对语言模型的生成进行评分，强化学习算法根据这些评分优化语言模型。
    `【若需查看原始图片详情，请参考原文中的“RLHF训练过程”示意图】`

##### 4.4.4 RLHF 提升大模型实际功用
RLHF 在实践中显著提升了大语言模型在特定任务上的表现，使其更具实际应用价值：
*   **总结任务：** [Stiennon et al., 2020] 的研究表明，RLHF 能够显著提升模型在文本总结任务上的表现。
    `【若需查看原始图片详情，请参考原文中的“Performance on summarization”图表，该图通常会对比基础模型、SFT模型和RLHF模型在总结性能上的提升】`
*   **代码补全/生成：** [Bai et al., 2022] 的研究显示，在给定上下文的情况下，RLHF 能够提高模型填充 Python 函数体的能力。
    `【若需查看原始图片详情，请参考原文中的“Performance on filling python function body given the context”图表，该图通常会展示不同模型大小下，RLHF对代码生成性能的积极影响】`

##### 4.4.5 VERL: RLHF 统一框架
*   **VERL** 是一个为RLHF设计的**全流程统一框架**，它旨在将RLHF的各个核心阶段（SFT、奖励模型训练、强化学习训练）无缝集成。
*   **关键特性：**
    *   **高速策略推理与采样：** 实现了10倍以上的加速，显著提升了RLHF训练的效率。
    *   **多种RL算法支持：** 框架支持多种强化学习算法，包括PPO (Proximal Policy Optimization)、GRPO (Generalized Reinforcement Learning with Policy Optimization) 和 DPO (Direct Preference Optimization)，为研究和应用提供了灵活性。

