# 机器学习基础
## 1 智能计算系统基础概述

### 1.1 概念层次关系

在智能计算领域，**人工智能 (AI)**、**机器学习 (ML)**、**神经网络 (NN)** 和 **深度学习 (DL)** 之间存在着清晰的层次结构和包含关系。这种关系可以理解为一个由广到深、由抽象到具体的演进过程。

*   **人工智能 (AI)**：是最大的概念，是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。其目标是使机器能够像人一样思考、学习、理解和解决问题。人工智能包含多个子领域，如智能代理与规划、知识表示与推理等，而机器学习是其重要的一个分支。

*   **机器学习 (ML)**：是实现人工智能的一种核心方法。它允许计算机系统通过数据而非显式编程来学习，从而识别模式、做出决策或预测。机器学习涉及各种算法，如线性回归、逻辑回归、支持向量机、决策树等，这些算法旨在通过数据训练出模型，使其能够从经验中“学习”并改进性能。

*   **神经网络 (NN)**：是机器学习领域中的一个重要模型类别，灵感来源于人脑的神经元结构。它由相互连接的节点（或称神经元）组成，这些节点分层排列，通过权重和激活函数处理信息。神经网络是深度学习的基础。

*   **深度学习 (DL)**：是机器学习的一个子领域，它特指使用**包含多个隐藏层（即“深度”）的神经网络**进行学习的方法。深度学习模型的特点是能够自动从原始数据中学习和提取多层次的、抽象的特征表示，从而在图像识别、语音处理和自然语言处理等复杂任务中取得了突破性进展。


### 1.2 典型机器学习过程

**机器学习的定义**：
机器学习是通过**数据**和**机器学习方法**，对数据内在规律（假设）进行优化与验证，从而获得对数据/任务模式最为准确的函数建模。这意味着机器通过分析大量数据，自主发现数据中的模式和规律，并构建一个能够解释或预测这些规律的模型。

**典型机器学习过程图示描述**：
1.  **训练数据 (Training Data)**：这是机器学习过程的起点，是带有已知输入和输出对的数据集，用于训练模型。
2.  **机器学习方法 (Machine Learning Method)**：选择合适的算法（如线性回归、决策树、神经网络等），这些算法将根据训练数据学习模式。
3.  **模型/函数 (Model/Function)**：通过机器学习方法在训练数据上学习得到的结果，它是一个能够捕获数据内在规律的数学表达式或结构。
4.  **新数据 (New Data)**：当模型训练完成后，会引入模型从未见过的新数据。
5.  **预测值 (Prediction)**：模型利用学习到的函数对新数据进行处理，生成预测结果。

**示例：认识天鹅**
这个过程可以用“认识天鹅”的例子来形象说明：
*   **训练数据**：给机器看大量的图片，其中一些是天鹅的图片（标注为“天鹅”），另一些不是（标注为“不是天鹅”）。这些图片是数据，图片上的特征（如颜色、形状、大小、行为等）是输入，图片是否为天鹅是输出（标签）。
*   **机器学习方法**：采用一个分类算法（例如，神经网络），让算法分析这些图片中的像素信息和标签。
*   **模型/函数**：算法通过学习，建立起一个“天鹅识别”模型，这个模型能够根据图片的特征来判断它是否是天鹅。
*   **新数据**：给模型一张它以前没看过的图片。
*   **预测值**：模型会根据其学习到的规律，给出这张图片是“天鹅”或“不是天鹅”的预测结果。

## 2 线性回归

### 2.1 问题引入与概念

#### 2.1.1 房屋销售预测案例

在现实世界的许多场景中，我们常常需要根据已知的信息来预测某个数值。一个典型的例子是**房屋销售价格预测**。假设一个房屋销售中心拥有大量的历史交易数据，这些数据包含了房屋的各种属性（如面积、楼层、朝向等）以及对应的最终销售价格。

*   **特征 (Features)**：影响房屋价格的属性。
    *   例如，**\(x_1\)表示房屋面积**（单位可能为平方米）。
    *   例如，**\(x_2\)表示房屋楼层**。
*   **标签/目标 (Label/Target)**：我们希望预测的数值。
    *   例如，**\(y\)表示房屋售价**（单位可能为万元）。

面对这样的数据，我们的核心问题是：**如何设计一个“回归程序”来预测新房屋的售价？**

#### 2.1.2 寻找特征与售价关系

为了预测新房屋的售价，我们不能仅仅依靠销售记录中已有的数据。例如，如果销售记录中没有面积为 65 平方米的房屋，那么我们如何预测一间 65 平方米的房屋的售价\(y\)呢？

解决这个问题的关键在于：**寻找特征 \(x_1\) (房屋面积) 和售价\(y\)之间的内在关系**。这个关系一旦被“学习”或“发现”，我们就可以用它来对任何给定面积的房屋进行售价预测。**线性回归**就是一种用于发现这种数值型特征与数值型目标之间线性关系的方法。

### 2.2 线性回归模型

线性回归旨在找到一个最佳的直线（或超平面），能够“拟合”给定数据集中的点，从而揭示这些点背后的规律。

#### 2.2.1 单变量线性回归模型 (一元回归模型)

当只有一个特征（例如，只有房屋面积\(x\)）来预测目标（售价\(y\)）时，我们称之为单变量线性回归或一元回归模型。

*   **核心思想**：我们假设\(x\)和\(y\)之间存在一个近似的线性关系，可以用一条直线来表示。
*   **模型假设函数 (Hypothesis Function)**：
     \(H_w(x) = w_0 + wx\)
    *   **\(x\)**：表示**特征 (Feature)**，即自变量（如房屋面积）。
    *   **\(H_w(x)\)**：表示**假设 (Hypothesis)**，是模型对给定\(x\)的预测值。
    *   **\(w_0\)和\(w\)**：表示模型的**参数 (Parameters)**，也称为权重或系数。
        * \(w_0\)是**截距 (Intercept)**，表示当\(x=0\)时的预测值。
        * \(w\)是**斜率 (Slope)**，表示\(x\)每增加一个单位，\(H_w(x)\)的变化量。
*   **目标**：通过训练数据找到最佳的\(w_0\)和\(w\)，使得这条直线能够最好地代表数据点的分布规律。

#### 2.2.2 多变量线性回归模型

在实际问题中，影响目标变量的特征往往不止一个。例如，房屋售价\(y\)不仅受面积\(x_1\)影响，还可能受楼层\(x_2\)、朝向\(x_3\)等多个特征\(x_n\)的影响。

*   **模型假设函数 (多特征)**：
    \(H_w(x) = w_0 + w_1x_1 + w_2x_2 + \dots + w_nx_n\)
    *   **\(x_1, x_2, \dots, x_n\)**：表示\(n\)个不同的特征。
    *   **\(w_0, w_1, \dots, w_n\)**：是模型对应的参数。
*   **向量化表示 (更简洁)**：
    为了方便计算和表示，我们通常使用向量形式来表达多变量线性回归模型。
    *   定义参数向量：\(\hat{\mathbf{w}} = [w_0; w_1; \dots; w_n]\)
    *   定义特征向量（在特征前添加一个常数\(x_0=1\)用于与\(w_0\)相乘）：\(\mathbf{x} = [x_0; x_1; \dots; x_n]\)，其中\(x_0=1\)。
    *   则模型假设函数可以写为：\(H_w(\mathbf{x}) = \hat{\mathbf{w}}^T \mathbf{x}\)
    *   **意义**：不同的权重\(\hat{\mathbf{w}}\)向量意味着不同的模型假设，反映了各个特征对目标变量影响的强度和方向。

### 2.3 损失函数：均方误差 (MSE)

为了衡量我们拟合的线性函数（即模型）与实际数据点之间的契合程度，我们需要一个**损失函数 (Loss Function)**。损失函数越小，说明模型的预测越接近真实值，拟合效果越好。

#### 2.3.1 定义与目标

对于线性回归，最常用的损失函数是**均方误差 (Mean Squared Error, MSE)**。

*   **数据表示**：我们有一组观测数据，包含\(m\)个样本。每个样本\(i\)由其特征值\(\mathbf{x}^{(i)}\)和对应的真实目标值\(y^{(i)}\)组成。
    *   对于单变量：\(\{ (\mathbf{x}^{(1)}, y^{(1)}), (\mathbf{x}^{(2)}, y^{(2)}), \dots, (\mathbf{x}^{(m)}, y^{(m)}) \}\)
    *   对于多变量：\(\mathbf{x}^{(i)} = (x_{i1}; x_{i2}; \dots; x_{id})\)，其中\(d\)是特征的数量，\(y_i \in \mathbb{R}\)。
*   **均方误差定义 (针对单变量模型)**：
  \(MSE(\omega_0, \omega) = \frac{1}{m} \sum_{i=1}^{m} (y^{(i)} - (\omega_0 + \omega x^{(i)}))^2\)
    *   其中\(y^{(i)}\)是第\(i\)个样本的真实值，\((\omega_0 + \omega x^{(i)})\)是模型对第\(i\)个样本的预测值\(H_w(x^{(i)})\).
*   **均方误差定义 (针对多变量模型)**：
  \(L(\hat{\mathbf{w}}) = \frac{1}{2} \sum_{j=1}^{m} (H_w(\mathbf{x}^{(j)}) - y^{(j)})^2 = \frac{1}{2} \sum_{j=1}^{m} (\hat{\mathbf{w}}^T \mathbf{x}^{(j)} - y^{(j)})^2\)
    *   这里的\(\frac{1}{2}\)是为了求导时方便，不影响最小化结果。
*   **目标**：通过最小化这个损失函数\(L(\hat{\mathbf{w}})\)，来找到最优的参数\(\hat{\mathbf{w}}\)，使得模型的预测值尽可能接近实际值。这能使模型更好地拟合数据，提高预测的准确性。

#### 2.3.2 误差与权重修正

*   **误差 (\(\epsilon\))**：模型预测值\(\hat{y}\)与真实值\(y\)之间的差异，即\(\epsilon = y - \hat{y} = y - \hat{\mathbf{w}}^T \mathbf{x}\)。
*   **修正机制**：机器学习的核心思想就是通过不断修正模型的权重向量\(\hat{\mathbf{w}}\)，以使这种误差\(\epsilon\)尽可能地减小。这个修正过程就是模型的**训练**过程。

### 2.4 线性回归的求解方法

找到了衡量模型好坏的损失函数后，下一步就是找到能够使损失函数最小化的参数\(\hat{\mathbf{w}}\)。

#### 2.4.1 解析解 (正规方程)

对于均方误差 (MSE) 这种形式的损失函数，由于它是关于参数的二次函数，我们可以通过微积分的方法直接求解其最小值。

*   **方法原理**：
    1.  对损失函数\(L(\hat{\mathbf{w}})\)关于每个参数\(w_j\)求偏导数。
    2.  将所有偏导数组成的梯度向量设为零向量。
    3.  解这个线性方程组，得到的参数值即为最优解。
*   **正规方程 (Normal Equation)**：
    通过上述过程，可以直接得到参数\(\hat{\mathbf{w}}\)的解析表达式：
  \(\mathbf{w}^* = (\mathbf{X}^T \mathbf{X})^{-1} \mathbf{X}^T \mathbf{y}\)
    *   **\(\mathbf{X}\)**：被称为**设计矩阵 (Design Matrix)**，它的每一行代表一个训练样本的特征向量（包括\(x_0=1\)）。
    *   **\(\mathbf{y}\)**：是所有训练样本真实目标值组成的列向量。
    *   **\((\mathbf{X}^T \mathbf{X})^{-1}\)**：是矩阵\(\mathbf{X}^T \mathbf{X}\)的逆。
*   **特点与优势**：
    *   **闭式解 (Closed-form Solution)**：可以直接通过一次计算（矩阵运算）得到全局最优解，无需迭代过程。
    *   **全局最优**：对于均方误差，解析解保证找到的是全局最小值。
*   **局限性**：
    *   **计算成本**：当特征数量\(n\)非常大时（例如几十万甚至上百万），计算\((\mathbf{X}^T \mathbf{X})^{-1}\)的逆矩阵的计算成本非常高（通常为\(O(n^3)\)），这使得解析解在大规模数据集上变得不可行。
    *   **矩阵可逆性**：要求矩阵\(\mathbf{X}^T \mathbf{X}\)必须可逆。如果不可逆（例如特征之间存在高度相关性或样本数量小于特征数量），则需要使用伪逆。

除了解析解，线性回归也可以通过**梯度下降法**或**牛顿法**等迭代优化方法求解，这些方法将在后续章节中详细介绍。

### 2.5 线性假设的偏差与局限性

尽管线性回归模型简洁且易于理解，但它也有其固有的局限性。

*   **模型假设**：线性回归模型最核心的假设是：**特征\(x\)与标签\(y\)之间存在线性关系**，即\(y = \hat{\mathbf{w}}^T \mathbf{x} + b\)。
*   **局限性**：当真实世界的数据模式**过于复杂，是非线性的**时，线性回归模型就无法准确捕捉这些复杂的非线性关系。
*   **后果**：在这种情况下，即使找到了最优的线性拟合，模型也会产生明显的**系统性误差 (Systematic Error)**，这被称为**高偏差 (High Bias)**。这意味着模型过于简化，未能充分学习数据中的真实模式，导致拟合不足 (Underfitting)。例如，如果数据点呈现出抛物线或S形曲线的趋势，用一条直线去拟合将始终存在很大的偏差。

## 3 逻辑回归

### 3.1 线性分类概念

在某些机器学习任务中，我们的目标不是预测一个连续的数值（如房屋价格），而是将输入数据分到不同的类别中，这被称为**分类问题 (Classification Problem)**。

#### 3.1.1 直线/超平面分割

最简单的线性分类方法是尝试找到一个**线性边界**来区分不同的类别。

*   **二维空间示例**：
    *   考虑二维空间中的数据点，每个点由特征\(x = (x_1, x_2)\)表示。
    *   我们可以定义一个线性方程：\(w^T x = w_1x_1 + w_2x_2 = 0\)。
    *   这条直线\(w^T x = 0\)能够将二维平面分割成两个区域：\(w^T x > 0\)和\(w^T x < 0\)。
    *   我们可以将属于不同区域的点分到不同的类别。例如，如果一个点的\(w^T x > 0\)，则将其分类为类别 A；如果\(w^T x < 0\)，则分类为类别 B。
    *   向量\(w = (w_1, w_2)\)决定了这条分割线的方向，而截距项（如果包含的话）决定了其位置。

*   **高维空间（n维）**：
    *   在\(n\)维空间中，线性方程\(w^T x = 0\)定义的是一个**超平面 (Hyperplane)**。
    *   这个超平面将\(n\)维空间分割成两个半空间：\(w^T x > 0\)和\(w^T x < 0\)。
    *   通过超平面，我们可以实现对高维数据的线性分类。

#### 3.1.2 线性分类中损失函数的挑战

对于线性分类问题，直接尝试将线性回归的**均方误差 (MSE)** 损失函数应用于分类标签（例如，标签为 1 和 -1）时，会遇到一些问题：

*   **标签的意义**：在分类问题中，我们希望区分类别，而不是精确预测一个数值。MSE 衡量的是预测值与真实值之间的“距离”，这在分类任务中不一定是最合适的度量。
*   **不可导函数**：一种直观的分类损失是 0/1 损失（预测正确得 0 分，错误得 1 分）。然而，0/1 损失函数在很多点上是不可导的，这使得基于梯度的优化方法（如梯度下降法）难以应用。
*   **对离群点的敏感性**：如果使用 MSE，模型对远离决策边界的、被错误分类的点会非常敏感，会付出很大的“代价”，从而可能导致模型整体性能下降。

因此，研究者们倾向于采用**近似的、可导的、并且能够用概率来解释的平滑损失函数**来替代 0/1 损失。

### 3.2 逻辑回归

**逻辑回归 (Logistic Regression)** 是一种广泛使用的、用于解决二分类问题的统计模型。尽管名字中带有“回归”，它实际上是一个分类算法。

#### 3.2.1 从线性回归到逻辑回归的引入

线性回归模型直接输出一个连续的数值，这不适合表示类别概率（概率值应在 [0, 1] 之间）。逻辑回归通过引入一个**激活函数**来解决这个问题。

*   **局限性**：线性回归在处理非线性可分数据时表现不佳；其输出是连续值，难以直接解释为分类概率。
*   **改进思路**：将线性模型的输出通过一个函数映射到\((0, 1)\)的区间，这个输出可以被解释为样本属于某个特定类别的概率。

#### 3.2.2 Sigmoid 函数及其特性

**Sigmoid 函数**（也称为 Logistic 函数）是逻辑回归中常用的激活函数。

*   **数学形式**：
   \(\sigma(z) = \frac{1}{1 + e^{-z}}\)
    *   其中\(z\)通常是线性组合的结果，即\(z = \mathbf{w}^T \mathbf{x} + b\)(或\(\hat{\mathbf{w}}^T \mathbf{x}\)，如果包含截距项)。

*   **可视化中的良好特性**：
    *   **类似于阶跃函数**：当\(z\)变化时，\(\sigma(z)\)会迅速从接近 0 变化到接近 1。这使得它能够有效地将输入区分开。
    *   **对离群值的影响较小**：相比于直接使用线性模型的输出，Sigmoid 函数将较大的正数映射到接近 1，将较大的负数映射到接近 0，一定程度上“压缩”了输出范围，使其对离群点的敏感性降低。
    *   **连续的**：Sigmoid 函数处处可导，方便使用梯度下降等基于梯度的优化方法进行模型训练。
    *   **输出范围**：其输出始终在\((0, 1)\)之间，非常适合表示概率。

#### 3.2.3 逻辑回归模型形式

逻辑回归模型将原始特征的线性组合\(z = \mathbf{w}^T \mathbf{x} + b\)通过 Sigmoid 函数进行转换，得到样本属于正类（类别 1）的概率。

*   **模型输出**：
   \(P(y=1 | \mathbf{x}; \mathbf{w}, b) = \sigma(\mathbf{w}^T \mathbf{x} + b) = \frac{1}{1 + e^{-(\mathbf{w}^T \mathbf{x} + b)}}\)
    *   这意味着，给定输入特征\(\mathbf{x}\)，模型预测该样本属于类别 1 的概率是\(P(y=1|\dots)\)。
    *   同理，属于类别 0（或 -1，取决于标签定义）的概率是：
      \(P(y=0 | \mathbf{x}; \mathbf{w}, b) = 1 - P(y=1 | \mathbf{x}; \mathbf{w}, b) = 1 - \sigma(\mathbf{w}^T \mathbf{x} + b) = \sigma(-(\mathbf{w}^T \mathbf{x} + b))\)
*   **决策规则**：通常，如果\(P(y=1|\dots) > 0.5\)，则将样本分类为类别 1；否则，分类为类别 0。

### 3.3 损失函数：交叉熵损失 (Cross-Entropy Loss)

为了训练逻辑回归模型，我们需要选择一个合适的损失函数。对于逻辑回归，**交叉熵损失 (Cross-Entropy Loss)** 是最常用的选择。

#### 3.3.1 定义

交叉熵损失衡量的是模型预测的概率分布与真实的概率分布之间的差异。对于一个二分类问题，假设有\(m\)个样本，标签\(y\)只能是 0 或 1。

*   **交叉熵损失函数**：
  \(L(\mathbf{w}, b) = -\frac{1}{m} \sum_{i=1}^{m} \left[ y^{(i)} \log(\hat{y}^{(i)}) + (1 - y^{(i)}) \log(1 - \hat{y}^{(i)}) \right]\)
    *   其中：
        * \(y^{(i)}\)是第\(i\)个样本的真实标签 (0 或 1)。
        * \(\hat{y}^{(i)} = P(y=1 | \mathbf{x}^{(i)}; \mathbf{w}, b) = \sigma(\mathbf{w}^T \mathbf{x}^{(i)} + b)\)是模型预测的第\(i\)个样本属于类别 1 的概率。
        * \(1 - \hat{y}^{(i)}\)是模型预测的第\(i\)个样本属于类别 0 的概率。
    *   **直观解释**：
        *   如果\(y^{(i)} = 1\)，损失变为\(-\log(\hat{y}^{(i)})\)。为了最小化损失，\(\hat{y}^{(i)}\)需要接近 1。
        *   如果\(y^{(i)} = 0\)，损失变为\(-\log(1 - \hat{y}^{(i)})\)。为了最小化损失，\(\hat{y}^{(i)}\)需要接近 0（即\(1 - \hat{y}^{(i)}\)需要接近 1）。

#### 3.3.2 与最大似然估计 (MLE) 的关系

交叉熵损失函数与**最大似然估计 (Maximum Likelihood Estimation, MLE)** 密切相关。

*   **似然函数**：假设我们有一组训练数据\(\{(\mathbf{x}^{(i)}, y^{(i)})\}_{i=1}^m\)。给定模型参数\(\mathbf{w}\)和\(b\)，我们希望找到一组参数，使得观测到的训练数据的似然函数最大化。
    *   对于二分类问题，似然函数可以写为：
      \(L(\mathbf{w}, b) = \prod_{i=1}^{m} P(y^{(i)} | \mathbf{x}^{(i)}; \mathbf{w}, b)\)
    *   根据模型定义，\(P(y^{(i)} | \mathbf{x}^{(i)}; \mathbf{w}, b)\)可以写成\(\hat{y}^{(i)}\)(如果\(y^{(i)}=1\)) 或\(1-\hat{y}^{(i)}\)(如果\(y^{(i)}=0\))。
    *   更统一地，我们可以写成：\(P(y^{(i)} | \mathbf{x}^{(i)}; \mathbf{w}, b) = (\hat{y}^{(i)})^{y^{(i)}} (1 - \hat{y}^{(i)})^{1 - y^{(i)}}\)
    *   则似然函数为：\(L(\mathbf{w}, b) = \prod_{i=1}^{m} (\hat{y}^{(i)})^{y^{(i)}} (1 - \hat{y}^{(i)})^{1 - y^{(i)}}\)

*   **最大化似然等价于最小化负对数似然**：
    由于直接最大化连乘形式的似然函数在计算上很困难（容易溢出，且求导复杂），我们通常取其对数（对数函数是单调递增的，最大化对数似然等价于最大化似然），并将其变为最小化问题。
    *   对数似然：\(\log L(\mathbf{w}, b) = \sum_{i=1}^{m} \left[ y^{(i)} \log(\hat{y}^{(i)}) + (1 - y^{(i)}) \log(1 - \hat{y}^{(i)}) \right]\)
    *   最小化负对数似然：
      \(-\log L(\mathbf{w}, b) = -\sum_{i=1}^{m} \left[ y^{(i)} \log(\hat{y}^{(i)}) + (1 - y^{(i)}) \log(1 - \hat{y}^{(i)}) \right]\)
    *   如果我们再取平均值（除以\(m\)），就得到了我们之前定义的交叉熵损失函数！
      \(\text{Cross-Entropy Loss} = -\frac{1}{m} \sum_{i=1}^{m} \left[ y^{(i)} \log(\hat{y}^{(i)}) + (1 - y^{(i)}) \log(1 - \hat{y}^{(i)}) \right]\)

因此，**最小化逻辑回归的交叉熵损失函数，本质上就是通过最大似然估计来寻找最能拟合训练数据的模型参数**。

### 3.4 逻辑回归的求解

#### 3.4.1 非解析解特性

与线性回归可以通过正规方程（解析解）直接求解参数不同，逻辑回归的损失函数（交叉熵损失）在经过 Sigmoid 函数转换后，其关于参数\(\mathbf{w}\)和\(b\)的表达式是非线性的。

*   **尝试求解**：如果我们尝试直接对交叉熵损失函数求导并令导数为零，会得到一个**非线性超越方程**。
*   **结果**：这类方程通常没有简单的解析解（闭式解），意味着我们无法像线性回归那样通过一步矩阵运算直接得到最优参数。

因此，求解逻辑回归模型参数（即找到使交叉熵损失最小化的\(\mathbf{w}\)和\(b\)）需要依赖**迭代优化方法**，最常见的是**梯度下降法 (Gradient Descent)** 及其变体。

### 3.5 分类问题的激活函数选择

在神经网络的语境下，激活函数的作用是在线性组合的输出后引入非线性，从而增强模型的表达能力。对于分类问题，输出层的激活函数选择尤为重要，它决定了模型的输出形式。

#### 3.5.1 Sigmoid 函数 (二分类)

*   **用途**：当处理**二分类问题**时，Sigmoid 函数是输出层常用的激活函数。
*   **输出**：将线性组合的输出\(z\)映射到\((0, 1)\)区间，表示样本属于**正类 (类别 1)** 的概率。

#### 3.5.2 Softmax 函数 (多分类)

*   **用途**：当处理**多分类问题**（即类别数量大于 2）时，Softmax 函数是输出层常用的激活函数。
*   **输出**：对于一个\(K\)类的分类问题，Softmax 函数将一个\(K\)维的向量（通常是线性组合的输出）转换为一个概率分布。输出的每个元素表示样本属于对应类别的概率，所有输出元素的和为 1。
    *   假设线性组合的输出为\(z = (z_1, z_2, \dots, z_K)\)。
    *   Softmax 函数的输出\(\hat{y}_i\)（表示属于类别\(i\)的概率）为：
      \(\hat{y}_i = \text{Softmax}(z)_i = \frac{e^{z_i}}{\sum_{j=1}^{K} e^{z_j}}\)
    * \(\sum_{i=1}^{K} \hat{y}_i = 1\)

**注意**：在神经网络中，**隐含层**通常使用 Sigmoid、ReLU 等激活函数来引入非线性，而**输出层**的激活函数选择则取决于具体的任务（回归、二分类、多分类）。

【“2.4 神经网络训练方法”的学习笔记已生成】
## 4 神经网络训练方法

神经网络的训练核心目标是调整模型参数（权重\(\mathbf{W}\)和偏置\(\mathbf{b}\)），使得模型的输出\(\hat{\mathbf{y}}\)尽可能地逼近真实值\(\mathbf{y}\)。这个过程通常通过最小化一个损失函数\(L(\mathbf{W})\)来实现，该损失函数衡量了模型预测值与真实值之间的差异。

### 4.1 参数寻优：迭代法 (梯度下降法)

#### 4.1.1 原理与更新公式

**梯度下降法 (Gradient Descent, GD)** 是一种最常用的迭代优化算法，用于寻找损失函数最小值的参数。

*   **核心原理**：
    *   损失函数\(L(\mathbf{W})\)是关于模型参数\(\mathbf{W}\)的一个函数。
    *   **负梯度方向**是损失函数下降最快的方向。
    *   因此，通过沿着损失函数负梯度的方向更新参数，可以逐步减小损失函数的值，直到达到局部最小值（或全局最小值）。

*   **更新公式**：
   \(\mathbf{W} \leftarrow \mathbf{W} - \eta \frac{\partial L(\mathbf{W})}{\partial \mathbf{W}}\)
    *   **\(\mathbf{W}\)**：表示模型参数（可以是单个权重，也可以是权重向量或矩阵）。
    *   **\(\eta\)(eta)**：称为**学习率 (Learning Rate)** 或**步长 (Step Size)**。它控制了每次参数更新的幅度。
        *   如果\(\eta\)过大，可能导致参数更新过快，跳过最小值点，甚至发散。
        *   如果\(\eta\)过小，会导致收敛速度过慢，训练时间过长。
    *   **\(\frac{\partial L(\mathbf{W})}{\partial \mathbf{W}}\)**：表示损失函数\(L(\mathbf{W})\)关于参数\(\mathbf{W}\)的**梯度 (Gradient)**。梯度是一个向量，其每个分量是损失函数对相应参数的偏导数。

*   **迭代过程**：
    1.  **初始化参数**：随机或使用特定策略（如全零向量）初始化模型参数\(\mathbf{W}\)。
    2.  **计算梯度**：在当前参数\(\mathbf{W}\)处，计算损失函数\(L(\mathbf{W})\)对所有参数的梯度。
    3.  **更新参数**：按照上述更新公式，沿着梯度的负方向调整参数。
    4.  **重复**：重复步骤 2 和 3，直到损失函数收敛（变化非常小）或达到预设的最大迭代次数。

#### 4.1.2 梯度下降的可视化与示例

**概念可视化**：
想象损失函数\(C(x_1, x_2)\)是一个三维曲面（一个碗状），我们要找到碗底的最低点。
*   **当前点**：我们站在曲面上的某个位置\((x_1, x_2)\)。
*   **梯度**：梯度向量指向曲面上坡度最陡峭的方向。
*   **负梯度**：负梯度向量指向曲面下降最陡峭的方向。
*   **更新**：每次迭代，我们沿着负梯度方向走一小步（步长由学习率控制），从而逐步接近最低点。

**数学示例**：
*   **目标函数**：\(f(x_1, x_2) = x_1^2 + 3x_2^2 + x_1x_2\)
*   **初始点**：\((x_1, x_2) = (3, 3)\)
*   **学习率**：\(\eta = 0.2\)

**解答过程**：
1.  **计算梯度**：
   \(\nabla f(x_1, x_2) = \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2} \right) = (2x_1 + x_2, x_1 + 6x_2)\)

2.  **第 1 轮迭代**：
    *   当前点：\((x_1, x_2) = (3, 3)\)
    *   梯度：\(\nabla f(3, 3) = (2 \times 3 + 3, 3 + 6 \times 3) = (9, 21)\)
    *   更新：
       \((x_1, x_2) \leftarrow (3, 3) - 0.2 \times (9, 21)\)
       \((x_1, x_2) \leftarrow (3 - 1.8, 3 - 4.2) = (1.2, -1.2)\)

3.  **第 2 轮迭代**：
    *   当前点：\((x_1, x_2) = (1.2, -1.2)\)
    *   梯度：\(\nabla f(1.2, -1.2) = (2 \times 1.2 + (-1.2), 1.2 + 6 \times (-1.2)) = (2.4 - 1.2, 1.2 - 7.2) = (1.2, -6)\)
    *   更新：
       \((x_1, x_2) \leftarrow (1.2, -1.2) - 0.2 \times (1.2, -6)\)
       \((x_1, x_2) \leftarrow (1.2 - 0.24, -1.2 - (-1.2)) = (0.96, 0)\)

4.  **第 3 轮迭代**：
    *   当前点：\((x_1, x_2) = (0.96, 0)\)
    *   梯度：\(\nabla f(0.96, 0) = (2 \times 0.96 + 0, 0.96 + 6 \times 0) = (1.92, 0.96)\)
    *   更新：
       \((x_1, x_2) \leftarrow (0.96, 0) - 0.2 \times (1.92, 0.96)\)
       \((x_1, x_2) \leftarrow (0.96 - 0.384, 0 - 0.192) = (0.576, -0.192)\)

经过三次迭代，参数\((x_1, x_2)\)的值更新为\((0.576, -0.192)\)。
【若需查看原始图片详情，请参考原文中的“GD可视化”等高线图，它展示了迭代路径如何逐步接近最小值点。】

### 4.2 梯度下降算法的变体

机器学习模型的损失函数通常具有以下形式：
\(L = \frac{1}{N} \sum_{i} f(x_i, y_i, \mathbf{w})\)
其中\(N\)是训练样本的总数，\(f\)是单个样本的损失贡献。

#### 4.2.1 批量梯度下降 (Batch Gradient Descent, BGD)

*   **原理**：在每次参数更新时，BGD 会计算**所有**训练样本的梯度，然后根据这些梯度的平均值来更新参数。
   \(\mathbf{w}_{t+1} = \mathbf{w}_t - \eta \times \nabla L(\mathbf{w}_t) = \mathbf{w}_t - \eta \times \frac{1}{N} \sum_{i=1}^{N} \frac{\partial f(x_i, y_i, \mathbf{w}_t)}{\partial \mathbf{w}_t}\)
*   **特点**：
    *   **计算精度高**：每次更新都使用了全部样本的信息，因此梯度估计更准确，收敛路径更平滑，通常能收敛到全局最小值（对于凸函数）或较好的局部最小值。
    *   **计算复杂度高**：对于超大规模数据集，每次迭代都需要遍历整个数据集，计算成本极高，导致训练速度非常慢，甚至不可行。
    *   **内存需求大**：需要将整个数据集加载到内存中。

#### 4.2.2 随机梯度下降 (Stochastic Gradient Descent, SGD)

*   **原理**：与 BGD 相反，SGD 在每次参数更新时**随机抽取一个样本**来计算梯度，并以此样本的梯度来近似整个数据集的梯度。
   \(\mathbf{w}_{t+1} = \mathbf{w}_t - \eta \times \nabla f(x_i, y_i, \mathbf{w}_t)\)
    其中\((x_i, y_i)\)是随机选取的单个样本。
*   **特点**：
    *   **计算复杂度低**：每次更新只处理一个样本，计算速度快。
    *   **随机性强**：由于每次只使用一个样本，梯度估计具有较高的方差，导致损失函数在下降过程中会伴随显著的震荡。
    *   **可能跳出局部最优**：这种震荡有时能帮助模型跳出浅的局部最小值或鞍点，找到更好的解。
    *   **优化效率低**：虽然单次迭代快，但由于梯度估计不准确，可能需要更多次的迭代才能收敛，且可能收敛到次优解。

#### 4.2.3 Mini-batch 随机梯度下降 (Mini-batch Stochastic Gradient Descent, MBGD)

*   **原理**：MBGD 介于 BGD 和 SGD 之间。它在每次参数更新时**随机抽取一个固定大小的“小批量” (mini-batch) 样本**来计算梯度。
   \(\mathbf{g} \leftarrow \frac{1}{p} \sum_{i \in \text{batch}} \nabla f(x_i, y_i, \mathbf{w}_t)\)
   \(mathbf{w}_{t+1} = \mathbf{w}_t - \eta \times \mathbf{g}\)
    其中\(p\)是 mini-batch 的大小，\(\mathbf{g}\)是当前 mini-batch 的平均梯度。
*   **特点**：
    *   **目前深度学习领域 SGD 通常指的就是 Mini-batch SGD**。
    *   **平衡效率与准确性**：它结合了 BGD 的稳定性和 SGD 的效率。每次更新的计算量适中，梯度估计相对稳定，且能够有效利用现代并行计算的优势。
    *   **计算复杂度适中**：比 BGD 快，比 SGD 每次迭代更稳定。
    *   **更好的泛化能力**：引入的适度随机性可以帮助模型避免过拟合，提高泛化能力。
    *   **小批量的选择**：mini-batch 的大小 (\(p\)) 是一个重要的超参数，需要仔细调整。它控制着估计误差（学习方向的发散）和每个周期（epoch）的步数之间的权衡。
        *   Batch size 过小，更新频繁，收敛路径震荡，但可能跳出局部最优。
        *   Batch size 过大，更新平稳，但计算开销增加，可能陷入局部最优。

#### 4.2.4 SGD变体的优缺点与收敛过程

*   **SGD和MBGD需要更多步骤才能收敛**：相较于 BGD，SGD 和 MBGD 在每个训练周期（对整个训练数据集的一次遍历）中执行的更新步骤更多（因为每次只处理一小部分数据）。
*   **实现更快的收敛**：尽管步数多，但由于每次更新的计算量大大减少，所以**在相同时间内**，SGD 和 MBGD 通常能更快地达到一个可接受的收敛水平，尤其是在训练前期。
*   **SGD的缺点**：
    *   **学习率选择困难**：由于梯度估计的随机性，选择合适的学习率变得非常关键和困难。
    *   **容易收敛到局部最优点或困在鞍点**：虽然随机性有助于跳出浅层局部最小值，但在复杂的非凸损失函数中，SGD 仍可能被困在质量不佳的局部最优解或鞍点附近。
    *   **收敛过程中的山谷震荡**：在损失函数表面存在狭长山谷区域时，SGD 由于其梯度估计的方差大，容易在山谷两侧来回震荡，而不是直接沿谷底向下，这会显著减慢收敛速度。
        【若需查看原始图片详情，请参考原文中的“收敛过程中的山谷震荡”图示，它直观地展示了SGD在狭长山谷区域的低效震荡。】

### 4.3 梯度下降面临的挑战与解决方案

#### 4.3.1 山谷震荡问题

*   **问题描述**：在多维参数空间中，损失函数通常不是球形的，而是可能存在**狭长的山谷**。在这种区域中，损失函数在某个维度上变化剧烈（陡峭），而在另一个维度上变化缓慢（平坦）。
*   **SGD 的表现**：由于 SGD 采用小批量样本的梯度估计，存在显著的方差。这种估计偏差导致更新方向偏离最优下降路径，从而在峡谷壁间反复振荡。这种震荡使得模型无法沿主曲率方向高效下降，进而引发收敛过程不稳定和收敛速率降低的问题。
*   **步长影响**：
    *   步长设置过小时，收敛过程将十分缓慢。
    *   步长设置过大时，梯度可能会在最小值附近来回震荡，甚至发散。

#### 4.3.2 动量 (Momentum)

**动量 (Momentum)** 是一种常用的优化技术，旨在加速 SGD 在相关方向上的收敛，并抑制不相关方向上的震荡。

*   **目的**：通过积累历史梯度信息，减小梯度方向的改变，抑制梯度的震荡，从而加速收敛速度。
*   **核心思想**：引入一个“速度”或“动量”项，使参数更新不仅依赖于当前的梯度，还依赖于之前梯度的加权平均。
*   **更新公式**：
    1.  **计算梯度**：\(\mathbf{g} \leftarrow \frac{1}{p} \sum_{i \in \text{batch}} \nabla f(x_i, y_i, \mathbf{w}_t)\)(Mini-batch 梯度)
    2.  **更新动量**：\(\mathbf{v} \leftarrow \mu \times \mathbf{v} - \eta \times \mathbf{g}\)
    3.  **更新参数**：\(\mathbf{w} \leftarrow \mathbf{w} + \mathbf{v}\)
    *   **\(\mu\)(mu)**：**动量因子 (Momentum Factor)**，通常是一个接近 1 的值（如 0.9）。它决定了上一次更新对当前更新的影响程度。
    *   **\(\mathbf{v}\)**：**累计动量 (Accumulated Momentum)**，可以看作是参数更新的速度向量。
*   **直观解释**：
    *   如果连续多个梯度方向相同，动量项会不断累积，使得参数更新加速。这有助于快速穿过平坦区域。
    *   如果梯度方向频繁变化（如在山谷震荡），动量项会因正负梯度的抵消而减小，从而抑制震荡。
    *   可以类比为一个球从山坡滚下：球不仅会受当前坡度的影响，还会因为惯性（动量）而保持之前的运动趋势。

#### 4.3.3 Adam 优化器

**Adam (Adaptive Moment Estimation)** 是一种结合了动量和自适应学习率的优化算法，它在实际应用中非常流行且表现出色。Adam 通过计算梯度的一阶矩（均值）和二阶矩（未中心化方差）的指数加权移动平均来辅助参数更新。

##### 4.3.3.1 一阶矩估计 (均值)

*   **作用**：跟踪梯度的方向历史信息，表达了**“动量”**或**平均梯度方向**。
*   **公式**：
   \(\mathbf{m}_t = \beta_1 \mathbf{m}_{t-1} + (1 - \beta_1) \mathbf{g}_t\)
    *   **\(\mathbf{m}_t\)**：当前时刻的一阶矩估计向量。
    *   **\(\beta_1\)**：衰减率超参数（通常为 0.9），控制着历史梯度的影响程度。
    *   **\(\mathbf{g}_t\)**：当前时刻的梯度向量。

##### 4.3.3.2 二阶矩估计 (未中心化方差)

*   **作用**：跟踪梯度大小的历史信息，表达了**“平均学习率”**或**自适应步长**。
*   **公式**：
   \(\mathbf{v}_t = \beta_2 \mathbf{v}_{t-1} + (1 - \beta_2) \mathbf{g}_t \odot \mathbf{g}_t\)
    *   **\(\mathbf{v}_t\)**：当前时刻的二阶矩估计向量。
    *   **\(\beta_2\)**：衰减率超参数（通常为 0.999），控制着历史平方梯度的影响程度。
    *   **\(\odot\)**：表示元素级别的乘法（哈达玛积）。

##### 4.3.3.3 Adam 解决的问题与泛化能力

Adam 在参数更新时会对一阶矩和二阶矩进行**偏差修正 (Bias Correction)**，特别是在训练初期，以抵消初始化时\(\mathbf{m}_0\)和\(\mathbf{v}_0\)通常为零的偏差。修正后的公式如下：
\(\hat{\mathbf{m}}_t = \frac{\mathbf{m}_t}{1 - \beta_1^t}\)
\(\hat{\mathbf{v}}_t = \frac{\mathbf{v}_t}{1 - \beta_2^t}\)
然后，参数更新公式为：
\(\mathbf{w}_t \leftarrow \mathbf{w}_{t-1} - \eta \frac{\hat{\mathbf{m}}_t}{\sqrt{\hat{\mathbf{v}}_t} + \epsilon}\)
其中\(\epsilon\)是一个很小的常数（防止分母为零）。

*   **Adam 的优势**：
    *   **结合动量**：通过一阶矩估计，Adam 继承了动量的优点，加速在相关方向上的收敛。
    *   **自适应学习率**：通过二阶矩估计，Adam 为每个参数维护了一个独立的学习率。
        *   对于频繁出现大幅梯度的参数，\(\mathbf{v}_t\)值会增大，从而在更新时缩小其学习率。
        *   对于梯度较小的参数，则会相对放大学习率。
        *   这种机制使得 Adam 能够自动适应不同参数的尺度差异，且对稀疏梯度数据处理效果好。
    *   **解决 SGD 挑战**：Adam 基本解决了之前提到的梯度下降的一系列问题：
        *   **随机小样本**：通过动量和平滑处理减少了 SGD 的震荡。
        *   **自适应学习率**：无需手动为每个参数调整学习率。
        *   **容易卡在梯度较小点（鞍点）**：自适应学习率和动量机制有助于更好地越过或逃离鞍点。
    *   **更好的泛化能力、提高训练稳定性、适应稀疏数据和大规模分布式训练场景**。

##### 4.3.3.4 Adam 在NLP任务上的效果对比

【若需查看原始图片详情，请参考原文中的“NLP任务上的效果对比”图示】
在一项关于 LSTM 模型在 NLP 任务上的训练实验中，观察到 Adam 优化器在**训练前期比 SGD with Momentum (SGDM) 具有显著更快的收敛速度**。这表明 Adam 能够更快地找到一个较好的解，从而缩短模型训练的周期。

#### 4.3.4 梯度消失、梯度爆炸、局部最小值问题

虽然 Adam 等优化器在很大程度上缓解了梯度下降的一些问题，但对于深度神经网络，依然存在一些挑战：

*   **梯度消失问题 (Vanishing Gradients)**：
    *   **描述**：在深层神经网络中，反向传播过程中梯度会逐层传递。如果激活函数的导数（例如 Sigmoid 函数在饱和区的导数）很小，或者权重很小，那么梯度在反向传播时会呈指数级减小。
    *   **后果**：越靠近输入层的隐藏层，其权重更新会变得非常缓慢甚至停滞，导致网络无法有效学习浅层特征。

*   **梯度爆炸问题 (Exploding Gradients)**：
    *   **描述**：与梯度消失相反，如果激活函数的导数很大，或者权重很大，梯度在反向传播时可能会呈指数级增大。
    *   **后果**：导致参数更新幅度过大，模型训练不稳定，权重值剧烈震荡，甚至溢出为 NaN (Not a Number)。

*   **陷入局部最小值（或鞍点）**：
    *   **描述**：神经网络的损失函数通常是非凸的，存在多个局部最小值和鞍点。
    *   **后果**：梯度下降算法（包括其变体）可能收敛到局部最小值，而非全局最小值，或者被困在鞍点（在某个方向是最小值，在另一个方向是最大值的点），这会影响模型的最终性能。

这些问题需要通过更深层次的网络架构设计（如残差网络）、恰当的激活函数选择（如 ReLU 及其变体）、参数初始化策略、批量归一化 (Batch Normalization) 以及梯度裁剪 (Gradient Clipping) 等方法来解决。

## 5 神经网络设计基础

### 5.1 神经网络与线性/逻辑回归的联系

神经网络（Neural Networks）是机器学习领域中一种强大的模型，它的基本构建块和核心思想与前面介绍的线性回归和逻辑回归有着深厚的渊源。可以说，神经网络是在这些基本模型的基础上，通过堆叠、组合和引入非线性而发展起来的。

#### 5.1.1 神经网络与线性回归

*   **线性回归模型的局限**：线性回归模型的核心假设是特征与标签之间存在线性关系。这种**模型假设过于简单**，导致其**高偏差 (high bias)**，无法很好地建模和捕获复杂问题中的非线性模式。当真实数据关系是非线性的时，线性回归模型会产生明显的系统性误差，即拟合不足 (underfitting)。
*   **神经网络的演进**：为了克服这一局限，研究者们从线性回归的基本操作——**权重加权求和**——出发，通过**不断叠加**这种操作，并引入**非线性激活函数**，构建了能够近似任意复杂函数的神经网络。
    *   **单一神经元**：一个简单的神经元，其输出可以看作是输入特征的加权和，这与线性回归的假设函数\(H_w(x) = \sum w_i x_i + w_0\)非常相似。
    *   **多层连接**：通过将多个这样的神经元组织成层，并将层与层之间连接起来，网络的表达能力得到了极大的提升。

#### 5.1.2 神经网络与逻辑回归

*   **逻辑回归模型的局限**：逻辑回归模型虽然引入了 Sigmoid 函数来处理二分类问题，但它本质上仍然是基于线性决策边界进行分类的。这意味着它**模型假设相对单一**，仅适用于**线性可分**的问题。面对现实世界中复杂的非线性分类任务时，逻辑回归模型的表现会受到限制。
*   **神经网络的突破**：在逻辑回归的基础上，通过引入**多层结构**和**非线性激活函数**，可以构建出具有强大非线性拟合能力的神经网络。
    *   **单层感知机**：带有 Sigmoid 激活函数的单层神经网络，其行为与逻辑回归模型非常相似。
    *   **多层感知机 (MLP)**：通过堆叠多个这样的层，并使用非线性激活函数，神经网络能够学习和表示复杂的非线性决策边界。这使其能够有效处理复杂分类问题，显著提升模型的泛化性能和预测精度。
    *   **从线性到非线性**：通过多层非线性变换，神经网络能够将原始输入数据映射到一个更高维度的特征空间，在这个空间中，原本非线性可分的数据可能变得线性可分。

**总结**：神经网络可以看作是线性回归和逻辑回归的**通用化和扩展**。通过增加层次结构和引入非线性激活函数，神经网络能够克服单一线性/逻辑模型在处理复杂模式时的限制，从而具备学习和近似任意复杂函数的能力。

### 5.2 神经网络的结构与表示

神经网络通常由输入层、一个或多个隐藏层以及输出层组成。信息在这些层之间流动，经过一系列的计算和转换。

#### 5.2.1 正向传播 (Forward Propagation)

**正向传播**是神经网络在给定输入后，通过权重、偏置和激活函数逐层计算，直到得到最终输出结果的过程。它描述了信息流如何从输入层经过隐藏层到达输出层。

*   **过程描述**：
    1.  **输入层接收输入**：接收原始特征向量\(\mathbf{x}\)。
    2.  **隐藏层计算**：
        *   每个隐藏层中的神经元接收前一层（或输入层）的输出。
        *   对这些输入进行**加权求和**（线性变换），加上一个**偏置项**\(\mathbf{b}\)。
        *   将结果通过一个**激活函数\(G\)** (如 Sigmoid, ReLU 等) 进行非线性变换。
        *   例如，对于第一个隐藏层：\(\mathbf{h} = G(\mathbf{W}^{(1)T} \mathbf{x} + \mathbf{b}^{(1)})\)。
    3.  **输出层计算**：
        *   输出层接收最后一个隐藏层的输出。
        *   同样进行加权求和和偏置项的添加。
        *   再通过一个**输出激活函数\(G'\)**（例如，二分类用 Sigmoid，多分类用 Softmax，回归用线性激活）。
        *   例如，对于输出层：\(\hat{\mathbf{y}} = G'(\mathbf{W}^{(2)T} \mathbf{h} + \mathbf{b}^{(2)})\)。
*   **示例图解**：
    【若需查看原始图片详情，请参考原文中的“正向传播”图示】
    图示展示了一个简单的三层神经网络（输入层、一个隐藏层、一个输出层）。
    *   **输入**\(\mathbf{x}\)：例如\((\mathbf{x}_1, \mathbf{x}_2, \mathbf{x}_3)\)。
    *   **隐藏层**\(\mathbf{h}\)：例如\((\mathbf{h}_1, \mathbf{h}_2, \mathbf{h}_3)\)。
    *   **输出**\(\hat{\mathbf{y}}\)：例如\((\hat{\mathbf{y}}_1, \hat{\mathbf{y}}_2)\)。
    *   **权重矩阵**：\(\mathbf{W}^{(1)}\)连接输入层到隐藏层，\(\mathbf{W}^{(2)}\)连接隐藏层到输出层。
    *   **偏置向量**：\(\mathbf{b}^{(1)}\)对应隐藏层，\(\mathbf{b}^{(2)}\)对应输出层。
    *   **参数数量计算**：图示中的例子需要\(3 \times 3\)个权重和\(3\)个偏置（第一层），以及\(3 \times 2\)个权重和\(2\)个偏置（第二层），共\(9+3+6+2 = 20\)个参数。如果按照 PPT 的例子，第一层是\(3 \times 3\)权重，第二层是\(3 \times 2\)权重，偏置向量是和神经元数量对应的，所以\(W^{(1)}\)是\(3 \times 3\)加上\(b^{(1)}\)是\(3\)个，\(W^{(2)}\)是\(3 \times 2\)加上\(b^{(2)}\)是\(2\)个，共\(9+3+6+2=20\)个参数。
    *   **更复杂的例子**：一个包含两个隐藏层的神经网络，其参数数量会进一步增加（例如，PPT中给出 29 个参数的例子，计算方式为\(2 \times 3 + 3 + 3 \times 2 + 2 = 6+3+6+2 = 17\)参数，如果按照图示的连接方式，第二层权重\(3 \times 3\)加上偏置 3 个，第三层权重\(3 \times 2\)加上偏置 2 个，总共是\(2 \times 3 + 3 + 3 \times 3 + 3 + 3 \times 2 + 2 = 6+3+9+3+6+2 = 29\)个参数）。这说明了神经网络的参数数量可以非常庞大，是其强大表达能力的基础。

#### 5.2.2 多层神经网络的特征抽象能力

*   **层层抽象**：随着神经网络层数（特别是隐藏层）的增加，每一层神经元学习到的都是前一层神经元输出的更抽象、更高层次的表示。
*   **信息提炼**：输入特征从低级、原始的表示（如像素值）逐步提取为更高级、更具语义的抽象特征。
*   **示例（图像识别）**：
    【若需查看原始图片详情，请参考原文中的“多层神经网络”图像特征提取图示】
    在一个图像识别任务中：
    *   **第一个隐层**：可能学习到图像的**“边缘”特征**（如水平边缘、垂直边缘）。
    *   **第二个隐层**：可能将边缘特征组合成**“形状”特征**（如圆形、方形）。
    *   **第三个隐层**：可能进一步抽象出**“图案”特征**（如眼睛、鼻子）。
    *   **第四个隐层**：可能识别出更复杂的**“目标”特征**（如人脸、汽车）。
*   **意义**：通过这种多层级的抽象，神经网络能够从原始数据中自动学习到具有区分性的特征，从而实现对复杂事物的识别、分类或理解，并获得更好的区分与分类能力。

#### 5.2.3 多层神经网络的非线性拟合能力

*   **核心原因**：引入**非线性激活函数**是多层神经网络能够拟合非线性关系的关键。如果所有层都只进行线性变换（即使层数再多），其整体效果仍然等同于一个单层的线性模型，因为线性函数的组合仍然是线性函数。
*   **从单层到多层**：
    *   **单层感知机**：只能解决线性可分问题。
    *   **两层神经网络**：通过引入一个隐藏层和非线性激活函数，原则上可以拟合任何连续函数，例如，解决异或 (XOR) 这样的非线性可分问题。
    *   **多层神经网络 (MLP)**：随着网络层数的增加，以及激活函数的恰当选择，神经网络拟合**非线性分界**的能力不断增强。这使其能够学习高度复杂的输入-输出映射，处理各种非线性问题。
*   **交互性演示**：例如 TensorFlow Playground（`http://playground.tensorflow.org/`）等工具可以直观展示多层神经网络如何通过非线性激活函数逐步构建复杂的决策边界。

### 5.3 神经网络模型训练过程

#### 5.3.1 训练目的与核心思想

*   **训练目的**：神经网络模型训练的最终目的，就是**调整模型的所有参数**（包括权重\(\mathbf{W}\)和偏置\(\mathbf{b}\)），使得模型的计算输出\(\hat{\mathbf{y}}\)尽可能地与真实值\(\mathbf{y}\)逼近。
*   **核心思想**：通过衡量预测输出与真实值之间的差异（损失函数），并利用优化算法（如梯度下降）迭代地更新参数，以最小化这个差异。

#### 5.3.2 反向传播 (Backpropagation, BP)

**反向传播 (BP)** 是训练多层神经网络最核心的算法。它是一种高效计算梯度的方法，使得梯度下降算法能够应用于拥有多个隐藏层的神经网络。

##### 5.3.2.1 原理与链式法则

*   **基本思想**：
    1.  **正向传播**：首先进行正向传播，计算网络的输出和损失。
    2.  **反向计算误差**：根据损失函数，计算输出层与真实值之间的误差。
    3.  **误差反向传播**：将这个误差从输出层逐层向后（即向输入层方向）传播，计算每一层神经元的误差贡献。
    4.  **计算梯度**：利用各层的误差贡献和链式法则，计算损失函数对每个权重和偏置的梯度。
    5.  **更新参数**：根据计算出的梯度，使用梯度下降法更新权重和偏置。
*   **链式法则 (Chain Rule)**：反向传播算法的核心数学工具。它允许我们计算复合函数（如神经网络）的导数。
    *   **示例**：如果\(z = f(g_1(x) + g_2(x))\)，那么\(\frac{\partial z}{\partial x} = \frac{\partial z}{\partial g_1} \frac{\partial g_1}{\partial x} + \frac{\partial z}{\partial g_2} \frac{\partial g_2}{\partial x}\)。
    *   在神经网络中，损失函数\(L\)是关于输出\(\hat{\mathbf{y}}\)的函数，\(\hat{\mathbf{y}}\)是关于隐藏层输出\(\mathbf{h}\)的函数，\(\mathbf{h}\)又是关于输入\(\mathbf{x}\)和权重\(\mathbf{W}\)的函数。为了计算\(\frac{\partial L}{\partial \mathbf{W}}\)，我们需要从\(L\)开始，一步步地“链式”求导，直到所需的权重\(\mathbf{W}\)。

##### 5.3.2.2 BP 示例 (详细计算过程)

我们将通过一个具体的数值例子来理解反向传播的计算过程。
【若需查看原始图片详情，请参考原文中的“链式传导示例”图示，该图示展示了一个带有三个输入神经元、三个隐藏神经元和两个输出神经元的神经网络结构。】

*   **网络结构**：
    *   输入层：\(\mathbf{x} = [x_1, x_2, x_3]^T\)
    *   隐藏层：\(\mathbf{h} = [h_1, h_2, h_3]^T\)
    *   输出层：\(\hat{\mathbf{y}} = [\hat{y}_1, \hat{y}_2]^T\)
*   **给定值**：
    *   输入数据：\(x_1=0.02, x_2=0.04, x_3=0.01\)
    *   偏置：\(\mathbf{b}^{(1)}=[0.4; 0.4; 0.4]\),\(\mathbf{b}^{(2)}=[0.7; 0.7]\)
    *   期望输出：\(\mathbf{y} = [0.9, 0.5]^T\)
*   **初始权重**：
   \(\mathbf{W}^{(1)} = \begin{pmatrix} 0.25 & 0.15 & 0.30 \\ 0.25 & 0.20 & 0.35 \\ 0.10 & 0.25 & 0.15 \end{pmatrix}\)
   \(\mathbf{W}^{(2)} = \begin{pmatrix} 0.40 & 0.25 \\ 0.35 & 0.30 \\ 0.01 & 0.35 \end{pmatrix}\)
*   **激活函数**：所有层都使用 Sigmoid 函数\(\sigma(z) = \frac{1}{1 + e^{-z}}\)。
*   **损失函数**：均方误差 (MSE)\(L(\mathbf{W}) = \frac{1}{2} \sum_k (y_k - \hat{y}_k)^2\)

**1. 正向传播**：

*   **输入到隐层计算**：
    *   **线性组合\(\mathbf{v}\)**：
       \(\mathbf{v} = \mathbf{W}^{(1)T} \mathbf{x} + \mathbf{b}^{(1)} = \begin{pmatrix} 0.25 & 0.25 & 0.10 \\ 0.15 & 0.20 & 0.25 \\ 0.30 & 0.35 & 0.15 \end{pmatrix} \begin{pmatrix} 0.02 \\ 0.04 \\ 0.01 \end{pmatrix} + \begin{pmatrix} 0.4 \\ 0.4 \\ 0.4 \end{pmatrix} = \begin{pmatrix} 0.005+0.01+0.001 \\ 0.003+0.008+0.0025 \\ 0.006+0.014+0.0015 \end{pmatrix} + \begin{pmatrix} 0.4 \\ 0.4 \\ 0.4 \end{pmatrix} = \begin{pmatrix} 0.016 \\ 0.0135 \\ 0.0215 \end{pmatrix} + \begin{pmatrix} 0.4 \\ 0.4 \\ 0.4 \end{pmatrix} = \begin{pmatrix} 0.4160 \\ 0.4135 \\ 0.4215 \end{pmatrix}\)
    *   **隐层输出\(\mathbf{h}\)** (经过 Sigmoid 激活)：
       \(\mathbf{h} = \sigma(\mathbf{v}) = \begin{pmatrix} 1 / (1 + e^{-0.4160}) \\ 1 / (1 + e^{-0.4135}) \\ 1 / (1 + e^{-0.4215}) \end{pmatrix} \approx \begin{pmatrix} 0.6025 \\ 0.6019 \\ 0.6038 \end{pmatrix}\)

*   **隐层到输出层计算**：
    *   **线性组合\(\mathbf{z}\)**：
       \(\mathbf{z} = \mathbf{W}^{(2)T} \mathbf{h} + \mathbf{b}^{(2)} = \begin{pmatrix} 0.40 & 0.35 & 0.01 \\ 0.25 & 0.30 & 0.35 \end{pmatrix} \begin{pmatrix} 0.6025 \\ 0.6019 \\ 0.6038 \end{pmatrix} + \begin{pmatrix} 0.7 \\ 0.7 \end{pmatrix} = \begin{pmatrix} 0.2410 + 0.2107 + 0.0060 \\ 0.1506 + 0.1806 + 0.2113 \end{pmatrix} + \begin{pmatrix} 0.7 \\ 0.7 \end{pmatrix} = \begin{pmatrix} 0.4577 \\ 0.5425 \end{pmatrix} + \begin{pmatrix} 0.7 \\ 0.7 \end{pmatrix} = \begin{pmatrix} 1.1577 \\ 1.2425 \end{pmatrix}\)
    *   **输出层输出\(\hat{\mathbf{y}}\)** (经过 Sigmoid 激活)：
       \(\hat{\mathbf{y}} = \sigma(\mathbf{z}) = \begin{pmatrix} 1 / (1 + e^{-1.1577}) \\ 1 / (1 + e^{-1.2425}) \end{pmatrix} \approx \begin{pmatrix} 0.7609 \\ 0.7760 \end{pmatrix}\)

*   **计算总误差**：
    *   预测输出\(\hat{\mathbf{y}} = [0.7609, 0.7760]^T\)
    *   期望输出\(\mathbf{y} = [0.9, 0.5]^T\)
    *   总损失\(L(\mathbf{W}) = \frac{1}{2} (y_1 - \hat{y}_1)^2 + \frac{1}{2} (y_2 - \hat{y}_2)^2\)
       \(L(\mathbf{W}) = \frac{1}{2} (0.9 - 0.7609)^2 + \frac{1}{2} (0.5 - 0.7760)^2 = \frac{1}{2} (0.1391)^2 + \frac{1}{2} (-0.2760)^2 \approx 0.00967 + 0.03809 \approx 0.04776\)
        *注：PPT中显示的损失为 0.0478，与精确计算略有差异，可能为舍入误差。*
    *   由于计算值与真实值之间存在差距，我们需要通过反向传播来修改权重。

**2. 反向传播（以更新\(w^{(2)}_{2,1}\)为例）**：

我们将计算损失函数\(L(\mathbf{W})\)对权重\(w^{(2)}_{2,1}\)（即\(h_2\)到\(\hat{y}_1\)的权重，在 PPT 中表示为\(w\)）的偏导数\(\frac{\partial L}{\partial w^{(2)}_{2,1}}\)。

*   **应用链式法则**：
   \(\frac{\partial L}{\partial w^{(2)}_{2,1}} = \frac{\partial L}{\partial \hat{y}_1} \cdot \frac{\partial \hat{y}_1}{\partial z_1} \cdot \frac{\partial z_1}{\partial w^{(2)}_{2,1}}\)

*   **逐项计算**：
    1.  **\(\frac{\partial L}{\partial \hat{y}_1}\)**：
       \(L = \frac{1}{2} (y_1 - \hat{y}_1)^2 + \frac{1}{2} (y_2 - \hat{y}_2)^2\)
       \(\frac{\partial L}{\partial \hat{y}_1} = -(y_1 - \hat{y}_1) = \hat{y}_1 - y_1 = 0.7609 - 0.9 = -0.1391\)
    2.  **\(\frac{\partial \hat{y}_1}{\partial z_1}\)**：
        由于\(\hat{y}_1 = \sigma(z_1) = \frac{1}{1 + e^{-z_1}}\)，Sigmoid 函数的导数是\(\sigma(z)(1 - \sigma(z))\)。
       \(\frac{\partial \hat{y}_1}{\partial z_1} = \hat{y}_1 (1 - \hat{y}_1) = 0.7609 \times (1 - 0.7609) = 0.7609 \times 0.2391 \approx 0.1819\)
    3.  **\(\frac{\partial z_1}{\partial w^{(2)}_{2,1}}\)**：
       \(z_1 = w^{(2)}_{1,1} h_1 + w^{(2)}_{2,1} h_2 + w^{(2)}_{3,1} h_3 + b^{(2)}_1\)
        所以，\(\frac{\partial z_1}{\partial w^{(2)}_{2,1}} = h_2 = 0.6019\)

*   **整合计算梯度**：
   \(\frac{\partial L}{\partial w^{(2)}_{2,1}} = (-0.1391) \times (0.1819) \times (0.6019) \approx -0.0152\)

*   **更新权重\(w^{(2)}_{2,1}\)**：
    假设学习率\(\eta = 1.0\)(PPT中未明确给出，但从\(0.35 - (-0.0152) = 0.3652\)推断)。
   \(w^{(2)}_{2,1} \leftarrow w^{(2)}_{2,1} - \eta \times \frac{\partial L}{\partial w^{(2)}_{2,1}} = 0.35 - (1.0 \times (-0.0152)) = 0.35 + 0.0152 = 0.3652\)
    *   通过这个更新，权重\(w^{(2)}_{2,1}\)从 0.35 变为 0.3652。
    *   对所有其他权重和偏置项也进行类似的梯度计算和更新。

##### 5.3.2.3 BP 的向量化表示

为了高效地实现反向传播，通常使用向量化运算。

*   **使用 Sigmoid 作为激活函数**：
    *   Sigmoid 导数特性：\(\sigma'(z) = \sigma(z)(1-\sigma(z))\)。

*   **前向传输（向量形式）**：
    *   输入到隐层：
       \(\mathbf{v} = \mathbf{W}^{(1)T} \mathbf{x} + \mathbf{b}^{(1)}\)
       \(\mathbf{h} = \sigma(\mathbf{v})\)
    *   隐层到输出层：
       \(\mathbf{z} = \mathbf{W}^{(2)T} \mathbf{h} + \mathbf{b}^{(2)}\)
       \(\hat{\mathbf{y}} = \sigma(\mathbf{z})\)

*   **反向传播（向量形式）**：
    1.  **计算输出层误差项\(\boldsymbol{\delta}^{(2)}\)**：
        衡量输出层的误差对线性组合\(\mathbf{z}\)的影响。
        假设损失函数为均方误差\(L = \frac{1}{2} \sum (\mathbf{y}_k - \hat{\mathbf{y}}_k)^2\)，则\(\frac{\partial L}{\partial \hat{\mathbf{y}}} = \hat{\mathbf{y}} - \mathbf{y}\)。
       \(\boldsymbol{\delta}^{(2)} = (\hat{\mathbf{y}} - \mathbf{y}) \odot \sigma'(\mathbf{z}) = (\hat{\mathbf{y}} - \mathbf{y}) \odot \hat{\mathbf{y}}(1 - \hat{\mathbf{y}})\)
        这里的\(\odot\)是元素级别的乘法。

    2.  **计算隐藏层误差项\(\boldsymbol{\delta}^{(1)}\)**：
        输出层误差反向传播到隐藏层。
       \(\boldsymbol{\delta}^{(1)} = (\mathbf{W}^{(2)} \boldsymbol{\delta}^{(2)}) \odot \sigma'(\mathbf{v}) = (\mathbf{W}^{(2)} \boldsymbol{\delta}^{(2)}) \odot \mathbf{h}(1 - \mathbf{h})\)

    3.  **计算权重和偏置的梯度**：
        *   输出层权重梯度：\(\frac{\partial L}{\partial \mathbf{W}^{(2)}} = \mathbf{h} (\boldsymbol{\delta}^{(2)})^T\)
        *   输出层偏置梯度：\(\frac{\partial L}{\partial \mathbf{b}^{(2)}} = \boldsymbol{\delta}^{(2)}\)
        *   隐藏层权重梯度：\(\frac{\partial L}{\partial \mathbf{W}^{(1)}} = \mathbf{x} (\boldsymbol{\delta}^{(1)})^T\)
        *   隐藏层偏置梯度：\(\frac{\partial L}{\partial \mathbf{b}^{(1)}} = \boldsymbol{\delta}^{(1)}\)

    4.  **更新参数**：
       \(\mathbf{W} \leftarrow \mathbf{W} - \eta \frac{\partial L}{\partial \mathbf{W}}\)
       \(\mathbf{b} \leftarrow \mathbf{b} - \eta \frac{\partial L}{\partial \mathbf{b}}\)

##### 5.3.2.4 BP 算法的本质与迭代过程

*   **本质**：标准 BP 算法本质上是**梯度下降法的一种应用**，它提供了一种系统高效地计算神经网络中所有参数梯度的方法。
*   **作用**：反向传播的作用是将神经网络的输出误差反向传播到网络的输入端，并以此来更新网络中各个连接的权重和偏置。
*   **迭代训练**：
    1.  完成第一次反向传播后，网络的模型参数得到更新。
    2.  网络进行下一轮的正向传播过程。
    3.  如此反复地迭代进行训练，从而不断缩小计算值与真实值之间的误差，使模型性能逐步提升。

##### 5.3.2.5 BP 算法的缺陷

尽管 BP 算法在神经网络训练中非常有效，但它也存在一些固有的局限性，尤其是在训练深层网络时：

###### 5.3.2.5.1 梯度消失问题 (Vanishing Gradients)

*   **描述**：由于深层神经网络包含较多的隐藏层，在反向传播过程中，如果激活函数的导数（例如 Sigmoid 或 Tanh 函数在饱和区的导数很小）或者权重过小，那么梯度在通过多层链式乘法时会呈指数级减小。
*   **后果**：越靠近输入层（网络前端）的隐藏层，其梯度将变得越小，导致这些层的权重更新缓慢或停滞。这意味着浅层特征难以学习，模型训练效率低下。

###### 5.3.2.5.2 梯度爆炸问题 (Exploding Gradients)

*   **描述**：与梯度消失相反，如果激活函数的导数很大（例如 ReLU 导数始终为 1）或者权重过大，梯度在反向传播时可能会呈指数级增大。
*   **后果**：导致神经网络不稳定，权重更新过大，在训练过程中参数值迅速变得非常大，甚至溢出为 NaN (Not a Number)，使得模型无法从训练数据中很好地学习。

###### 5.3.2.5.3 局部最小值/鞍点问题 (Local Minima / Saddle Points)

*   **描述**：神经网络的损失函数通常是非凸的，在多维空间中存在大量的局部最小值和鞍点。
*   **后果**：BP 算法（作为梯度下降的一种应用）可能收敛到局部最小值而非全局最小值。在鞍点处，虽然某个方向梯度为零，但并非真正的最小值，模型可能会被困在这些点，导致无法找到最优解。

### 5.4 神经网络训练参数的选择与优化

为了提升神经网络的训练效果和模型性能，除了 BP 算法本身，还需要关注其他关键设计和优化方面。当模型训练结果不尽如人意（不准确）时，可以从以下几个方面进行调整：

#### 5.4.1 机器学习基本组件 (Data, Model, Optimizer, Loss, Metric)

训练一个机器学习模型可以看作是一个系统工程，涉及以下几个核心组件：

*   **Data (数据)**：模型的输入，包括训练数据、验证数据和测试数据。数据质量、数量和预处理对模型性能至关重要。
*   **Model (模型)**：即神经网络的架构，包括层数、每层神经元数量、连接方式等。
*   **Optimizer (优化器)**：用于调整模型参数以最小化损失函数的算法（如 SGD、Adam 等）。
*   **Loss (损失函数)**：衡量模型预测与真实值之间差异的函数。例如，\(Loss = \sum_{i=1}^n (predicted - truth)^2\)。这个函数是关于模型参数的函数。
*   **Metric (评估指标)**：用于评估模型性能的量化标准，可能与损失函数不同（例如准确率、F1-score 等）。

这五个组件共同构成了一个机器学习项目的核心要素，任何一个环节的问题都可能影响最终结果。

#### 5.4.2 选择合适的激活函数

#### 5.4.2.1 激活函数的作用

*   **引入非线性**：在神经元中，输入数据经过加权求和后，还会通过一个非线性函数\(G\)，这个函数就是**激活函数 (Activation Function)**。激活函数是多层神经网络能够学习和拟合复杂非线性模式的关键。如果没有激活函数或只使用线性激活函数，无论堆叠多少层，整个网络最终都等效于一个简单的线性模型。
*   **特征变换**：激活函数将神经元的输入信号转换成输出信号，这个输出信号将作为下一层神经元的输入。

#### 5.4.2.2 激活函数应具备的性质

一个好的激活函数通常需要具备以下性质：

*   **可微性 (Differentiability)**：这是最重要的性质之一。当优化方法是基于梯度（如反向传播）时，激活函数必须是可微的，以便能够计算梯度并更新参数。
*   **输出值的范围**：
    *   **有限范围**：当激活函数的输出值是有限的时候（如 Sigmoid、Tanh），基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著。这有助于避免梯度爆炸。
    *   **无限范围**：当激活函数的输出是无限的时候（如 ReLU），模型的训练会更加高效，但也可能更容易导致梯度爆炸，因此在这种情况下通常需要更小的学习率。
*   **非线性**：使多层网络能够学习复杂的模式。
*   **单调性**：保证损失函数是凸函数，使得梯度下降更容易收敛。
*   **计算效率**：激活函数的计算应该尽可能高效，因为在每次正向和反向传播中都会被大量调用。

#### 5.4.2.3 常用激活函数示例 (ReLU, Leaky ReLU)

*   **ReLU (Rectified Linear Unit) 函数**：
    *   **公式**：\(f(x) = \max(0, x)\)
    *   **特点**：
        *   解决了 Sigmoid 和 Tanh 在正区间饱和导致的梯度消失问题，因为它在\(x > 0\)时导数恒为 1。
        *   计算效率高，只需判断大小。
        *   但可能导致“死亡 ReLU”问题，即当\(x \le 0\)时神经元不再激活，梯度为 0，无法更新。

*   **Leaky ReLU 函数**：
    *   **公式**：\(f(x) = \max(\alpha x, x)\)，其中\(\alpha \in (0, 1)\)是一个很小的正数（例如 0.01）。
    *   **特点**：
        *   解决了 ReLU 的“死亡 ReLU”问题，因为它在\(x < 0\)时依然有一个小的非零梯度\(\alpha\)，允许信息通过。
        *   保持了 ReLU 的计算效率。

#### 5.4.3 选择恰当的损失函数

*   **定义**：损失函数\(L = f(\hat{\mathbf{y}}, \mathbf{y})\)，其中\(\hat{\mathbf{y}}\)是模型预测值，\(\mathbf{y}\)是真实值。模型预测值\(\hat{\mathbf{y}}\)是神经网络模型参数\(\mathbf{W}\)的函数，记作\(\hat{\mathbf{y}} = H_W(\mathbf{x})\)。因此，从参数\(\mathbf{W}\)的角度看，损失函数可以记为\(L(\mathbf{W}) = f(H_W(\mathbf{x}), \mathbf{y})\)。
*   **作用**：损失函数用于**评价网络模型的好坏**。损失函数值越小，说明模型及其参数越符合训练样本\((\mathbf{x}, \mathbf{y})\)所反映的真实数据模式。
*   **选择依据**：选择何种损失函数取决于具体的任务类型：
    *   **回归任务**：常用均方误差 (MSE)、平均绝对误差 (MAE) 等。
    *   **二分类任务**：常用二元交叉熵损失 (Binary Cross-Entropy Loss)。
    *   **多分类任务**：常用类别交叉熵损失 (Categorical Cross-Entropy Loss)。

