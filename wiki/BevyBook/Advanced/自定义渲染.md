# 自定义渲染## 概述

**学习目标**：
- 理解 Bevy 渲染系统的基本概念
- 掌握自定义材质的创建
- 学会编写自定义着色器（WGSL）
- 了解自定义后处理效果的实现
- 理解自定义渲染阶段和实例化

**前置知识要求**：
- 3D 渲染基础
- 着色器基础
- WGSL 语言基础
- 渲染管线基础

## 核心概念

### 什么是自定义渲染？

自定义渲染是在 Bevy 默认渲染系统基础上，创建自定义的渲染效果。这包括自定义材质、自定义着色器、自定义后处理效果等。

**为什么需要自定义渲染？**

1. **特殊效果**：实现默认渲染系统不支持的特殊效果
2. **性能优化**：针对特定场景优化渲染性能
3. **艺术风格**：实现特定的艺术风格和视觉效果
4. **扩展功能**：扩展 Bevy 的渲染功能

### 自定义渲染的核心组件

Bevy 自定义渲染系统包含以下核心组件：

- **Material**：材质系统，用于定义材质属性
- **Shader**：着色器，用于定义渲染逻辑
- **RenderGraph**：渲染图，用于组织渲染管线
- **RenderPhase**：渲染阶段，用于组织渲染对象
- **Instancing**：实例化，用于批量渲染

## 基础用法

### 自定义材质

创建自定义材质。

**源代码文件**：`bevy/examples/shader_advanced/custom_post_processing.rs`

**代码示例**：

```rust
use bevy::{
    prelude::*,
    render::{
        extract_component::{
            ExtractComponent, ExtractComponentPlugin, UniformComponentPlugin,
        },
        render_resource::*,
    },
};

#[derive(Component, Clone, Copy)]
struct PostProcessSettings {
    intensity: f32,
}

impl ExtractComponent for PostProcessSettings {
    type Query = &'static Self;
    type Filter = ();
    type Out = Self;

    fn extract_component(item: QueryItem<Self::Query>) -> Option<Self::Out> {
        Some(*item)
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(ExtractComponentPlugin::<PostProcessSettings>::default())
        .add_plugins(UniformComponentPlugin::<PostProcessSettings>::default())
        .run();
}
```

**关键要点**：
- 使用 `ExtractComponent` trait 提取组件到渲染世界
- 使用 `UniformComponentPlugin` 将组件数据传递到 GPU
- 材质数据通过 uniform buffer 传递到着色器
- 可以在主世界控制材质属性

**说明**：
自定义材质允许你创建自己的材质类型。通过 `ExtractComponent` 和 `UniformComponentPlugin`，可以将主世界的组件数据传递到渲染世界，并在着色器中使用。

### 自定义着色器（WGSL）

编写自定义着色器。

**源代码文件**：`bevy/examples/shader_advanced/custom_post_processing.rs`

**着色器示例**：

```wgsl
#import bevy_core_pipeline::tonemapping::tone_mapping

@group(0) @binding(0)
var<uniform> settings: PostProcessSettings;

@group(0) @binding(1)
var main_texture: texture_2d<f32>;

@group(0) @binding(2)
var main_texture_sampler: sampler;

@fragment
fn fragment(in: FragmentInput) -> @location(0) vec4<f32> {
    let color = textureSample(main_texture, main_texture_sampler, in.uv);
    let tone_mapped = tone_mapping(color);
    return vec4<f32>(tone_mapped * settings.intensity, 1.0);
}
```

**关键要点**：
- 使用 WGSL 编写着色器
- 通过 uniform buffer 访问材质数据
- 使用 `textureSample` 采样纹理
- 可以应用后处理效果

**说明**：
自定义着色器允许你实现自己的渲染逻辑。Bevy 使用 WGSL 作为着色器语言，支持现代图形 API。

### 自定义后处理效果

创建自定义后处理效果。

**源代码文件**：`bevy/examples/shader_advanced/custom_post_processing.rs`

**代码示例**：

```rust
use bevy::{
    core_pipeline::core_3d::graph::{Core3d, Node3d},
    prelude::*,
    render::{
        render_graph::{RenderGraphContext, RenderLabel, ViewNode, ViewNodeRunner},
        render_resource::*,
        RenderApp, RenderStartup,
    },
};

#[derive(RenderLabel)]
struct PostProcessLabel;

struct PostProcessNode;

impl ViewNode for PostProcessNode {
    type ViewQuery = (
        &'static ViewTarget,
        &'static PostProcessSettings,
    );

    fn run(
        &self,
        _graph: &mut RenderGraphContext,
        render_context: &mut RenderContext,
        (view_target, settings): QueryItem<Self::ViewQuery>,
        world: &World,
    ) -> Result<(), NodeRunError> {
        // 实现后处理逻辑
        Ok(())
    }
}

fn init_post_process_pipeline(mut render_app: ResMut<RenderApp>) {
    render_app
        .add_render_graph_node::<ViewNodeRunner<PostProcessNode>>(
            Core3d,
            PostProcessLabel,
        )
        .add_render_graph_edges(
            Core3d,
            (
                Node3d::Tonemapping,
                PostProcessLabel,
                Node3d::EndMainPassPostProcessing,
            ),
        );
}
```

**关键要点**：
- 使用 `ViewNode` trait 创建自定义渲染节点
- 使用 `RenderGraph` 组织渲染管线
- 通过 `ViewTarget` 访问渲染目标
- 可以读取和写入渲染纹理

**说明**：
自定义后处理效果允许你在渲染完成后对图像进行处理。通过 `ViewNode` 和 `RenderGraph`，可以创建自己的后处理管线。

### 自定义顶点属性

创建自定义顶点属性。

**源代码文件**：`bevy/examples/shader_advanced/custom_vertex_attribute.rs`

**关键信息**：
- 使用 `MeshVertexAttribute` 定义自定义顶点属性
- 在着色器中访问自定义顶点属性
- 可以传递额外的顶点数据到着色器

**说明**：
自定义顶点属性允许你传递额外的顶点数据到着色器。这对于实现特殊效果非常有用。

### 自定义实例化

实现自定义实例化渲染。

**源代码文件**：`bevy/examples/shader_advanced/custom_shader_instancing.rs`

**关键信息**：
- 使用实例化渲染批量绘制相同对象
- 通过实例数据传递每个实例的属性
- 可以显著提高渲染性能

**说明**：
自定义实例化允许你批量渲染相同对象，每个实例可以有不同的属性。这对于渲染大量相似对象非常有用。

### 自定义渲染阶段

创建自定义渲染阶段。

**源代码文件**：`bevy/examples/shader_advanced/custom_render_phase.rs`

**关键信息**：
- 使用 `RenderPhase` 组织渲染对象
- 可以创建自己的渲染阶段
- 可以控制渲染顺序和方式

**说明**：
自定义渲染阶段允许你组织渲染对象，控制渲染顺序和方式。这对于实现复杂的渲染效果非常有用。

## 进阶用法

### 高级着色器技术

使用高级着色器技术。

**关键信息**：
- 使用计算着色器进行 GPU 计算
- 使用纹理数组和采样器数组
- 实现复杂的渲染效果

**说明**：
高级着色器技术可以让你实现更复杂的渲染效果。通过计算着色器和高级纹理技术，可以实现各种视觉效果。

### 渲染管线优化

优化自定义渲染管线。

**关键信息**：
- 减少渲染目标切换
- 优化着色器性能
- 使用批处理和实例化
- 合理使用渲染阶段

**说明**：
渲染管线优化可以提高自定义渲染的性能。通过减少状态切换、优化着色器、使用批处理等技术，可以显著提高性能。

## 实际应用

### 在游戏开发中的应用场景

自定义渲染在游戏开发中有广泛的应用：

1. **特殊效果**：实现水、火、烟雾等特殊效果
2. **艺术风格**：实现卡通、像素等艺术风格
3. **后处理**：实现泛光、色差、色调映射等后处理效果
4. **性能优化**：针对特定场景优化渲染性能

### 常见问题

**问题 1**：如何创建自定义材质？

**解决方案**：实现 `Material` trait，使用 `ExtractComponent` 和 `UniformComponentPlugin` 将数据传递到 GPU。

**问题 2**：如何编写自定义着色器？

**解决方案**：使用 WGSL 编写着色器，通过 uniform buffer 访问材质数据，使用 `textureSample` 采样纹理。

**问题 3**：如何实现自定义后处理效果？

**解决方案**：使用 `ViewNode` trait 创建自定义渲染节点，通过 `RenderGraph` 组织渲染管线。

### 性能考虑

1. **着色器优化**：优化着色器代码，减少计算量
2. **批处理**：使用批处理和实例化减少绘制调用
3. **纹理优化**：合理使用纹理格式和大小
4. **渲染目标**：减少渲染目标切换

## 相关资源

**相关源代码文件**：
- `bevy/examples/shader_advanced/custom_post_processing.rs` - 自定义后处理示例
- `bevy/examples/shader_advanced/custom_vertex_attribute.rs` - 自定义顶点属性示例
- `bevy/examples/shader_advanced/custom_shader_instancing.rs` - 自定义实例化示例
- `bevy/examples/shader_advanced/custom_render_phase.rs` - 自定义渲染阶段示例
- `bevy/examples/shader_advanced/specialized_mesh_pipeline.rs` - 专用网格管线示例

**官方文档链接**：
- [Bevy 渲染系统文档](https://docs.rs/bevy/latest/bevy/render/index.html)
- [WGSL 规范](https://www.w3.org/TR/WGSL/)
- [着色器示例](https://github.com/bevyengine/bevy/tree/main/examples/shader_advanced)

**进一步学习建议**：
- 学习 WGSL 语言，了解着色器编程
- 学习渲染管线，了解渲染流程
- 学习性能优化，了解如何优化自定义渲染

---

**索引**：[返回上级目录](/wiki/BevyBook/Advanced/)

