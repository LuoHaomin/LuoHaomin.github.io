# 性能优化## 概述

**学习目标**：
- 理解 Bevy 性能优化的基本概念
- 掌握性能分析工具的使用
- 学会优化 ECS 查询和系统调度
- 了解渲染优化技巧
- 掌握内存优化方法
- 理解大规模实体处理

**前置知识要求**：
- ECS 基础
- 系统调度基础
- 渲染基础
- 资源管理基础

## 核心概念

### 什么是性能优化？

性能优化是提高应用运行效率的过程。在 Bevy 中，性能优化涉及多个方面，包括 ECS 查询优化、系统调度优化、渲染优化、内存优化等。

**为什么需要性能优化？**

1. **提高帧率**：优化可以提高游戏的帧率，提供更流畅的体验
2. **减少延迟**：优化可以减少输入延迟，提高响应性
3. **降低资源消耗**：优化可以降低 CPU 和内存使用
4. **支持更大规模**：优化可以支持更多实体和更复杂的场景

### 性能优化的核心原则

1. **测量优先**：在优化之前先测量性能
2. **识别瓶颈**：找到真正的性能瓶颈
3. **针对性优化**：针对瓶颈进行优化
4. **验证效果**：优化后验证效果

## 基础用法

### 性能分析工具

使用 Bevy 的诊断插件进行性能分析。

**源代码文件**：`bevy/examples/stress_tests/bevymark.rs`

**代码示例**：

```rust
use bevy::{
    diagnostic::{DiagnosticsStore, FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin},
    prelude::*,
};

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(FrameTimeDiagnosticsPlugin)
        .add_plugins(LogDiagnosticsPlugin::default())
        .add_systems(Update, print_diagnostics)
        .run();
}

fn print_diagnostics(diagnostics: Res<DiagnosticsStore>) {
    if let Some(fps) = diagnostics.get(&FrameTimeDiagnosticsPlugin::FPS) {
        if let Some(value) = fps.smoothed() {
            println!("FPS: {:.2}", value);
        }
    }
}
```

**关键要点**：
- 使用 `FrameTimeDiagnosticsPlugin` 监控帧率
- 使用 `LogDiagnosticsPlugin` 记录诊断信息
- 使用 `DiagnosticsStore` 访问诊断数据
- 可以监控 FPS、帧时间等指标

**说明**：
性能分析是优化的第一步。通过诊断插件，可以监控应用的性能指标，识别性能瓶颈。

### ECS 查询优化

优化 ECS 查询以提高性能。

**源代码文件**：`bevy/examples/stress_tests/many_cubes.rs`

**关键信息**：
- 使用精确的查询过滤器减少查询范围
- 避免不必要的组件访问
- 使用并行查询提高性能
- 合理使用 `Changed` 过滤器

**说明**：
ECS 查询是性能的关键。通过优化查询，可以减少不必要的组件访问，提高系统执行效率。

### 系统调度优化

优化系统调度以提高性能。

**关键信息**：
- 合理组织系统集（SystemSet）
- 使用运行条件（Run Conditions）避免不必要的执行
- 利用并行执行提高性能
- 避免系统间的数据竞争

**说明**：
系统调度优化可以提高系统的执行效率。通过合理组织系统，可以充分利用并行执行，提高性能。

### 渲染优化

优化渲染以提高性能。

**源代码文件**：`bevy/examples/stress_tests/many_cubes.rs`

**代码示例**：

```rust
use bevy::{
    camera::visibility::{NoCpuCulling, NoFrustumCulling},
    render::{
        batching::NoAutomaticBatching,
        view::NoIndirectDrawing,
    },
    prelude::*,
};

// 禁用视锥剔除（用于压力测试）
commands.spawn((
    Camera3d::default(),
    NoFrustumCulling,
    NoCpuCulling,
));

// 禁用自动批处理（用于压力测试）
commands.spawn((
    Mesh3d(mesh_handle),
    MeshMaterial3d(material_handle),
    NoAutomaticBatching,
    NoIndirectDrawing,
));
```

**关键要点**：
- 使用视锥剔除（Frustum Culling）减少渲染对象
- 使用遮挡剔除（Occlusion Culling）进一步优化
- 使用批处理（Batching）减少绘制调用
- 使用实例化渲染（Instancing）提高性能

**说明**：
渲染优化是性能优化的重要部分。通过使用剔除、批处理、实例化等技术，可以显著提高渲染性能。

### 内存优化

优化内存使用以提高性能。

**关键信息**：
- 合理使用资源生命周期
- 及时清理不再使用的资源
- 使用对象池减少分配
- 避免不必要的克隆

**说明**：
内存优化可以减少内存分配和垃圾回收，提高性能。通过合理管理资源生命周期，可以避免内存泄漏。

### 大规模实体处理

处理大规模实体以提高性能。

**源代码文件**：`bevy/examples/stress_tests/bevymark.rs`

**代码示例**：

```rust
use bevy::prelude::*;

const BIRDS_PER_SECOND: u32 = 10000;

fn spawn_birds(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    time: Res<Time>,
) {
    let bird_count = (BIRDS_PER_SECOND as f32 * time.delta_secs()) as u32;
    
    for _ in 0..bird_count {
        commands.spawn((
            Mesh3d(meshes.add(Cuboid::new(0.1, 0.1, 0.1))),
            MeshMaterial3d(materials.add(Color::srgb(0.5, 0.5, 1.0))),
            Transform::from_xyz(
                rand::random::<f32>() * 100.0 - 50.0,
                rand::random::<f32>() * 100.0 - 50.0,
                rand::random::<f32>() * 100.0 - 50.0,
            ),
            Bird {
                velocity: Vec3::new(
                    rand::random::<f32>() * 2.0 - 1.0,
                    rand::random::<f32>() * 2.0 - 1.0,
                    rand::random::<f32>() * 2.0 - 1.0,
                ),
            },
        ));
    }
}
```

**关键要点**：
- 使用批处理减少绘制调用
- 使用实例化渲染提高性能
- 合理使用剔除减少渲染对象
- 优化实体创建和销毁

**说明**：
大规模实体处理是性能优化的挑战。通过使用批处理、实例化、剔除等技术，可以支持更多实体。

## 进阶用法

### 高级性能分析

使用更高级的性能分析工具。

**关键信息**：
- 使用性能分析器（如 `tracy`、`puffin`）
- 分析系统执行时间
- 识别热点函数
- 优化关键路径

**说明**：
高级性能分析可以提供更详细的性能信息，帮助识别性能瓶颈。

### 自定义批处理

实现自定义批处理策略。

**关键信息**：
- 理解批处理原理
- 实现自定义批处理逻辑
- 优化批处理性能
- 处理批处理边界情况

**说明**：
自定义批处理可以根据具体需求优化批处理策略，提高性能。

## 实际应用

### 在游戏开发中的应用场景

性能优化在游戏开发中有广泛的应用：

1. **大规模场景**：优化大规模场景的渲染性能
2. **复杂系统**：优化复杂系统的执行效率
3. **移动平台**：优化移动平台的性能
4. **实时应用**：优化实时应用的响应性

### 常见问题

**问题 1**：如何识别性能瓶颈？

**解决方案**：使用性能分析工具，如 `FrameTimeDiagnosticsPlugin`、`LogDiagnosticsPlugin`，或者使用外部性能分析器。

**问题 2**：如何优化 ECS 查询？

**解决方案**：使用精确的查询过滤器，避免不必要的组件访问，使用并行查询，合理使用 `Changed` 过滤器。

**问题 3**：如何优化渲染性能？

**解决方案**：使用视锥剔除、遮挡剔除、批处理、实例化渲染等技术。

### 性能考虑

1. **测量优先**：在优化之前先测量性能
2. **识别瓶颈**：找到真正的性能瓶颈
3. **针对性优化**：针对瓶颈进行优化
4. **验证效果**：优化后验证效果

## 相关资源

**相关源代码文件**：
- `bevy/examples/stress_tests/bevymark.rs` - 2D 性能测试示例
- `bevy/examples/stress_tests/many_cubes.rs` - 3D 性能测试示例
- `bevy/examples/stress_tests/many_sprites.rs` - 精灵性能测试示例
- `bevy/examples/stress_tests/README.md` - 性能测试说明

**官方文档链接**：
- [Bevy 性能优化文档](https://bevyengine.org/learn/book/getting-started/performance/)
- [性能测试示例](https://github.com/bevyengine/bevy/tree/main/examples/stress_tests)

**进一步学习建议**：
- 学习自定义渲染，了解如何优化渲染管线
- 学习大规模实体开发，了解如何处理大规模场景
- 学习性能分析工具，了解如何识别性能瓶颈

---

**索引**：[返回上级目录](/wiki/BevyBook/Advanced/)

