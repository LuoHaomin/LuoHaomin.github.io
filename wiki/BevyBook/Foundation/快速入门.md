# 快速入门## 概述

**学习目标**：

- 创建第一个 Bevy 应用
- 理解 Bevy 应用的基本结构
- 学会定义和注册系统
- 理解 Bevy 应用的生命周期

**前置知识要求**：

- Rust 基础语法
- 基本的 Rust 项目结构
- Cargo 包管理器使用

## 核心概念

### Bevy 应用是什么？

Bevy 应用是使用 Bevy 游戏引擎创建的程序。每个 Bevy 应用都基于 ECS（Entity Component System）模式构建。

**为什么使用 Bevy？**

1. **数据导向**：功能由数据驱动，而非继承层次
2. **高性能**：大规模并行执行，缓存友好
3. **易用性**：简洁的 API，易于学习和使用
4. **模块化**：插件化架构，易于扩展

### Bevy 应用的基本结构

Bevy 应用由以下部分组成：

- **App**：应用主入口，管理应用生命周期
- **System**：系统函数，处理游戏逻辑
- **Schedule**：系统调度，控制系统的执行顺序
- **Plugin**：插件，封装相关功能

## 基础用法

### 创建最简单的 Bevy 应用

创建一个输出 "hello world" 的最简单 Bevy 应用。

**源代码文件**：`bevy/examples/hello_world.rs`

**代码示例**：

```rust
use bevy::prelude::*;

fn main() {
    App::new().add_systems(Update, hello_world_system).run();
}

fn hello_world_system() {
    println!("hello world");
}
```

**关键要点**：

- 使用 `App::new()` 创建应用
- 使用 `add_systems()` 注册系统
- `Update` 是系统调度，表示系统在每次更新时运行
- 使用 `run()` 启动应用
- 系统是普通 Rust 函数

**说明**：
这是最简单的 Bevy 应用。`App::new()` 创建了一个新的应用实例，`add_systems(Update, hello_world_system)` 将系统注册到 `Update` 调度中，`run()` 启动应用并进入主循环。系统 `hello_world_system` 在每次应用更新时运行，输出 "hello world"。

### 配置 Bevy 项目

在开始编写 Bevy 应用之前，需要配置项目依赖。

**配置步骤**：

1. 在 `Cargo.toml` 中添加 Bevy 依赖

```toml
[dependencies]
bevy = "0.15"  # 确保这是最新版本
```

2. 或者使用 Cargo 命令添加

```bash
cargo add bevy
```

**关键要点**：

- 确保使用最新版本的 Bevy
- Bevy 版本可能会影响 API 使用方式
- 建议使用 `cargo add` 命令自动管理依赖

**说明**：
Bevy 是一个快速发展的项目，API 可能会发生变化。使用最新版本可以确保获得最新的功能和修复。

### 应用生命周期

Bevy 应用有不同的调度阶段，控制系统的执行顺序。

**源代码文件**：`bevy/examples/hello_world.rs`

**代码示例**：

```rust
fn main() {
    App::new()
        .add_systems(Startup, startup_system)  // 启动系统，运行一次
        .add_systems(Update, update_system)   // 更新系统，每次更新运行
        .run();
}

fn startup_system() {
    println!("应用启动");
    }
    
fn update_system() {
    println!("应用更新");
        }
```

**关键要点**：

- `Startup`：启动系统，在应用启动时运行一次
- `Update`：更新系统，在每次应用更新时运行
- 系统按调度顺序执行
- 启动系统在更新系统之前执行

**说明**：
启动系统用于初始化应用状态，如创建初始实体、加载资源等。更新系统用于处理游戏逻辑，如处理输入、更新游戏状态等。

## 进阶用法

### 系统执行顺序

可以通过 `.before()` 和 `.after()` 方法控制系统的执行顺序。

**代码示例**：

```rust
fn main() {
    App::new()
        .add_systems(Update, (
            system_a,
            system_b.after(system_a),  // system_b 在 system_a 之后运行
            system_c.before(system_b), // system_c 在 system_b 之前运行
        ))
        .run();
}
```

**注意事项**：

- 系统执行顺序影响游戏逻辑
- 确保依赖关系正确
- 避免循环依赖

**最佳实践**：

- 使用 `.before()` 和 `.after()` 明确指定顺序
- 将相关系统组织在一起
- 避免不必要的顺序依赖

### 使用插件

插件是封装相关功能的模块，可以简化应用配置。

**代码示例**：

```rust
fn main() {
    App::new()
        .add_plugins(DefaultPlugins)  // 添加默认插件
        .add_systems(Update, hello_world_system)
        .run();
}
```

**注意事项**：

- `DefaultPlugins` 包含窗口、输入、渲染等基本功能
- 可以根据需要选择插件
- 插件可以自定义配置

**最佳实践**：

- 使用 `DefaultPlugins` 快速开始
- 根据需要添加或移除插件
- 创建自定义插件封装功能

## 实际应用

### 在游戏开发中的应用场景

快速入门是学习 Bevy 的第一步，为后续学习打下基础：

1. **项目初始化**：创建新的 Bevy 项目
2. **系统注册**：注册游戏逻辑系统
3. **应用配置**：配置应用的基本设置

### 常见问题

**问题 1**：如何运行 Bevy 应用？

**解决方案**：使用 `cargo run` 命令运行应用。确保在项目根目录下执行。

**问题 2**：系统什么时候运行？

**解决方案**：系统在注册的调度阶段运行。`Startup` 系统运行一次，`Update` 系统每次更新运行。

**问题 3**：如何调试 Bevy 应用？

**解决方案**：使用 `println!` 输出调试信息，或使用 Bevy 的诊断工具。

### 性能考虑

- **系统优化**：尽量减少系统的执行时间
- **并行执行**：系统可以并行执行，提高性能
- **资源管理**：合理管理资源，避免内存泄漏

## 相关资源

**相关源代码文件**：
- `bevy/examples/hello_world.rs` - Hello World 示例
- `bevy/examples/app/empty.rs` - 空应用示例
- `bevy/examples/app/empty_defaults.rs` - 带默认插件的空应用示例

**官方文档链接**：
- [Bevy 快速入门指南](https://bevyengine.org/learn/quick-start/introduction)
- [Bevy 官方文档](https://bevyengine.org/learn/)
- [Bevy 官方示例](https://github.com/bevyengine/bevy/tree/main/examples)

**进一步学习建议**：
- 学习 ECS 基础，理解 Bevy 的核心编程范式
- 学习资源管理，了解如何加载和管理资源
- 学习输入处理，了解如何处理用户输入

---

**索引**：[返回上级目录](/wiki/bevybook/foundation/)

