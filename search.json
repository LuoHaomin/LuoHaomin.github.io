[{"title":"写在前面","path":"/Luo-Haomin/2025/10/14/写在前面/","content":"我开始重新维护这个博客了。 希望能在这里记录一些有趣的想法和见解，记录一些技术上的探索和学习。","tags":["大纲"]},{"title":"Hexo Stellar 主题使用指南","path":"/Luo-Haomin/2025/10/12/Hexo主题-stellar/","content":"本博客使用的是Hexo搭建的，使用了Hexo主题中的Stellar主题。 Stellar主题是一个功能极其丰富的综合型 Hexo 主题，包含博客系统、知识库系统、专栏系统、笔记系统，内置海量的标签和动态数据组件。它不仅支持传统的博客写作，还提供了文档管理、知识库、专栏系统等高级功能，特别适合技术博客、知识分享和个人品牌建设。 环境要求在开始使用 Stellar 主题之前，请确保您的环境满足以下要求： Hexo: 6.3.0 ~ latesthexo-cli: 4.3.0 ~ latestnode: 14.17.3 ～ latest LTS # 建议选择 LTS 版本npm: 6.14.13 ~ latest 安装配置1. 安装主题# 在 Hexo 根目录下安装主题npm install hexo-theme-stellar 2. 启用主题在 _config.yml 中设置主题： theme: stellar 3. 创建主题配置文件创建 _config.stellar.yml 文件来配置主题： # 复制主题默认配置cp node_modules/hexo-theme-stellar/_config.yml _config.stellar.yml 基础配置站点基本信息在 _config.yml 中配置站点基本信息： # Sitetitle: 我的博客subtitle: 一行字|A line of codedescription: 这是我的个人博客author: 您的名字language: zh-CNtimezone: Asia/Shanghai# URLurl: https://your-domain.compermalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true trailing_html: true 主题基础配置在 _config.stellar.yml 中配置主题： # Logo 配置logo: avatar: [config.avatar](/about/) title: [config.title](/) subtitle: config.subtitle# 样式配置style: prefers_theme: auto # auto / light / dark smooth_scroll: true font-size: root: 16px body: 17px code: 85% 博客系统使用创建博客文章使用 Hexo 命令创建新文章： hexo new post 文章标题 文章 Front-matter 配置Stellar 主题支持丰富的 Front-matter 配置选项： ---# 基本信息title: 文章标题date: 2025-01-01 12:00:00tags: [标签1, 标签2] # 文章的标签categories: [分类1, 分类2] # 文章的分类description: 文章描述 # 或使用 excerpt# 封面和横幅cover: /images/cover.jpg # 封面小图banner: /images/banner.jpg # 文章顶部大图# 海报（可选）poster: topic: 专栏名称 # 标题上方的小字 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: #FF6B35 # 标题颜色# 功能开关sticky: 1 # 置顶，数字越大越靠前comments: true # 是否允许评论indexing: true # 是否被搜索索引breadcrumb: true # 是否显示面包屑导航# 页面布局type: tech # tech: 技术类文章, story: 故事类文章leftbar: recent, related # 左侧栏组件rightbar: toc, ghrepo # 右侧栏组件h1: 文章标题 # 设置为 隐藏标题# 专栏和作者topic: blogtool # 专栏 idauthor: author_name # 作者 id# 数学公式和图表mermaid: true # 启用 Mermaid 图表katex: true # 启用 KaTeX 数学公式mathjax: true # 启用 MathJax 数学公式---文章摘要，会显示在列表页面。!-- more --文章正文内容... 文章类型说明Stellar 支持两种文章类型： tech：技术类文章，适合代码和技术文档，代码块样式更突出 story：故事类文章，文字间距更大，适合阅读体验 页面管理创建普通页面hexo new page about 页面 Front-matter： ---title: 关于我date: 2025-01-01 12:00:00layout: pagemenu_id: 关于 # 高亮的菜单项--- 自定义页面布局---title: 自定义页面layout: pageleftbar: recentrightbar: toc--- Wiki文档系统使用Wiki 系统是 Stellar 主题的核心功能之一，适合构建知识库和项目文档。根据源码分析，Wiki 系统通过数据文件配置和页面关联来实现项目管理。 Wiki 系统工作原理Wiki 系统通过以下机制工作： 项目配置管理：在 source/_data/wiki/ 目录下创建项目配置文件 页面关联：通过页面的 wiki 字段关联到具体项目 自动生成：通过 wiki.js generator 自动生成 Wiki 列表页面 项目分类：支持通过标签对项目进行分类 页面树构建：根据配置的 tree 结构构建页面导航 创建 Wiki 文档系统第一步：创建项目配置文件在 source/_data/wiki/ 目录下创建项目配置文件，例如 my-project.yml： title: 我的项目description: 项目文档icon: solar:document-2-bold-duotonecolor: #3DC550tags: [前端, 教程] # 项目标签，用于分类sort: 1 # 排序权重，数字越大越靠前base_dir: wiki/my-project/ # 项目页面基础路径tree: # 页面树结构配置 基础: [index, getting-started] 高级: [advanced, deployment]homepage: index # 指定首页，可选 第二步：创建 Wiki 页面在 source/wiki/my-project/ 目录下创建页面文件： # 创建项目页面hexo new page wiki/my-project/indexhexo new page wiki/my-project/getting-startedhexo new page wiki/my-project/advanced 第三步：配置页面 Front-matter每个 Wiki 页面需要配置相应的 Front-matter： ---title: 快速开始wiki: my-project # 关联到项目配置layout: wiki # 使用 wiki 布局--- 第四步：配置 Wiki 上架在 source/_data/wiki.yml 中配置要显示的项目： # 上架的项目列表，只有在此列表中的项目才会在 Wiki 首页显示- my-project- another-project Wiki 页面结构示例source/├── _data/│ ├── wiki/│ │ └── my-project.yml # 项目配置│ └── wiki.yml # Wiki 上架配置└── wiki/ └── my-project/ ├── index.md # 项目首页 ├── getting-started.md # 基础页面 └── advanced.md # 高级页面 Wiki 系统特性 项目卡片展示：在 Wiki 首页以卡片形式展示所有上架项目 标签分类：支持通过标签对项目进行分类筛选 页面树导航：根据配置的 tree 结构生成页面导航 自动首页：未指定 homepage 时，自动选择 TOC 第一页作为首页 相关项目推荐：基于标签推荐相关项目 注意： 页面路径匹配：确保页面文件路径与 base_dir + tree 配置匹配# 配置base_dir: wiki/my-project/tree: 基础: [index, getting-started]# 对应的页面文件source/wiki/my-project/index.mdsource/wiki/my-project/getting-started.md 多个页面：Tree 组件只有在项目有多个页面时才会显示，单个页面不会显示导航树 笔记本系统使用笔记本系统适合管理学习笔记和知识整理，通过标签树结构实现层级化管理。 笔记本系统工作原理笔记本系统通过以下机制工作： 笔记本配置：在 source/_data/notebooks/ 目录下配置笔记本 标签树管理：使用层级标签实现笔记分类 自动生成：通过 generator 自动生成笔记本列表页面 标签云展示：自动生成标签云和标签树 创建笔记本系统第一步：创建笔记本配置在 source/_data/notebooks/ 目录下创建笔记本配置文件，例如 hexo.yml： title: Hexo 学习笔记description: Hexo 相关学习笔记icon: solar:notebook-bookmark-bold-duotonecolor: #FA6400menu_id: notesleftbar: tagtree, recentrightbar: toc 第二步：创建笔记文章使用标准的 Hexo 命令创建文章： hexo new post Hexo 基础教程 第三步：配置笔记 Front-matter在笔记的 Front-matter 中指定笔记本： ---title: Hexo 基础教程notebook: hexotags: [Hexo/基础, Hexo/教程]layout: notes--- 标签树结构使用笔记本系统支持层级标签，使用 / 分隔符： tags: [Hexo/基础/安装, Hexo/配置/主题, JavaScript/ES6/箭头函数] 这会生成如下的标签树结构： Hexo├── 基础│ └── 安装├── 配置│ └── 主题JavaScript└── ES6 └── 箭头函数 笔记本系统特性 层级标签：支持多级标签分类 标签云：自动生成可视化标签云 标签树：侧边栏显示层级标签树 笔记统计：显示每个标签下的笔记数量 专栏系统使用专栏系统适合系列文章管理，通过 topic 配置实现文章分组。 专栏系统工作原理专栏系统通过以下机制工作： 专栏配置：在 source/_data/topic/ 目录下配置专栏 文章关联：通过 topic 字段关联文章到专栏 专栏页面：自动生成专栏列表页面 文章分组：在专栏页面中按时间或分类显示文章 创建专栏系统第一步：创建专栏配置在 source/_data/topic/ 目录下创建专栏配置文件，例如 blogtool.yml： title: 博客工具description: 博客相关工具使用教程icon: solar:documents-bold-duotonecolor: #1BCDFCmenu_id: postleftbar: recent, relatedrightbar: toc 第二步：创建专栏文章创建文章时在 Front-matter 中指定专栏： ---title: Hexo 主题配置topic: blogtoollayout: post--- 专栏系统特性 文章分组：自动将同专栏文章分组显示 专栏导航：在专栏页面显示所有相关文章 系列标识：在文章页面显示所属专栏信息 统计信息：显示专栏文章数量等统计信息 菜单配置菜单栏是 Stellar 主题的核心导航组件，位于左侧边栏顶部。 Menubar 配置在 _config.stellar.yml 中配置菜单： menubar: columns: 4 # 一行显示多少个菜单项 items: # 菜单项列表 - id: post # 页面中高亮的 menu_id theme: #1BCDFC # 高亮时的颜色 icon: solar:documents-bold-duotone # 图标 title: 博客 # 标题 url: / # 跳转链接 - id: wiki theme: #3DC550 icon: solar:document-2-bold-duotone title: 文档 url: /wiki/ - id: notes theme: #FA6400 icon: solar:notebook-bookmark-bold-duotone title: 笔记 url: /notebooks/ - id: 关于 theme: #F44336 icon: solar:backpack-bold-duotone title: 关于 url: /about 菜单高亮逻辑Stellar 主题的菜单高亮遵循以下优先级： 第一优先级：页面 Front-matter---title: 我的文章menu_id: wiki # 直接指定高亮哪个菜单--- 第二优先级：笔记本配置# 在笔记本配置中指定notebook: menu_id: notes 第三优先级：页面类型自动判断 博客文章 → post 专栏文章 → post 文档页面 → wiki 笔记页面 → notebooks 笔记本列表 → notebooks 作者页面 → post 404页面 → post 自定义图标在 source/_data/icons.yml 中定义自定义图标： # 自定义图标custom:my-icon: svg xmlns=http://www.w3.org/2000/svg width=32 height=32 viewBox=0 0 24 24 path fill=currentColor d=...//svg 图标要求： 尺寸：width=32 height=32 颜色：使用 fill=currentColor 以支持主题色 移除硬编码的颜色属性 侧边栏配置侧边栏组件Stellar 提供了丰富的侧边栏组件： 左侧栏组件# _config.stellar.ymlsite_tree: post: leftbar: recent, related, tagtree # 博客文章左侧栏 wiki: leftbar: tree, related, recent # 文档页面左侧栏 右侧栏组件site_tree: post: rightbar: toc, ghrepo # 博客文章右侧栏 wiki: rightbar: toc, ghrepo # 文档页面右侧栏 可用组件列表 组件名 功能 说明 welcome 欢迎信息 个性化欢迎组件 recent 最近更新 显示最新文章 related 相关文章 智能推荐文章 tagtree 标签树 层级标签展示 tagcloud 标签云 可视化标签 toc 目录 文章目录导航 tree 页面树 上下篇文章 ghrepo GitHub 仓库 仓库信息展示 ghuser GitHub 用户 用户信息展示 timeline 时间线 动态时间线 author 作者信息 作者卡片 组件配置示例# _config.stellar.ymlwidgets: recent: layout: recent limit: 10 # 显示数量 rss: /atom.xml # RSS 源 tagcloud: layout: tagcloud title: 标签云 min_font: 12 max_font: 24 amount: 100 color: true # 使用颜色 timeline: layout: timeline title: 近期动态 api: https://api.github.com/repos/user/repo/issues limit: 20 插件功能数学公式支持KaTeX 配置# _config.stellar.ymlplugins: katex: enable: true copy_tex: true mhchem: true 在文章中使用： ---katex: true--- MathJax 配置plugins: mathjax: enable: true config: tex2jax: inlineMath: [[$,$], [\\\\(,\\\\)]] displayMath: [[$$,$$], [\\\\[,\\\\]]] Mermaid 图表plugins: mermaid: enable: true theme: neutral 使用： graph TD A[开始] -- B判断 B --|是| C[执行A] B --|否| D[执行B] C -- E[结束] D -- E 评论系统支持多种评论服务： Beaudar 配置# _config.stellar.ymlcomments: service: beaudar beaudar: repo: username/repo issue_term: pathname theme: github-light Utterances 配置comments: service: utterances utterances: repo: username/repo issue_term: pathname theme: github-light Giscus 配置comments: service: giscus giscus: repo: username/repo repo_id: repo_id category_id: category_id mapping: pathname theme: light 搜索功能本地搜索# _config.stellar.ymlsearch: service: local local: enable: true path: search.json field: post,page content: true format: html Algolia 搜索search: service: algolia algolia: appId: your_app_id apiKey: your_api_key indexName: your_index_name 自定义样式主题色配置# _config.stellar.ymlstyle: color: theme: hsl(192 98% 55%) # 主题色 accent: hsl(14 100% 57%) # 强调色 link: hsl(207 90% 54%) # 链接色 字体配置style: font-family: body: system-ui, Microsoft Yahei, Segoe UI, Arial, sans-serif code: Menlo, Monaco, Consolas, system-ui, monospace, sans-serif font-size: root: 16px body: 17px code: 85% 圆角配置style: border-radius: card-l: 24px # 侧边栏、文章横幅 card: 16px # 文章内卡片 card-s: 12px # 小型卡片 bar: 8px # 横条元素 image-l: 24px # 非技术类文章插图 image: 16px # 技术类文章插图 自定义 CSS创建 source/css/_custom.styl 文件： // 自定义样式.custom-class color: var(--theme) font-weight: bold// 覆盖主题样式.nav-item border-radius: 12px 标签组件Note 标签标题正文，颜色有这些：redorangeyellowgreencyanbluepurplelightdarkwarningerror，通过[color:color]指定 Box 标签标题 正文，也可以指定[color:color] [child:codeblocktabs] 折叠% folding title [codeblock:bool] [open:bool] [color:color] %content% endfolding % 就像这样： 标题 codeblock:true # 这里是代码块def hello(): print(Hello, World!) 题目1 这是答案1题目2 这是答案2题目3 这是答案3 grid% grid %!-- cell --一个单元格!-- cell --另一个单元格% endgrid % 一个单元格 另一个单元格 tab图片代码块表格let x = 123print(hello world) a b c a1 b1 c1 a2 b2 c2 timeline% timeline 标题 %!-- node 时间点1 --事件描述1!-- node 时间点2 --事件描述2% endtimeline % 小提示 实际上，你如果用VSCode作为编辑器，你可以使用代码片段来快速插入标签。以下是一个代码片段的示例：codesnippets Stellar Note: scope: markdown, prefix: /note, body: [ % note $1:标题 $2:正文 [color:$3:blue] % ], description: Stellar Note 标签\t,\tStellar Box: scope: markdown, prefix: /box, body: [ % box $1:标题 [color:$2:blue] %, $3:正文内容, % endbox % ], description: Stellar Box 标签\t,\tStellar Folding: scope: markdown, prefix: /folding, body: [ % folding $1:标题 $2:[open:true] $3:[color:cyan] %, $4:折叠内容, % endfolding % ], description: Stellar Folding 折叠标签\t,\tStellar Folders: scope: markdown, prefix: /folders, body: [ % folders %, !-- folder $1:题目1 --, $2:这是答案1, !-- folder $3:题目2 --, $4:这是答案2, % endfolders % ], description: Stellar Folders 折叠组标签\t,\tStellar Grid: scope: markdown, prefix: /grid, body: [ % grid %, !-- cell --, $1:一个单元格, !-- cell --, $2:另一个单元格, % endgrid % ], description: Stellar Grid 网格标签\t,\tStellar Tabs: scope: markdown, prefix: /tabs, body: [ % tabs $1:active:1 $2:align:center %, , !-- tab $3:标签1 --, $4:内容1, , !-- tab $5:标签2 --, $6:内容2, , % endtabs % ], description: Stellar Tabs 标签页","tags":["Hexo","主题","教程"]},{"title":"Hexo使用速查表","path":"/Luo-Haomin/2025/10/12/Hexo使用速查表/","content":"1. 初始化和安装 npm install -g hexo-cli 全局安装 Hexo 命令行工具。 hexo init 初始化一个新的 Hexo 项目。 npm install 安装项目依赖。 配置：在_config.yml中可以修改博客的配置。 2. 生成和预览 hexo g 或 hexo generate 生成静态文件。 hexo s 或 hexo server 启动本地开发服务器预览博客。 3. 部署 npm install hexo-deployer-git --save 安装 Git 部署插件。 hexo d 或 hexo deploy 部署博客到远程仓库。 4. 主题管理 git clone 主题仓库URL themes/主题名 克隆主题到项目主题目录。 cd themes/主题名 npm install 进入主题目录并安装主题依赖。 5. 项目维护 npm ls --depth 0 查看项目依赖树。 npm audit fix 修复项目依赖的安全漏洞。 hexo clean 清理生成的文件和缓存。如果修改了配置，需要先清理缓存才生效。 6. 页面和文章管理 hexo new page 页面名 创建新页面。 hexo new post 文章名 创建新文章。 7. 其他实用命令 npm cache clean --force 清理 npm 缓存。 rm -rf node_modules rm package-lock.json 删除 node_modules 目录和 package-lock.json 文件，用于重新安装依赖。","tags":["Hexo"]},{"title":"项目介绍","path":"/Luo-Haomin/wiki/SoW/index.html","content":"项目介绍SoW 是一个专注于世界建模和仿真的高效平台。"},{"title":"Bevy 教程完整索引","path":"/Luo-Haomin/wiki/BevyBook/INDEX.html","content":"Bevy 教程完整索引本文档提供 Bevy 教程的完整索引，方便快速查找和学习。 目录结构tutorial_book/├── Foundation/ # 基础部分├── ECS/ # 实体组件系统├── Assets/ # 资源管理├── Input/ # 输入处理├── Animation/ # 动画系统├── 2D_Graphics/ # 2D 图形├── 3D_Graphics/ # 3D 图形├── UI_Audio_Window/ # UI、音频与窗口├── Architecture/ # 架构设计├── Advanced/ # 高级主题└── Examples/ # 示例项目 第一部分：基础（Foundation）1. 快速入门 安装 Bevy 配置开发环境 第一个 Bevy 程序 项目结构 2. Bevy 与 Rust 框架 Bevy 简介 Rust 基础 Bevy 架构 核心概念 3. 游戏引擎基础 游戏引擎核心概念 游戏循环 资源管理 渲染管线 索引文件：FoundationREADME.md 第二部分：ECS（实体组件系统）1. 核心编程框架（ECS） ECS 概述 核心概念 设计思想 2. 组件（Components） 组件基础 组件类型 组件存储 组件访问 3. 实体（Entities） 实体基础 实体创建 实体查询 实体删除 4. 系统（Systems） 系统基础 系统定义 系统参数 系统执行 5. 查询（Queries） 查询基础 查询类型 查询过滤 查询优化 6. 资源（Resources） 资源基础 资源访问 资源管理 全局资源 7. 命令（Commands） 命令基础 实体命令 组件命令 资源命令 8. 系统调度（Schedule 与 App） 调度基础 调度阶段 系统顺序 并行执行 9. 状态管理（State） 状态基础 状态定义 状态转换 状态系统 10. 时间系统（Time） 时间基础 游戏时间 固定时间步 时间控制 11. ECS 进阶 高级查询 变更检测 事件系统 性能优化 索引文件：ECSREADME.md 第三部分：资源管理（Assets）1. 资源管理 资源加载 资源生命周期 异步加载 热重载 自定义资源 2. 场景系统（Scene） 场景基础 场景保存 场景加载 场景序列化 索引文件：AssetsREADME.md 第四部分：输入处理（Input）1. 输入基础 输入系统概述 输入事件 输入状态 2. 输入处理 键盘输入 鼠标输入 游戏手柄输入 触摸输入 IME 输入 3. 拾取系统（Picking） 拾取基础 2D 拾取 3D 拾取 拾取事件 索引文件：InputREADME.md 第五部分：动画系统（Animation）1. 动画基础 动画概述 AnimationClip AnimationPlayer 动画播放 2. 动画进阶 动画混合 动画事件 动画遮罩 缓动函数 3. UI 动画 UI 动画基础 UI 动画组件 UI 动画系统 4. 变形目标 变形目标基础 变形目标创建 变形目标动画 索引文件：AnimationREADME.md 第六部分：2D 图形（2D Graphics）1. 2D 基础 2D 渲染基础 精灵（Sprite） 2D 相机 2D 变换 2. 2D 开发 精灵动画 精灵表 2D 物理 2D 后处理 索引文件：2D_GraphicsREADME.md 第七部分：3D 图形（3D Graphics）1. 3D 开发 3D 模型 材质系统 光照系统 后处理效果 2. 相机系统（Camera） 相机基础 相机类型 相机控制 多相机 索引文件：3D_GraphicsREADME.md 第八部分：UI、音频与窗口（UI Audio Window）1. 窗口管理 窗口创建 窗口配置 多窗口 透明窗口 窗口截图 2. 用户界面（UI） UI 系统概述 UI 组件 UI 布局 UI 样式 UI 交互 3. 音频系统 音频加载 背景音乐 音效 音频控制 3D 音频 索引文件：UI_Audio_WindowREADME.md 第九部分：架构设计（Architecture）1. 代码组织 项目结构 模块化设计 文件组织 命名规范 2. 逻辑-渲染分离 MainWorld 与 RenderApp ExtractSchedule 数据流向 Headless 模式 3. 插件系统 插件基础 插件组 插件依赖 插件生命周期 索引文件：ArchitectureREADME.md 第十部分：高级主题（Advanced）1. 性能优化 性能分析 ECS 优化 渲染优化 内存优化 2. 自定义渲染 自定义材质 自定义着色器 自定义后处理 自定义渲染阶段 3. 网络编程 网络基础 服务器端开发 客户端开发 网络同步 4. 拆解学习 源代码阅读 架构分析 功能扩展 性能分析 索引文件：AdvancedREADME.md 第十一部分：示例项目（Examples）示例项目索引 完整项目示例 最佳实践 代码示例 学习路径新手路径 Foundation（基础） → 了解 Bevy 和 Rust 基础 ECS（实体组件系统） → 掌握 Bevy 的核心编程范式 Assets（资源管理） → 学习如何加载和管理资源 Input（输入处理） → 处理用户输入 Graphics（图形渲染） → 根据需求选择 2D 或 3D UI Audio Window → 添加用户界面、音效和窗口管理 进阶路径 Animation（动画系统） → 添加动画效果 Architecture（架构设计） → 学习如何组织大型项目 Advanced（高级主题） → 深入高级功能 专家路径 自定义渲染 → 实现自定义渲染效果 网络编程 → 开发多人游戏 拆解学习 → 深入理解 Bevy 内部机制 快速查找按主题查找 ECS 相关：ECS 目录下的所有文件 渲染相关：2D_Graphics、3D_Graphics、Advanced自定义渲染.md 输入相关：Input 目录下的所有文件 资源相关：Assets 目录下的所有文件 架构相关：Architecture 目录下的所有文件 按难度查找 入门：Foundation、ECS组件（Components）.md、ECS实体（Entities）.md 中级：ECS查询（Queries）.md、Assets资源管理.md、Input输入处理.md 高级：Advanced 目录下的所有文件、Architecture逻辑-渲染分离.md 相关资源 主 README - 教程概览 学习路径 - 详细学习路径 架构文档 - 教程架构说明 贡献指南 - 贡献指南 最后更新：2025-01-XX"},{"title":"学习路径指南","path":"/Luo-Haomin/wiki/BevyBook/LEARNING_PATH.html","content":"学习路径指南本指南帮助你根据不同的学习目标选择合适的学习路径。 学习目标路径 1：快速入门（1-2 天）目标：快速了解 Bevy，能够创建简单的程序 学习内容： Foundation（基础） - 快速入门 ECS（实体组件系统） - ECS 基础 Assets（资源管理） - 资源加载基础 Input（输入处理） - 输入基础 预计时间：4-6 小时 成果：能够创建一个简单的交互式程序 路径 2：2D 游戏开发（1-2 周）目标：掌握 2D 游戏开发，能够创建完整的 2D 游戏 学习内容： Foundation（基础） - 全部内容 ECS（实体组件系统） - 全部内容 Assets（资源管理） - 全部内容 Input（输入处理） - 全部内容 2D Graphics（2D 图形） - 全部内容 UI Audio（界面与音频） - UI 部分 Architecture（架构设计） - 代码组织 预计时间：20-30 小时 成果：能够开发完整的 2D 游戏 路径 3：3D 游戏开发（2-3 周）目标：掌握 3D 游戏开发，能够创建完整的 3D 游戏 学习内容： Foundation（基础） - 全部内容 ECS（实体组件系统） - 全部内容 Assets（资源管理） - 全部内容 Input（输入处理） - 全部内容 3D Graphics（3D 图形） - 全部内容 UI Audio（界面与音频） - 全部内容 Architecture（架构设计） - 全部内容 预计时间：30-40 小时 成果：能够开发完整的 3D 游戏 路径 4：高级开发者（1-2 个月）目标：深入理解 Bevy，能够进行高级开发和优化 学习内容： 路径 2 或路径 3 的全部内容 Advanced（高级主题） - 全部内容 阅读 Bevy 源码 参与 Bevy 社区 预计时间：50-80 小时 成果：能够进行高级开发、性能优化和插件开发 路径 5：特定领域深入学习5.1 专注于 ECS学习内容： ECS（实体组件系统） - 全部内容 Advanced（高级主题） - 性能优化 Bevy ECS 源码阅读 5.2 专注于渲染学习内容： 2D Graphics（2D 图形） - 全部内容 3D Graphics（3D 图形） - 全部内容 Advanced（高级主题） - 自定义渲染 5.3 专注于网络学习内容： ECS（实体组件系统） - 全部内容 Architecture（架构设计） - 全部内容 Advanced（高级主题） - 网络编程 学习计划建议每日学习计划（2-3 小时天）第 1 周： 第 1-2 天：Foundation + ECS 基础 第 3-4 天：ECS 进阶 + Assets 第 5-6 天：Input + 2D3D 基础 第 7 天：复习和实践 第 2 周： 第 8-9 天：2D3D 开发 第 10-11 天：UI Audio 第 12-13 天：Architecture 第 14 天：项目实践 第 3-4 周： Advanced 主题学习 项目开发 源码阅读 学习建议1. 理论与实践结合 理论学习：阅读教程文档，理解概念 实践练习：编写代码，运行示例 项目实践：完成实际项目 2. 循序渐进 不要跳过基础内容 确保理解每个概念再继续 遇到问题及时查阅文档 3. 多写代码 每学完一个概念就写代码 修改示例代码 尝试实现自己的想法 4. 参与社区 加入 Bevy Discord 阅读其他人的代码 提问和回答问题 5. 持续学习 Bevy 在快速发展 关注更新和变化 阅读源码和文档 相关资源 Bevy 官方文档 Bevy 官方示例 Bevy Cheatbook Bevy Discord 索引：返回主目录"},{"title":"Bevy 完整教程","path":"/Luo-Haomin/wiki/BevyBook/README.html","content":"Bevy 完整教程欢迎来到 Bevy 游戏引擎完整教程！本教程旨在帮助你从零开始掌握 Bevy 游戏开发。 教程结构本教程采用渐进式学习路径，从基础概念到高级应用，帮助你系统地学习 Bevy。 学习路径Foundation（基础） ↓ECS（实体组件系统） ↓Assets（资源管理） ↓Input（输入处理） ↓Graphics（图形渲染） ├── 2D Graphics └── 3D Graphics ↓UI Audio（界面与音频） ↓Architecture（架构设计） ↓Advanced（高级主题） 目录第一部分：基础（Foundation） 快速入门 - 安装、配置、第一个程序 Bevy 与 Rust 框架 - Bevy 简介、Rust 基础 游戏引擎基础 - 游戏引擎核心概念 索引文件：FoundationREADME.md 第二部分：ECS（实体组件系统）ECS 是 Bevy 的核心编程范式，理解 ECS 是掌握 Bevy 的关键。 核心编程框架（ECS） - ECS 概述 ECS 基础 - 组件、实体、系统基础 ECS 进阶 - 查询、资源、事件系统 Relationship（关系） - 实体间关系系统 索引文件：ECSREADME.md 第三部分：资源管理（Assets） 资源管理 - 资源加载、生命周期、异步加载 索引文件：AssetsREADME.md 第四部分：输入处理（Input） 输入基础 - 输入系统概述 输入处理 - 键盘、鼠标、游戏手柄 索引文件：InputREADME.md 第五部分：图形渲染（Graphics）2D 图形 2D 基础 - 2D 渲染基础概念 2D 开发 - 精灵、相机、2D 物理 索引文件：2D_GraphicsREADME.md 3D 图形 3D 开发 - 3D 模型、材质、光照、相机 索引文件：3D_GraphicsREADME.md 第六部分：UI、音频与窗口（UI Audio Window） 窗口管理 - 窗口创建、配置、多窗口、透明窗口 用户界面（UI） - UI 组件、布局、样式、交互 音频系统 - 音频加载、播放控制、3D 音频 索引文件：UI_Audio_WindowREADME.md 第七部分：架构设计（Architecture） 代码组织 - 项目结构、模块化设计 逻辑-渲染分离 - MainWorld 与 RenderApp 插件系统 - 创建插件、插件组、插件管理 索引文件：ArchitectureREADME.md 第八部分：高级主题（Advanced） 性能优化 - 优化技巧、性能分析 自定义渲染 - 自定义着色器、渲染管线 网络编程 - 多人游戏、网络同步 拆解学习 - 深入理解 Bevy 内部机制 索引文件：AdvancedREADME.md 第九部分：示例项目（Examples） 示例项目索引 - 完整项目示例 快速开始如果你是 Bevy 新手，建议按以下顺序学习： Foundation（基础） - 了解 Bevy 和 Rust 基础 ECS（实体组件系统） - 掌握 Bevy 的核心编程范式 Assets（资源管理） - 学习如何加载和管理资源 Input（输入处理） - 处理用户输入 Graphics（图形渲染） - 根据你的需求选择 2D 或 3D UI Audio Window（界面、音频与窗口） - 添加用户界面、音效和窗口管理 Architecture（架构设计） - 学习如何组织大型项目 Advanced（高级主题） - 深入高级功能 教程特点 渐进式学习：从简单到复杂，循序渐进 实用示例：每个概念都配有实际代码示例 中文友好：全中文教程，降低学习门槛 完整覆盖：涵盖 Bevy 的核心功能和高级特性 最佳实践：分享实际开发中的经验和技巧 相关资源 Bevy 官方文档 Bevy 官方示例 Bevy Cheatbook Bevy Discord 许可证本教程遵循与 Bevy 相同的许可证。 贡献欢迎提交问题和改进建议！ 最后更新：2025-01-XX"},{"title":"待整理","path":"/Luo-Haomin/notes/Fragment/待整理.html","content":"技术相关2025-10-15提示词工程与POML（prompt orchestration markup language）通过结构化提示词提高生成内容的质量Procedural Animation通过程序化方式生成动画一种简单的程序性动画技术-argonautWord解决MarkDown粘贴公式问题我在写专利时，需要将内容从Notion复制到Word中，但发现公式没能正确粘贴，仍然保留“$公式$”。采用“Alt+F11”打开Microsoft Visual Basic for Applications，插入新模块，粘贴以下代码： Sub ConvertEquations() 最终稳定版：采用倒序处理逻辑，确保转换成功 [5](@ref) On Error GoTo ErrorHandler Dim sel As Selection Dim selRange As Range Dim positions As New Collection Dim i As Long Dim currentPos As Long Dim startPos As Long, endPos As Long --- 检查是否有选区 --- If Selection.Type = wdSelectionIP Then MsgBox 请先选中需要转换的文本区域！, vbExclamation, 操作提示 Exit Sub End If Set sel = Application.Selection Set selRange = sel.Range --- 阶段一：安全查找，只记录公式位置，不修改文档 --- currentPos = 1 Do While currentPos = Len(selRange.Text) startPos = InStr(currentPos, selRange.Text, $) If startPos = 0 Then Exit Do endPos = InStr(startPos + 1, selRange.Text, $) If endPos = 0 Then Exit Do 将找到的位置对（相对于选区开头）添加到集合中 Dim posPair(1) As Long posPair(0) = startPos posPair(1) = endPos positions.Add posPair currentPos = endPos + 1 Loop --- 阶段二：从后往前，根据记录的位置进行转换 --- If positions.Count 0 Then For i = positions.Count To 1 Step -1 Dim currentRange As Range Dim currentPair As Variant currentPair = positions(i) Set currentRange = selRange.Duplicate currentRange.Start = selRange.Start + currentPair(0) - 1 currentRange.End = selRange.Start + currentPair(1) 提取两个$符号之间的公式文本 Dim equationText As String equationText = Mid(currentRange.Text, 2, Len(currentRange.Text) - 2) 去掉首尾的$ 清除当前范围的内容（包括$符号），并插入公式 currentRange.Delete Set currentRange = ActiveDocument.Range(currentRange.Start, currentRange.Start) currentRange.Text = equationText currentRange.OMaths.Add currentRange currentRange.OMaths.BuildUp Next i End If MsgBox 转换成功！共处理 positions.Count 个行内公式。, vbInformation, 操作完成 Exit SubErrorHandler: MsgBox 发生了一个错误: Err.Description, vbCritical, 宏运行错误End Sub 关闭之后，回到Word，按“Alt+F8”，选择“ConvertEquations”，点击“运行”即可。 2025-10-16 生活相关2025-10-15技术与与思维的相互塑造Vibe Coding 对程序员思维的影响个人体验：将编码工作交给AI后，对代码的理解和掌控力下降，反而更依赖于AI的提示和建议AI掌握的知识远比人类多，经典的“技术知识优势”在AI的辅助下逐渐填平，什么是重要的呢？作为学生，如果对技能与知识的掌握不再是优势，那么什么才是学习过程中应该掌握的呢？思考与判断力在两年前，我的工作方式还是找文档、查资料、写代码。依靠自己的知识和技能来完成任务。这使得我对技术有了更深的理解和掌握。2025-10-16 灵感2025-10-15碎片化知识管理工具信息的主动收集？单纯的记录整理？2025-10-19用机器学习工具研究社会学？经济数据是良好的研究对象文本情绪分析？2025-10-21架构代码管理与日常收拾东西有什么相似之处吗？都是“整理”与“归类”的过程好的架构设计能让代码更易于理解和维护好的收纳方式能让物品更易于找到和使用SDD —— Specification-Driven Development通过明确的规范来驱动开发过程易于Vibe Coding集成Spec Kit编译原理：语义的形式化表示在于AI​意图的传递中是否可用？提示词工程？","tags":[null]},{"title":"快速开始","path":"/Luo-Haomin/wiki/TrickTrade/getting-started.html","content":"快速开始欢迎使用 TrickTrade！本指南将帮助您快速上手。"},{"title":"碎片","path":"/Luo-Haomin/notes/Fragment/碎片.html","content":"在这个碎片中，我记录了一些零散的想法和灵感，可能并不完整，但希望能够为将来的创作提供一些启发。 总论现代人每天都接受大量的信息，然而，绝大多数信息却往往显得“与我无关”。人们甚至难以记住自己刚刚看到的内容，更别说从中提取有价值的信息了。但，这真的是信息途径的问题吗？或是缺乏对这些零散信息的处理？ 我决定尝试一种新的方法：将这些零散的信息片段进行整理和分类，形成一个“碎片库”。通过这种方式，我希望能够更好地理解和利用这些信息。而不至于“过目即忘”。 具体怎么做呢？我会每天花一些时间，回顾当日浏览的各种信息源（如新闻、社交媒体、书籍等），并将其中有价值的部分摘录出来，进行分类和标记。这样，当我需要某个主题的信息时，就可以快速找到相关的碎片。这似乎类似之前读过的“卡片笔记法”。 卡片笔记法简介 How To Take Smart Note——卢曼卡片盒更细的颗粒度原子化意味着一张卡片只记录一个知识点，这有助于降低记忆难度和认知负荷。 关键在于链接与群聚 笔记分类 闪念笔记（Fleeting Note）：捕捉想法。 闪念卡片，旨在快速记录脑海中瞬间出现的想法，讲究的就是一个“快”字。 文献笔记（Literature Note）：简短，使用自己的语言。文献卡片，主要记录那些给我们带来启示和帮助的信息，以便我们在需要时能找到原文，并结合上下文进行复习。 渐进式处理包括四个步骤：原文摘录、重点加粗、要点标注和摘要小结。 **用自己的话来描述。**必要难度。 尊重原始数据，意味着找到原始数据来源，且不在原始数据上直接修改。 永久笔记（Permanent Note）：思考与已有信息的关联。发现新想法和创造新知识 项目笔记（Project Note）： 链接 主题概述链接： 相邻集群链接 逻辑前后链接","tags":[null]},{"title":"项目介绍","path":"/Luo-Haomin/wiki/TrickTrade/index.html","content":"项目介绍TrickTrade 是一个专注于量化交易的高效平台，提供丰富的策略和工具，帮助用户实现自动化交易。无论您是新手还是有经验的交易者，TrickTrade 都能满足您的需求。"},{"title":"2D开发","path":"/Luo-Haomin/wiki/BevyBook/2D_Graphics/2D开发.html","content":"2D开发概述学习目标： 掌握精灵图集的使用 学会创建精灵动画 了解 2D 文本渲染 掌握透明度的使用 了解后处理效果（泛光） 理解 2D 相机控制（视口到世界坐标转换） 掌握像素完美渲染 前置知识要求： 2D 基础 ECS 基础 资源管理基础 核心概念什么是 2D 开发？2D 开发是在二维平面上创建游戏和应用。Bevy 提供了强大的 2D 渲染系统，支持精灵、动画、文本、后处理等功能。 为什么需要 2D 开发？ 游戏开发：大多数 2D 游戏需要 2D 开发 UI 开发：用户界面通常使用 2D 渲染 性能优化：2D 渲染比 3D 渲染更高效 简单性：2D 开发通常比 3D 开发更简单 2D 开发的核心组件Bevy 2D 开发系统包含以下核心组件： Sprite：精灵，用于显示图像 TextureAtlas：纹理图集，用于管理多个精灵 Animation：动画，用于创建精灵动画 Text2d：2D 文本，用于显示文本 Camera2d：2D 相机，用于控制视图 Bloom：泛光效果，用于后处理 基础用法精灵图集使用精灵图集管理多个精灵。 源代码文件：bevy/examples/2d/texture_atlas.rs 代码示例： use bevy::asset::LoadedFolder, image::ImageSampler, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest())) .add_systems(Startup, setup) .run();fn setup( mut commands: Commands, asset_server: ResAssetServer, mut texture_atlases: ResMutAssetsTextureAtlasLayout, mut textures: ResMutAssetsImage,) // 从文件夹加载多个单独的精灵 let loaded_folder = asset_server.load_folder(textures/rpg); // 创建纹理图集 let (texture_atlas, sources, texture) = create_texture_atlas( loaded_folder, Some(UVec2::new(6, 6)), // 填充 Some(ImageSampler::nearest()), // 采样方式 mut textures, ); let atlas_handle = texture_atlases.add(texture_atlas); // 使用图集中的精灵 commands.spawn(( Sprite texture_atlas: Some(atlas_handle), ..default() , Transform::from_xyz(0.0, 0.0, 0.0), )); 关键要点： 使用 TextureAtlasLayout 创建纹理图集 可以从文件夹加载多个精灵 可以设置填充和采样方式 使用 Sprite 的 texture_atlas 属性使用图集 说明：精灵图集允许将多个精灵打包到一个纹理中，减少绘制调用和提高性能。 精灵动画创建精灵动画。 源代码文件：bevy/examples/2d/sprite_animation.rs 代码示例： use bevy::prelude::*;use std::time::Duration;fn main() App::new() .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest())) .add_systems(Startup, setup) .add_systems(Update, execute_animations) .run();#[derive(Component)]struct AnimationConfig first_sprite_index: usize, last_sprite_index: usize, fps: u8, frame_timer: Timer,impl AnimationConfig fn new(first: usize, last: usize, fps: u8) - Self Self first_sprite_index: first, last_sprite_index: last, fps, frame_timer: Timer::new(Duration::from_secs_f32(1.0 / (fps as f32)), TimerMode::Repeating), // 这个系统循环遍历 `TextureAtlas` 中的所有精灵，从 `first_sprite_index` 到 `last_sprite_index`fn execute_animations(time: ResTime, mut query: Query(mut AnimationConfig, mut Sprite)) for (mut config, mut sprite) in mut query // 跟踪当前精灵已显示的时间 config.frame_timer.tick(time.delta()); // 如果已显示用户定义的时间（fps）... if config.frame_timer.just_finished() if let Some(atlas) = mut sprite.texture_atlas if atlas.index == config.last_sprite_index // ...并且是最后一帧，则回到第一帧 atlas.index = config.first_sprite_index; else // ...并且不是最后一帧，则移动到下一帧 atlas.index += 1; 关键要点： 使用 AnimationConfig 配置动画 使用 Timer 控制动画帧率 通过更新 Sprite 的 texture_atlas.index 来切换帧 可以设置动画的起始帧和结束帧 说明：精灵动画通过在不同帧之间切换来创建动画效果。通过控制帧切换的时间，可以创建流畅的动画。 2D 文本渲染在 2D 场景中渲染文本。 源代码文件：bevy/examples/2d/text2d.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, (animate_translation, animate_rotation, animate_scale)) .run();fn setup(mut commands: Commands, asset_server: ResAssetServer) let font = asset_server.load(fonts/FiraSans-Bold.ttf); let text_font = TextFont font: font.clone(), font_size: 50.0, ..default() ; commands.spawn(Camera2d); // 演示变换 commands.spawn(( Text2d::new( translation ), text_font.clone(), TextLayout::new_with_justify(Justify::Center), TextBackgroundColor(Color::BLACK.with_alpha(0.5)), Text2dShadow::default(), Transform::from_xyz(0.0, 0.0, 0.0), )); // 演示文本换行 let box_size = Vec2::new(300.0, 200.0); commands.spawn(( Sprite::from_color(Color::srgb(0.25, 0.25, 0.55), box_size), Transform::from_translation(Vec3::new(0.0, -250.0, 0.0)), children![( Text2d::new(this text wraps in the box (Unicode linebreaks)), TextFont font, font_size: 35.0, ..default() , TextLayout::new(Justify::Left, LineBreak::WordBoundary), // 在矩形中换行文本 TextBounds::from(box_size), // 确保文本绘制在框的上方 Transform::from_translation(Vec3::Z), Text2dShadow::default(), )], )); 关键要点： 使用 Text2d 在 2D 场景中渲染文本 使用 TextFont 设置字体和大小 使用 TextLayout 设置文本布局和对齐 使用 TextBounds 设置文本边界和换行 使用 Text2dShadow 添加文本阴影 说明：2D 文本渲染允许在 2D 场景中显示文本。与 UI 文本不同，2D 文本是场景的一部分，可以应用变换、动画等效果。 透明度使用透明度创建半透明效果。 源代码文件：bevy/examples/2d/transparency_2d.rs 关键信息： 使用 Color::srgba() 创建带透明度的颜色 使用 AlphaMode 控制透明度模式 AlphaMode::Blend 用于半透明对象 AlphaMode::Mask 用于带透明度的纹理 透明对象需要正确的渲染顺序 说明：透明度是 2D 渲染中的重要特性。Bevy 支持多种透明度模式，可以创建玻璃、水、烟雾等效果。 后处理效果（泛光）使用泛光效果增强渲染效果。 源代码文件：bevy/examples/2d/bloom_2d.rs 代码示例： use bevy:: core_pipeline::tonemapping::DebandDither, Tonemapping, post_process::bloom::Bloom, BloomCompositeMode, prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, update_bloom_settings) .run();fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsColorMaterial, asset_server: ResAssetServer,) commands.spawn(( Camera2d, Camera clear_color: ClearColorConfig::Custom(Color::BLACK), ..default() , Tonemapping::TonyMcMapface, // 使用色调映射器 Bloom::default(), // 启用泛光效果 DebandDither::Enabled, // 可选：泛光会导致渐变，导致条带 )); // 精灵 commands.spawn(Sprite image: asset_server.load(branding/bevy_bird_dark.png), color: Color::srgb(5.0, 5.0, 5.0), // 在暗环境中放置明亮的东西以看到效果 custom_size: Some(Vec2::splat(160.0)), ..default() ); 关键要点： 使用 Bloom 组件添加泛光效果 使用 Tonemapping 进行色调映射 使用 DebandDither 减少条带 泛光效果在暗环境中更明显 说明：泛光效果可以在明亮区域周围创建光晕效果。这对于创建发光效果、增强视觉冲击力非常有用。 2D 相机控制（视口到世界坐标转换）将视口坐标转换为世界坐标。 源代码文件：bevy/examples/2d/2d_viewport_to_world.rs 关键信息： 使用 Camera 的 viewport_to_world() 方法 可以将屏幕坐标转换为世界坐标 适合处理鼠标点击、触摸输入等 需要考虑相机的变换和投影 说明：视口到世界坐标转换允许将屏幕坐标转换为游戏世界坐标。这对于处理鼠标点击、触摸输入等交互非常有用。 像素完美渲染实现像素完美渲染。 源代码文件：bevy/examples/2d/pixel_grid_snap.rs 关键信息： 使用 ImagePlugin::default_nearest() 禁用纹理过滤 使用像素对齐确保精灵对齐到像素网格 适合像素艺术风格的游戏 可以避免模糊和抗锯齿 说明：像素完美渲染确保精灵对齐到像素网格，避免模糊和抗锯齿。这对于像素艺术风格的游戏非常重要。 进阶用法高级动画创建复杂的动画效果。 关键信息： 可以创建多个动画轨道 可以混合不同的动画 可以使用动画事件 可以控制动画的播放速度 说明：高级动画允许创建复杂的动画效果。可以组合多个动画、控制播放速度、响应动画事件等。 性能优化优化 2D 渲染性能。 关键信息： 使用精灵图集减少绘制调用 使用批处理优化渲染 使用剔除减少渲染对象 合理使用透明度 说明：性能优化对于 2D 游戏非常重要。通过使用精灵图集、批处理、剔除等技术，可以显著提高渲染性能。 实际应用在游戏开发中的应用场景2D 开发在游戏开发中有广泛的应用： 2D 游戏：创建 2D 平台游戏、RPG、策略游戏等 UI 开发：创建游戏 UI 和 HUD 粒子效果：创建粒子效果和特效 菜单系统：创建游戏菜单和界面 常见问题问题 1：如何优化精灵动画性能？ 解决方案：使用精灵图集、批处理、剔除等技术来优化精灵动画性能。 问题 2：如何处理透明对象？ 解决方案：透明对象需要正确的渲染顺序。Bevy 会自动处理透明对象的排序。 问题 3：如何实现像素完美渲染？ 解决方案：使用 ImagePlugin::default_nearest() 禁用纹理过滤，并确保精灵对齐到像素网格。 性能考虑 精灵图集：使用精灵图集减少绘制调用 批处理：使用批处理优化渲染 剔除：使用剔除减少渲染对象 透明度：合理使用透明度以减少性能开销 相关资源相关源代码文件： bevy/examples/2d/texture_atlas.rs - 精灵图集示例 bevy/examples/2d/sprite_animation.rs - 精灵动画示例 bevy/examples/2d/text2d.rs - 2D 文本渲染示例 bevy/examples/2d/transparency_2d.rs - 透明度示例 bevy/examples/2d/bloom_2d.rs - 泛光效果示例 bevy/examples/2d/2d_viewport_to_world.rs - 视口到世界坐标转换示例 bevy/examples/2d/pixel_grid_snap.rs - 像素完美渲染示例 官方文档链接： Bevy 2D 渲染文档 2D 示例 进一步学习建议： 学习动画系统，了解如何创建更复杂的动画 学习 UI 系统，了解如何创建用户界面 学习性能优化，了解如何优化 2D 渲染性能 索引：返回上级目录"},{"title":"2D Graphics（2D 图形）","path":"/Luo-Haomin/wiki/BevyBook/2D_Graphics/README.html","content":"2D Graphics（2D 图形）本部分介绍如何在 Bevy 中进行 2D 图形渲染和开发。 内容列表1. 2D 基础 2D 渲染概述 2D 坐标系 2D 相机系统 2D 渲染管线 精灵（Sprite） 纹理（Texture） 学习目标：理解 Bevy 2D 渲染的基本概念 2. 2D 开发 精灵系统 创建精灵 精灵动画 精灵图集（Sprite Sheet） 精灵批处理 2D 相机 相机设置 相机移动 相机缩放 相机跟随 2D 物理 刚体（Rigid Body） 碰撞检测 物理材质 物理约束 2D 特效 粒子系统 后处理效果 光照（可选） 学习目标：能够开发完整的 2D 游戏 学习建议 从简单开始：先学会显示一个精灵，再逐步增加复杂度 理解坐标系：理解 2D 坐标系和变换 性能优化：注意精灵批处理和性能优化 实践项目：通过实际项目加深理解 相关资源 Bevy 2D 官方文档 2D 渲染示例 2D 物理示例 下一步完成本部分学习后，建议继续学习： 3D Graphics（3D 图形） - 学习 3D 渲染 UI Audio（界面与音频） - 添加 UI 和音效 Architecture（架构设计） - 组织大型 2D 项目 索引：返回主目录"},{"title":"2D 基础","path":"/Luo-Haomin/wiki/BevyBook/2D_Graphics/2D基础.html","content":"2D 基础概述学习目标： 理解 Bevy 2D 渲染的基本概念 掌握如何创建和显示精灵（Sprite） 学会使用 2D 相机（Camera2d） 理解精灵的变换（Transform）和动画 前置知识要求： Bevy 快速入门 ECS 基础 资源管理基础 核心概念什么是 2D 渲染？2D 渲染是在二维平面上显示图像和图形。Bevy 提供了强大的 2D 渲染系统，支持精灵、纹理、动画等功能。 为什么需要 2D 渲染？ 游戏开发：大多数 2D 游戏需要 2D 渲染 UI 开发：用户界面通常使用 2D 渲染 性能优化：2D 渲染比 3D 渲染更高效 2D 渲染的核心组件Bevy 2D 渲染系统包含以下核心组件： Sprite：精灵，用于显示图像 Camera2d：2D 相机，用于控制视图 Transform：变换，用于控制位置、旋转、缩放 AssetServer：资源服务器，用于加载图像资源 基础用法显示单个精灵创建并显示一个精灵图像。 源代码文件：bevy/examples/2d/sprite.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();fn setup(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Camera2d); commands.spawn(Sprite::from_image( asset_server.load(branding/bevy_bird_dark.png), )); 关键要点： 使用 Camera2d 创建 2D 相机 使用 Sprite::from_image() 从图像创建精灵 使用 AssetServer 加载图像资源 精灵默认显示在屏幕中心 说明：这是最简单的 2D 渲染示例。Camera2d 是 2D 相机，用于控制视图。Sprite::from_image() 从图像文件创建精灵。AssetServer 用于加载图像资源。精灵默认显示在屏幕中心（0, 0, 0）位置。 精灵翻转控制精灵的水平和垂直翻转。 源代码文件：bevy/examples/2d/sprite_flipping.rs 代码示例： commands.spawn(Sprite image: asset_server.load(branding/bevy_bird_dark.png), flip_x: true, // 水平翻转 flip_y: false, // 垂直翻转（默认） ..default()); 关键要点： flip_x: true 水平翻转精灵 flip_y: true 垂直翻转精灵 翻转是相对于精灵原始方向的 可以同时进行水平和垂直翻转 说明：精灵翻转用于改变精灵的显示方向。这在游戏开发中很有用，例如让角色面向不同方向。翻转是相对于精灵原始方向的，不会改变精灵的位置。 精灵移动实现精灵的移动动画。 源代码文件：bevy/examples/2d/move_sprite.rs 代码示例： #[derive(Component)]enum Direction Left, Right,fn setup(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Camera2d); commands.spawn(( Sprite::from_image(asset_server.load(branding/icon.png)), Transform::from_xyz(0., 0., 0.), Direction::Right, ));fn sprite_movement(time: ResTime, mut sprite_position: Query(mut Direction, mut Transform)) for (mut logo, mut transform) in mut sprite_position match *logo Direction::Right = transform.translation.x += 150. * time.delta_secs(), Direction::Left = transform.translation.x -= 150. * time.delta_secs(), if transform.translation.x 200. *logo = Direction::Left; else if transform.translation.x -200. *logo = Direction::Right; 关键要点： 使用 Transform 组件控制位置 使用 time.delta_secs() 确保帧率无关的移动 通过边界检测改变移动方向 使用组件存储移动方向 说明：精灵移动是 2D 游戏开发中的基本功能。使用 Transform 组件控制精灵的位置。time.delta_secs() 确保移动速度与帧率无关，无论帧率如何，移动速度都保持一致。通过边界检测可以改变移动方向，实现来回移动的效果。 进阶用法精灵旋转实现精灵的旋转动画。 源代码文件：bevy/examples/2d/rotation.rs 代码示例： fn sprite_rotation(mut sprite_query: Querymut Transform, WithSprite, time: ResTime) for mut transform in mut sprite_query transform.rotate_z(time.delta_secs() * 1.0); 注意事项： 旋转角度以弧度为单位 rotate_z() 绕 Z 轴旋转（2D 平面） 使用 time.delta_secs() 确保旋转速度与帧率无关 最佳实践： 使用 time.delta_secs() 确保动画速度一致 合理设置旋转速度，避免过快或过慢 考虑性能影响，避免过多旋转的精灵 精灵缩放控制精灵的大小。 代码示例： fn sprite_scale(mut sprite_query: Querymut Transform, WithSprite, time: ResTime) for mut transform in mut sprite_query let scale = (time.elapsed_secs() * 0.5).sin() * 0.5 + 1.0; transform.scale = Vec3::splat(scale); 注意事项： 缩放值 1.0 表示原始大小 小于 1.0 表示缩小，大于 1.0 表示放大 可以使用 Vec3::splat() 统一设置三个轴的缩放 最佳实践： 使用统一的缩放值保持精灵比例 避免过度缩放，影响性能 考虑缩放对碰撞检测的影响 实际应用在游戏开发中的应用场景2D 渲染在游戏开发中有广泛的应用： 角色显示：显示游戏角色和 NPC 背景渲染：显示游戏背景和场景 UI 元素：显示用户界面元素 特效显示：显示粒子效果和动画 常见问题问题 1：精灵不显示怎么办？ 解决方案： 确保创建了 Camera2d 检查图像资源路径是否正确 确认精灵的位置在相机视野内 问题 2：如何控制精灵的显示顺序？ 解决方案： 使用 Transform 的 translation.z 控制深度 Z 值越大，显示越靠前 默认 Z 值为 0 问题 3：如何优化 2D 渲染性能？ 解决方案： 使用精灵图集（Sprite Atlas）减少绘制调用 合理使用精灵批处理 避免过多的小精灵 性能考虑 精灵批处理：将多个精灵合并为一次绘制调用 纹理优化：使用合适的纹理格式和大小 相机优化：只渲染相机视野内的精灵 相关资源相关源代码文件： bevy/examples/2d/sprite.rs - 精灵显示示例 bevy/examples/2d/sprite_flipping.rs - 精灵翻转示例 bevy/examples/2d/move_sprite.rs - 精灵移动示例 bevy/examples/2d/rotation.rs - 精灵旋转示例 官方文档链接： Bevy 2D 官方文档 2D 渲染示例 精灵系统文档 进一步学习建议： 学习 2D 开发，了解精灵动画、精灵图集等高级功能 学习 2D 物理，了解碰撞检测和物理模拟 学习 2D 相机控制，了解相机跟随、缩放等功能 索引：返回上级目录"},{"title":"动画基础","path":"/Luo-Haomin/wiki/BevyBook/Animation/动画基础.html","content":"动画基础概述学习目标： 理解 Bevy 动画系统的基本概念 掌握动画网格的创建和播放 了解动画变换的使用 学会使用动画播放器和动画图 前置知识要求： Bevy 快速入门 ECS 基础 3D 开发基础 资源管理基础 核心概念什么是动画系统？动画系统是 Bevy 中用于创建和播放动画的功能。Bevy 的动画系统支持网格动画、变换动画、UI 动画等多种类型的动画。 为什么需要动画系统？ 视觉效果：动画可以增强游戏的视觉效果 用户体验：动画可以改善用户体验 游戏性：动画是游戏性的重要组成部分 艺术表现：动画可以增强艺术表现力 动画系统的核心组件Bevy 动画系统包含以下核心组件： AnimationClip：动画片段，包含动画数据 AnimationGraph：动画图，用于组织和管理动画 AnimationPlayer：动画播放器，用于播放动画 AnimationTarget：动画目标，用于指定动画作用的对象 基础用法动画网格创建和播放动画网格。 源代码文件：bevy/examples/animation/animated_mesh.rs 代码示例： use bevy::light::CascadeShadowConfigBuilder, prelude::*, scene::SceneInstanceReady;// 包含网格和动画的示例资源const GLTF_PATH: str = models/animated/Fox.glb;fn main() App::new() .insert_resource(AmbientLight color: Color::WHITE, brightness: 2000., ..default() ) .add_plugins(DefaultPlugins) .add_systems(Startup, setup_mesh_and_animation) .add_systems(Startup, setup_camera_and_environment) .run();// 一个存储我们要播放的动画引用的组件。这在我们开始加载网格时创建// （参见 `setup_mesh_and_animation`），并在网格生成时读取（参见 `play_animation_when_ready`）。#[derive(Component)]struct AnimationToPlay graph_handle: HandleAnimationGraph, index: AnimationNodeIndex,fn setup_mesh_and_animation( mut commands: Commands, asset_server: ResAssetServer, mut graphs: ResMutAssetsAnimationGraph,) // 创建一个包含单个动画的动画图。我们想要示例资源中的run动画，其索引为二。 let (graph, index) = AnimationGraph::from_clip( asset_server.load(GltfAssetLabel::Animation(2).from_asset(GLTF_PATH)), ); // 将动画图存储为资源。 let graph_handle = graphs.add(graph); // 创建一个存储我们动画引用的组件。 let animation_to_play = AnimationToPlay graph_handle, index, ; // 开始将资源作为场景加载，并将其引用存储在 SceneRoot 组件中。 // 此组件将在资源加载后自动生成包含我们网格的场景。 let mesh_scene = SceneRoot(asset_server.load(GltfAssetLabel::Scene(0).from_asset(GLTF_PATH))); // 生成一个包含我们组件的实体，并将其连接到一个观察者， // 该观察者将在场景加载并生成时触发。 commands .spawn((animation_to_play, mesh_scene)) .observe(play_animation_when_ready);fn play_animation_when_ready( scene_ready: OnSceneInstanceReady, mut commands: Commands, children: QueryChildren, animations_to_play: QueryAnimationToPlay, mut players: Querymut AnimationPlayer,) // 我们在 `setup_mesh_and_animation` 中生成的实体是触发器的目标。 // 首先找到我们添加到该实体的 AnimationToPlay 组件。 if let Ok(animation_to_play) = animations_to_play.get(scene_ready.entity) // SceneRoot 组件将场景生成为我们实体的子实体的层次结构。 // 由于资源包含蒙皮网格和动画，它还会生成一个动画播放器组件。 // 搜索我们实体的后代以找到动画播放器。 for child in children.iter_descendants(scene_ready.entity) if let Ok(mut player) = players.get_mut(child) // 告诉动画播放器开始动画并保持重复播放。 // // 如果你想尝试停止和切换动画，请参阅 `animated_mesh_control.rs` 示例。 player.play(animation_to_play.index).repeat(); // 添加动画图。这只需要执行一次即可将动画播放器连接到网格。 commands .entity(child) .insert(AnimationGraphHandle(animation_to_play.graph_handle.clone())); 关键要点： 使用 AnimationGraph::from_clip 从动画片段创建动画图 使用 AnimationPlayer 播放动画 使用 AnimationGraphHandle 将动画图连接到实体 使用 SceneInstanceReady 事件在场景加载后播放动画 说明：动画网格是动画系统的基础。通过加载包含动画的 glTF 文件，可以创建和播放动画网格。 动画变换创建和播放动画变换。 源代码文件：bevy/examples/animation/animated_transform.rs 代码示例： use bevy:: animation::animated_field, AnimationTarget, AnimationTargetId, prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .insert_resource(AmbientLight color: Color::WHITE, brightness: 150.0, ..default() ) .add_systems(Startup, setup) .run();fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial, mut animations: ResMutAssetsAnimationClip, mut graphs: ResMutAssetsAnimationGraph,) // 相机 commands.spawn(( Camera3d::default(), Transform::from_xyz(-2.0, 2.5, 5.0).looking_at(Vec3::ZERO, Vec3::Y), )); // 光源 commands.spawn(( PointLight intensity: 500_000.0, ..default() , Transform::from_xyz(0.0, 2.5, 0.0), )); // 让我们使用 `Name` 组件来定位实体。我们可以使用任何我们喜欢的东西， // 但名称很方便。 let planet = Name::new(planet); let orbit_controller = Name::new(orbit_controller); let satellite = Name::new(satellite); // 创建动画 let mut animation = AnimationClip::default(); // 曲线可以修改变换的单个部分：这里，平移。 let planet_animation_target_id = AnimationTargetId::from_name(planet); animation.add_curve_to_target( planet_animation_target_id, AnimatableCurve::new( animated_field!(Transform::translation), UnevenSampleAutoCurve::new([0.0, 1.0, 2.0, 3.0, 4.0].into_iter().zip([ Vec3::new(1.0, 0.0, 1.0), Vec3::new(-1.0, 0.0, 1.0), Vec3::new(-1.0, 0.0, -1.0), Vec3::new(1.0, 0.0, -1.0), // 如果需要无缝循环，最后一帧应该与第一帧相同 Vec3::new(1.0, 0.0, 1.0), ])) .expect(应该能够构建平移曲线，因为我们传入有效的样本), ), ); // 或者它可以修改变换的旋转。 // 为了找到要修改的实体，将遍历层次结构，在每个级别查找具有正确名称的实体。 let orbit_controller_animation_target_id = AnimationTargetId::from_names([planet.clone(), orbit_controller.clone()].iter()); animation.add_curve_to_target( orbit_controller_animation_target_id, AnimatableCurve::new( animated_field!(Transform::rotation), UnevenSampleAutoCurve::new([0.0, 1.0, 2.0, 3.0, 4.0].into_iter().zip([ Quat::IDENTITY, Quat::from_axis_angle(Vec3::Y, PI / 2.), Quat::from_axis_angle(Vec3::Y, PI / 2. * 2.), Quat::from_axis_angle(Vec3::Y, PI / 2. * 3.), Quat::IDENTITY, ])) .expect(无法构建旋转曲线), ), ); // 创建动画图 let (graph, animation_index) = AnimationGraph::from_clip(animations.add(animation)); // 创建动画播放器，并设置为重复播放 let mut player = AnimationPlayer::default(); player.play(animation_index).repeat(); // 创建将被动画化的场景 // 第一个实体是行星 let planet_entity = commands .spawn(( Mesh3d(meshes.add(Sphere::default())), MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))), // 添加动画图和播放器 planet, AnimationGraphHandle(graphs.add(graph)), player, )) .id(); commands.entity(planet_entity).insert(( AnimationTarget id: planet_animation_target_id, player: planet_entity, , children![( Transform::default(), Visibility::default(), orbit_controller, AnimationTarget id: orbit_controller_animation_target_id, player: planet_entity, , children![( Mesh3d(meshes.add(Cuboid::new(0.5, 0.5, 0.5))), MeshMaterial3d(materials.add(Color::srgb(0.3, 0.9, 0.3))), Transform::from_xyz(1.5, 0.0, 0.0), AnimationTarget id: satellite_animation_target_id, player: planet_entity, , satellite, )], )], )); 关键要点： 使用 AnimationClip 创建动画片段 使用 AnimatableCurve 创建动画曲线 使用 animated_field! 宏指定动画字段 使用 AnimationTarget 指定动画目标 说明：动画变换是动画系统的重要功能。通过创建动画曲线，可以动画化实体的变换属性。 进阶用法动画播放器使用动画播放器控制动画播放。 关键信息： 使用 AnimationPlayer::play() 播放动画 使用 .repeat() 重复播放动画 使用 .once() 播放一次动画 使用 .pause() 暂停动画 使用 .resume() 恢复动画 说明：动画播放器是动画系统的核心组件。通过使用动画播放器，可以控制动画的播放状态。 实际应用在游戏开发中的应用场景动画系统在游戏开发中有广泛的应用： 角色动画：创建角色行走、跑步、跳跃等动画 物体动画：创建物体移动、旋转、缩放等动画 UI 动画：创建 UI 元素的动画效果 特效动画：创建特效的动画效果 常见问题问题 1：如何加载动画网格？ 解决方案： 使用 AssetServer 加载 glTF 文件 使用 GltfAssetLabel::Animation 加载动画 使用 GltfAssetLabel::Scene 加载场景 使用 SceneInstanceReady 事件在场景加载后播放动画 问题 2：如何创建动画变换？ 解决方案： 使用 AnimationClip 创建动画片段 使用 AnimatableCurve 创建动画曲线 使用 animated_field! 宏指定动画字段 使用 AnimationTarget 指定动画目标 问题 3：如何控制动画播放？ 解决方案： 使用 AnimationPlayer::play() 播放动画 使用 .repeat() 重复播放动画 使用 .pause() 暂停动画 使用 .resume() 恢复动画 性能考虑 动画图：使用动画图组织和管理动画 动画目标：使用动画目标指定动画作用的对象 动画播放器：合理使用动画播放器控制动画播放 相关资源相关源代码文件： bevy/examples/animation/animated_mesh.rs - 动画网格示例 bevy/examples/animation/animated_transform.rs - 动画变换示例 官方文档链接： Bevy 动画系统 Bevy 动画示例 进一步学习建议： 学习动画进阶，了解动画图、动画事件等高级功能 学习 UI 动画，了解 UI 动画的创建和使用 索引：返回上级目录"},{"title":"Animation（动画系统）","path":"/Luo-Haomin/wiki/BevyBook/Animation/README.html","content":"Animation（动画系统）本部分介绍 Bevy 的动画系统，包括动画网格、动画变换、动画图、动画事件等。 内容列表1. 动画基础 动画网格（Animated Mesh） 动画变换（Animated Transform） 动画播放器（Animation Player） 动画图（Animation Graph） 学习目标：理解 Bevy 动画系统的基本概念，掌握动画的创建和播放 2. 动画进阶 动画图（Animation Graph） 动画事件（Animation Events） 动画遮罩（Animation Masks） 缓动函数（Easing Functions） 学习目标：掌握动画的高级功能，包括动画混合、事件处理和遮罩 3. UI 动画 UI 动画基础 动画 UI 属性 UI 动画示例 学习目标：掌握 UI 动画的创建和使用 4. 变形目标 变形目标基础 变形目标动画 变形目标示例 学习目标：掌握变形目标动画的创建和使用 学习建议 循序渐进：从动画基础开始，逐步学习高级功能 实践为主：通过实际项目应用动画功能 理解概念：深入理解动画图、动画事件等核心概念 参考示例：参考 Bevy 官方示例加深理解 相关资源 Bevy 动画系统文档 Bevy 动画示例 Bevy 官方文档 下一步完成本部分学习后，建议继续学习： 3D Graphics（3D 图形） - 深入学习 3D 渲染 Advanced（高级主题） - 深入高级功能 索引：返回主目录"},{"title":"Bevy简介与快速入门","path":"/Luo-Haomin/notes/Skill/Bevy/Bevy简介与快速入门.html","content":"Bevy简介Bevy是一个开源的游戏引擎，使用Rust语言编写。它采用了ECS（Entity-Component-System）架构，旨在提供高性能和易用性。Bevy支持2D和3D游戏开发，并且具有强大的渲染、音频、输入处理等功能。 参考资料Introduction Bevy Examples in WebGL2 bevy - Rust Bevy Assets Introduction - Unofficial Bevy Cheat Book","tags":[null,null]},{"title":"变形目标（Morph Targets）","path":"/Luo-Haomin/wiki/BevyBook/Animation/变形目标.html","content":"变形目标（Morph Targets）概述学习目标： 理解变形目标的基本概念 掌握变形目标动画的创建和使用 学会读取变形目标名称 了解变形目标的应用场景 前置知识要求： 动画基础 3D 开发基础 资源管理基础 核心概念什么是变形目标？变形目标是 3D 模型中用于创建形状变化的顶点位置集合。通过混合多个变形目标，可以创建各种形状变化效果，如面部表情、肌肉变形等。 为什么需要变形目标？ 面部表情：可以创建各种面部表情 形状变化：可以创建各种形状变化效果 细节动画：可以创建细节动画效果 性能优化：可以优化动画性能 变形目标的核心组件Bevy 变形目标动画包含以下核心组件： MorphTargets：变形目标集合，包含多个变形目标 MorphWeights：变形权重，控制变形目标的混合比例 AnimationClip：动画片段，包含变形目标动画数据 AnimationGraph：动画图，用于组织和管理变形目标动画 基础用法变形目标动画创建和播放变形目标动画。 源代码文件：bevy/examples/animation/morph_targets.rs 代码示例： use bevy::prelude::*;fn setup( mut commands: Commands, asset_server: ResAssetServer, mut graphs: ResMutAssetsAnimationGraph,) // 加载包含变形目标的 GLTF 模型 let gltf_path = models/animated/MorphStressTest.gltf; // 加载动画片段（包含变形目标动画） let animation_clip = asset_server.load( GltfAssetLabel::Animation(2).from_asset(gltf_path) ); // 创建动画图 let (graph, index) = AnimationGraph::from_clip(animation_clip); let graph_handle = graphs.add(graph); // 创建场景根节点 commands.spawn(( SceneRoot( asset_server.load(GltfAssetLabel::Scene(0).from_asset(gltf_path)) ), AnimationGraphHandle(graph_handle), AnimationPlayer::default().play(index).repeat(), )); 关键要点： 变形目标通常存储在 GLTF 模型中 可以从 GLTF 文件加载变形目标动画 变形目标动画使用标准的动画系统 可以设置动画的重复模式 说明：变形目标动画是创建细节动画的重要工具。通过使用变形目标，可以创建各种形状变化效果，如面部表情、肌肉变形等，而不需要额外的骨骼动画。 读取变形目标名称读取网格的变形目标名称。 源代码文件：bevy/examples/animation/morph_targets.rs 代码示例： use bevy::prelude::*;fn name_morphs( asset_server: ResAssetServer, mut events: MessageReaderAssetEventMesh, meshes: ResAssetsMesh,) for event in events.read() if let AssetEvent::Mesh::Added id = event let Some(path) = asset_server.get_path(*id) let Some(mesh) = meshes.get(*id) let Some(names) = mesh.morph_target_names() info!(Morph target names for path:?:); for name in names info!( name); 关键要点： 可以使用 mesh.morph_target_names() 来获取变形目标名称 变形目标名称通常在 GLTF 文件中定义 可以通过名称来识别和操作特定的变形目标 变形目标名称对于调试和开发很有用 说明：读取变形目标名称是了解和使用变形目标的重要步骤。通过读取名称，可以识别模型中的变形目标，并在代码中引用它们。 变形目标权重控制变形目标的混合权重。 源代码文件：bevy/examples/animation/morph_targets.rs 代码示例： use bevy::prelude::*;fn control_morph_weights( mut morph_weights: Querymut MorphWeights, input: ResButtonInputKeyCode,) for mut weights in mut morph_weights // 设置特定变形目标的权重 if input.just_pressed(KeyCode::Key1) weights.set_weight(0, 1.0); // 设置第一个变形目标的权重为 1.0 if input.just_pressed(KeyCode::Key2) weights.set_weight(1, 1.0); // 设置第二个变形目标的权重为 1.0 // 重置所有权重 if input.just_pressed(KeyCode::Key0) weights.clear(); 关键要点： 可以使用 MorphWeights 组件来控制变形目标权重 权重值通常在 0.0 到 1.0 之间 可以同时设置多个变形目标的权重 权重控制变形目标的混合比例 说明：控制变形目标权重是创建变形效果的关键。通过调整权重，可以控制不同变形目标的混合比例，创建各种形状变化效果。 进阶用法程序化创建变形目标动画可以程序化创建变形目标动画。 源代码文件：bevy/examples/animation/morph_targets.rs 关键信息： 可以程序化创建变形目标动画曲线 可以使用 AnimatableCurve 来定义变形目标权重随时间的变化 可以组合多个变形目标动画 可以使用动画图来组织复杂的变形目标动画 说明：程序化创建变形目标动画是创建动态变形效果的关键。通过程序化创建动画，可以根据游戏状态动态调整变形目标，创建更加动态和交互的变形效果。 变形目标与骨骼动画结合可以将变形目标动画与骨骼动画结合使用。 源代码文件：bevy/examples/animation/morph_targets.rs 关键信息： 变形目标动画可以与骨骼动画同时使用 变形目标通常用于细节动画，而骨骼动画用于主要动画 可以创建复杂的动画组合 性能考虑：变形目标会增加计算开销 说明：将变形目标动画与骨骼动画结合是创建复杂动画效果的关键。通过结合使用，可以创建更加丰富和详细的动画效果。 实际应用在游戏开发中的应用场景变形目标在游戏开发中有广泛的应用： 面部表情：创建角色的各种面部表情 肌肉变形：创建肌肉的变形效果 细节动画：创建细节动画效果，如布料变形 形状变化：创建各种形状变化效果 常见问题问题 1：如何创建变形目标？ 解决方案：变形目标通常在 3D 建模软件中创建，然后导出为 GLTF 格式。Bevy 支持从 GLTF 文件加载变形目标。 问题 2：如何控制变形目标的混合？ 解决方案：使用 MorphWeights 组件来控制变形目标权重。可以通过动画系统或直接设置权重来控制混合。 问题 3：变形目标会影响性能吗？ 解决方案：变形目标会增加计算开销，特别是当有多个变形目标时。应该合理使用变形目标，避免过度使用。 性能考虑 变形目标数量：尽量减少变形目标的数量 权重计算：优化权重计算以提高性能 动画优化：使用动画图来组织和管理变形目标动画 LOD 系统：在远距离时可以减少变形目标的使用 相关资源相关源代码文件： bevy/examples/animation/morph_targets.rs - 变形目标示例 官方文档链接： Bevy Animation 官方文档 变形目标示例 进一步学习建议： 学习动画基础，了解动画系统的基本使用 学习 3D 开发，了解如何加载和使用 3D 模型 学习动画进阶，了解动画图和动画混合 索引：返回上级目录"},{"title":"UI 动画","path":"/Luo-Haomin/wiki/BevyBook/Animation/UI动画.html","content":"UI 动画概述学习目标： 理解 UI 动画的基本概念 掌握 UI 属性动画的创建和使用 学会对文本进行动画处理 了解颜色动画的使用 前置知识要求： 动画基础 UI 基础 ECS 基础 核心概念什么是 UI 动画？UI 动画是对用户界面元素进行动画处理的功能。Bevy 支持对 UI 属性（如字体大小、颜色等）进行动画处理。 为什么需要 UI 动画？ 用户体验：动画可以改善用户体验 视觉反馈：动画可以提供视觉反馈 交互性：动画可以增强交互性 艺术表现：动画可以增强艺术表现力 UI 动画的核心组件Bevy UI 动画包含以下核心组件： AnimationClip：动画片段，包含 UI 属性动画数据 AnimationGraph：动画图，用于组织和管理 UI 动画 AnimationPlayer：动画播放器，用于播放 UI 动画 AnimationTarget：动画目标，用于指定动画作用的 UI 元素 基础用法UI 属性动画对 UI 属性（如字体大小）进行动画处理。 源代码文件：bevy/examples/animation/animated_ui.rs 代码示例： use bevy::prelude::*;fn setup( mut commands: Commands, mut animation_graphs: ResMutAssetsAnimationGraph, mut animation_clips: ResMutAssetsAnimationClip,) // 创建动画目标 ID let animation_target_name = Name::new(Text); let animation_target_id = AnimationTargetId::from_name(animation_target_name); // 创建动画片段 let mut animation_clip = AnimationClip::default(); // 创建字体大小动画曲线 animation_clip.add_curve_to_target( animation_target_id, AnimatableCurve::new( animated_field!(TextFont::font_size), AnimatableKeyframeCurve::new( [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0] .into_iter() .zip([24.0, 80.0, 24.0, 80.0, 24.0, 80.0, 24.0]), ) .expect(valid curve), ), ); // 保存动画片段 let animation_clip_handle = animation_clips.add(animation_clip); // 创建动画图 let (animation_graph, animation_node_index) = AnimationGraph::from_clip(animation_clip_handle); let animation_graph_handle = animation_graphs.add(animation_graph); // 创建文本实体 commands.spawn(( Text::default(), TextFont font_size: 24.0, ..default() , animation_target_name, AnimationGraphHandle(animation_graph_handle), AnimationPlayer::default().play(animation_node_index).repeat(), )); 关键要点： 可以使用 animated_field! 宏来指定要动画的属性 需要为 UI 元素设置名称以作为动画目标 动画曲线定义属性值随时间的变化 可以设置动画的重复模式 说明：UI 属性动画是创建动态用户界面的重要工具。通过对 UI 属性进行动画处理，可以创建各种视觉效果，如字体大小的变化、颜色的渐变等。 文本动画对文本进行动画处理。 源代码文件：bevy/examples/animation/animated_ui.rs 代码示例： use bevy::prelude::*;fn setup_text_animation( mut commands: Commands, mut animation_graphs: ResMutAssetsAnimationGraph, mut animation_clips: ResMutAssetsAnimationClip,) let animation_target_name = Name::new(Text); let animation_target_id = AnimationTargetId::from_name(animation_target_name); let mut animation_clip = AnimationClip::default(); // 创建字体大小动画 animation_clip.add_curve_to_target( animation_target_id, AnimatableCurve::new( animated_field!(TextFont::font_size), AnimatableKeyframeCurve::new( [0.0, 1.0, 2.0].into_iter().zip([24.0, 48.0, 24.0]), ) .expect(valid curve), ), ); // 创建文本颜色动画 animation_clip.add_curve_to_target( animation_target_id, AnimatableCurve::new( TextColorProperty, AnimatableKeyframeCurve::new( [0.0, 1.0, 2.0].into_iter().zip([ Srgba::RED, Srgba::GREEN, Srgba::BLUE, ]), ) .expect(valid curve), ), ); let animation_clip_handle = animation_clips.add(animation_clip); let (animation_graph, animation_node_index) = AnimationGraph::from_clip(animation_clip_handle); let animation_graph_handle = animation_graphs.add(animation_graph); commands.spawn(( Text::default(), TextFont font_size: 24.0, ..default() , TextColor(Srgba::RED), animation_target_name, AnimationGraphHandle(animation_graph_handle), AnimationPlayer::default().play(animation_node_index).repeat(), )); 关键要点： 可以对文本的多个属性进行动画处理 可以使用 TextColorProperty 来动画文本颜色 所有动画曲线应该有相同的时间范围 可以组合多个属性动画 说明：文本动画是创建动态文本效果的重要工具。通过对文本的字体大小、颜色等属性进行动画处理，可以创建各种视觉效果，如闪烁、渐变、缩放等。 颜色动画对 UI 元素的颜色进行动画处理。 源代码文件：bevy/examples/animation/animated_ui.rs 代码示例： use bevy::prelude::*;fn setup_color_animation( mut commands: Commands, mut animation_graphs: ResMutAssetsAnimationGraph, mut animation_clips: ResMutAssetsAnimationClip,) let animation_target_name = Name::new(Button); let animation_target_id = AnimationTargetId::from_name(animation_target_name); let mut animation_clip = AnimationClip::default(); // 创建背景颜色动画 animation_clip.add_curve_to_target( animation_target_id, AnimatableCurve::new( BackgroundColorProperty, AnimatableKeyframeCurve::new( [0.0, 1.0, 2.0].into_iter().zip([ Srgba::RED, Srgba::GREEN, Srgba::BLUE, ]), ) .expect(valid curve), ), ); let animation_clip_handle = animation_clips.add(animation_clip); let (animation_graph, animation_node_index) = AnimationGraph::from_clip(animation_clip_handle); let animation_graph_handle = animation_graphs.add(animation_graph); commands.spawn(( Node::default(), BackgroundColor(Srgba::RED), animation_target_name, AnimationGraphHandle(animation_graph_handle), AnimationPlayer::default().play(animation_node_index).repeat(), )); 关键要点： 可以对 UI 元素的背景颜色进行动画处理 可以使用 BackgroundColorProperty 来动画背景颜色 颜色值使用 Srgba 类型 可以创建平滑的颜色过渡 说明：颜色动画是创建动态 UI 效果的重要工具。通过对 UI 元素的颜色进行动画处理，可以创建各种视觉效果，如颜色渐变、闪烁、脉冲等。 进阶用法组合多个 UI 动画可以组合多个 UI 属性动画来创建复杂的动画效果。 源代码文件：bevy/examples/animation/animated_ui.rs 关键信息： 可以在同一个动画片段中添加多个属性动画 所有动画曲线应该有相同的时间范围 可以同时动画多个 UI 元素 可以使用动画图来组织复杂的动画 说明：组合多个 UI 动画是创建复杂动画效果的关键。通过组合多个属性动画，可以创建各种视觉效果，如同时改变字体大小和颜色、同时动画多个 UI 元素等。 响应式 UI 动画可以根据用户交互触发 UI 动画。 源代码文件：bevy/examples/animation/animated_ui.rs 关键信息： 可以在用户交互时触发动画 可以使用动画事件来同步动画和交互 可以根据游戏状态调整动画 可以动态创建和销毁动画 说明：响应式 UI 动画是创建交互式用户界面的关键。通过根据用户交互触发动画，可以创建更加动态和交互的用户界面。 实际应用在游戏开发中的应用场景UI 动画在游戏开发中有广泛的应用： 按钮动画：对按钮进行悬停、点击等动画处理 文本动画：对文本进行闪烁、渐变等动画处理 菜单动画：对菜单进行展开、收起等动画处理 提示动画：对提示信息进行出现、消失等动画处理 常见问题问题 1：如何创建平滑的 UI 动画？ 解决方案：使用缓动函数。通过应用缓动函数，可以创建平滑的 UI 动画过渡。 问题 2：如何同时动画多个 UI 属性？ 解决方案：在同一个动画片段中添加多个属性动画曲线。所有曲线应该有相同的时间范围。 问题 3：如何根据用户交互触发动画？ 解决方案：在交互系统中触发动画播放。可以使用 AnimationPlayer 的 play() 方法来播放动画。 性能考虑 动画数量：尽量减少同时播放的动画数量 属性选择：只对需要的属性进行动画处理 缓动函数：选择简单的缓动函数以提高性能 动画图优化：使用动画图来组织和管理动画 相关资源相关源代码文件： bevy/examples/animation/animated_ui.rs - UI 动画示例 官方文档链接： Bevy Animation 官方文档 UI 动画示例 进一步学习建议： 学习动画进阶，了解动画图和动画混合 学习 UI 基础，了解 UI 系统的使用 学习动画事件，了解如何在动画中触发事件 索引：返回上级目录"},{"title":"插件系统","path":"/Luo-Haomin/wiki/BevyBook/Architecture/plugin系统.html","content":"插件系统概述学习目标： 理解插件系统的基本概念 掌握插件的创建和注册 了解插件组的使用 学会配置和管理插件依赖 前置知识要求： Bevy 快速入门 ECS 基础 代码组织基础 核心概念什么是插件系统？插件系统是 Bevy 中用于组织和模块化功能的方式。插件是封装相关功能的模块，可以独立开发、测试和复用。 为什么需要插件系统？ 模块化：插件系统使代码更加模块化 可复用性：插件可以在不同项目中复用 可测试性：插件可以独立测试 可维护性：插件使代码更容易维护 插件系统的核心组件Bevy 插件系统包含以下核心组件： Plugin：插件 trait，用于定义插件 PluginGroup：插件组 trait，用于组织多个插件 App：应用程序，用于注册和管理插件 DefaultPlugins：默认插件组，包含基本功能 基础用法创建插件创建自定义插件。 源代码文件：bevy/examples/app/plugin.rs 代码示例： use bevy::prelude::*;use core::time::Duration;fn main() App::new() .add_plugins(( DefaultPlugins, PrintMessagePlugin wait_duration: Duration::from_secs(1), message: 这是一个示例插件.to_string(), , )) .run();// 打印消息插件struct PrintMessagePlugin wait_duration: Duration, message: String,impl Plugin for PrintMessagePlugin fn build(self, app: mut App) let state = PrintMessageState message: self.message.clone(), timer: Timer::new(self.wait_duration, TimerMode::Repeating), ; app.insert_resource(state) .add_systems(Update, print_message_system); #[derive(Resource)]struct PrintMessageState message: String, timer: Timer,fn print_message_system(mut state: ResMutPrintMessageState, time: ResTime) if state.timer.tick(time.delta()).is_finished() info!(, state.message); 关键要点： 实现 Plugin trait 来创建插件 在 build() 方法中配置插件 可以添加系统、资源、事件等 可以接受配置参数 说明：创建插件是组织代码的重要方式。通过将相关功能封装到插件中，可以使代码更加模块化和可维护。 插件组创建和管理插件组。 源代码文件：bevy/examples/app/plugin_group.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(( DefaultPlugins, HelloWorldPlugins, )) .run();// 插件组pub struct HelloWorldPlugins;impl PluginGroup for HelloWorldPlugins fn build(self) - PluginGroupBuilder PluginGroupBuilder::start::Self() .add(PrintHelloPlugin) .add(PrintWorldPlugin) struct PrintHelloPlugin;impl Plugin for PrintHelloPlugin fn build(self, app: mut App) app.add_systems(Update, print_hello_system); fn print_hello_system() info!(hello);struct PrintWorldPlugin;impl Plugin for PrintWorldPlugin fn build(self, app: mut App) app.add_systems(Update, print_world_system); fn print_world_system() info!(world); 关键要点： 实现 PluginGroup trait 来创建插件组 使用 PluginGroupBuilder 来构建插件组 可以组织多个相关插件 可以统一配置和管理插件 说明：插件组允许将多个相关插件组织在一起。这对于创建功能模块、管理插件依赖等非常有用。 插件配置配置插件行为。 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins( HelloWorldPlugins .build() .disable::PrintWorldPlugin() .add_before::PrintHelloPlugin( LogDiagnosticsPlugin::default(), ), ) .run(); 关键要点： 可以使用 disable() 禁用插件 可以使用 add_before() 和 add_after() 控制插件顺序 可以动态配置插件行为 可以条件性地启用插件 说明：插件配置允许灵活控制插件行为。这对于创建可配置的应用程序、支持不同平台等非常有用。 进阶用法插件依赖管理插件之间的依赖关系。 关键信息： 插件可以依赖其他插件 可以使用 PluginGroupBuilder 管理依赖顺序 可以检查插件是否已注册 可以处理插件依赖冲突 说明：插件依赖管理是创建复杂应用程序的关键。通过正确管理依赖关系，可以确保插件按正确顺序初始化。 条件插件根据条件启用或禁用插件。 代码示例： use bevy::prelude::*;fn main() let mut app = App::new(); // 根据条件添加插件 #[cfg(feature = debug)] app.add_plugins(LogDiagnosticsPlugin::default()); app.add_plugins(DefaultPlugins) .run(); 关键要点： 可以使用条件编译来启用或禁用插件 可以根据平台、特性等条件添加插件 可以创建可配置的插件系统 可以支持不同的构建配置 说明：条件插件允许根据不同的条件启用或禁用功能。这对于创建可配置的应用程序、支持不同平台等非常有用。 插件生命周期理解插件的生命周期。 关键信息： 插件在 App::build() 时初始化 插件可以添加启动系统、更新系统等 插件可以注册清理逻辑 插件可以监听应用事件 说明：理解插件生命周期对于正确使用插件非常重要。通过了解插件的生命周期，可以确保插件在正确的时机执行。 实际应用在游戏开发中的应用场景插件系统在游戏开发中有广泛的应用： 功能模块：将游戏功能组织成插件 第三方库：将第三方库封装成插件 游戏系统：将游戏系统（如物理、渲染）封装成插件 可配置性：通过插件系统创建可配置的应用程序 常见问题问题 1：如何创建可配置的插件？ 解决方案：在插件结构体中添加配置字段，并在 build() 方法中使用这些配置。 问题 2：如何处理插件依赖？ 解决方案：使用 PluginGroupBuilder 管理插件顺序，确保依赖插件先于被依赖插件初始化。 问题 3：如何条件性地启用插件？ 解决方案：使用条件编译（#[cfg]）或运行时条件来启用或禁用插件。 性能考虑 插件数量：尽量减少插件数量以提高启动速度 插件初始化：优化插件初始化逻辑以减少启动时间 插件依赖：合理组织插件依赖以减少初始化开销 条件插件：只在需要时启用插件以减少运行时开销 相关资源相关源代码文件： bevy/examples/app/plugin.rs - 插件示例 bevy/examples/app/plugin_group.rs - 插件组示例 官方文档链接： Bevy Plugin 官方文档 插件示例 进一步学习建议： 学习代码组织，了解如何组织插件代码 学习 ECS 系统，了解如何在插件中使用 ECS 学习资源管理，了解如何在插件中管理资源 索引：返回上级目录"},{"title":"动画进阶","path":"/Luo-Haomin/wiki/BevyBook/Animation/动画进阶.html","content":"动画进阶概述学习目标： 掌握动画图的创建和使用 理解动画混合的工作原理 学会使用动画事件 了解动画遮罩的使用 掌握缓动函数的使用 前置知识要求： 动画基础 ECS 基础 3D 开发基础 核心概念动画图（Animation Graph）动画图是 Bevy 中用于组织和管理动画的图形结构。它允许你创建复杂的动画混合和过渡。 为什么需要动画图？ 动画混合：可以在多个动画之间进行平滑过渡 动画组织：可以更好地组织和管理复杂的动画 性能优化：可以优化动画播放的性能 灵活性：可以动态调整动画权重 动画事件（Animation Events）动画事件允许你在动画播放的特定时间点触发自定义事件。 为什么需要动画事件？ 同步：可以在动画播放时同步其他系统 交互：可以在动画播放时触发交互 反馈：可以在动画播放时提供反馈 控制：可以更好地控制动画播放流程 动画遮罩（Animation Masks）动画遮罩允许你限制动画的作用范围，只对特定的骨骼或目标应用动画。 为什么需要动画遮罩？ 局部动画：可以对特定部位应用动画 动画组合：可以组合多个局部动画 性能优化：可以减少不必要的动画计算 灵活性：可以更灵活地控制动画 缓动函数（Easing Functions）缓动函数控制动画的加速和减速曲线，使动画更加自然。 为什么需要缓动函数？ 自然感：可以使动画更加自然 视觉效果：可以增强视觉效果 用户体验：可以改善用户体验 艺术表现：可以增强艺术表现力 基础用法动画图创建和使用动画图。 源代码文件：bevy/examples/animation/animation_graph.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();fn setup( mut commands: Commands, asset_server: ResAssetServer, mut graphs: ResMutAssetsAnimationGraph,) // 加载动画片段 let clip_handle = asset_server.load(animations/fox_idle.gltf#Animation0); // 从动画片段创建动画图 let (graph, node_index) = AnimationGraph::from_clip(clip_handle); let graph_handle = graphs.add(graph); // 创建动画播放器 let mut player = AnimationPlayer::default(); player.play(node_index).repeat(); // 创建实体并添加动画组件 commands.spawn(( AnimationGraphHandle(graph_handle), player, // ... 其他组件 )); 关键要点： 动画图用于组织和管理动画 可以从动画片段创建动画图 动画播放器用于播放动画图中的节点 可以设置动画的重复模式 说明：动画图是 Bevy 动画系统的核心。它允许你创建复杂的动画混合和过渡，使动画更加灵活和强大。 动画混合在多个动画之间进行混合。 源代码文件：bevy/examples/animation/animation_graph.rs 代码示例： use bevy::prelude::*;fn setup_animation_graph( mut graphs: ResMutAssetsAnimationGraph, mut clips: ResMutAssetsAnimationClip, asset_server: ResAssetServer,) // 加载多个动画片段 let idle_clip = asset_server.load(animations/fox_idle.gltf#Animation0); let walk_clip = asset_server.load(animations/fox_walk.gltf#Animation0); let run_clip = asset_server.load(animations/fox_run.gltf#Animation0); // 创建动画图 let mut graph = AnimationGraph::default(); // 添加动画节点 let idle_node = graph.add_clip(idle_clip); let walk_node = graph.add_clip(walk_clip); let run_node = graph.add_clip(run_clip); // 创建混合节点 let blend_node = graph.add_blend(Root); // 连接节点 graph.connect(idle_node, blend_node); graph.connect(walk_node, blend_node); graph.connect(run_node, blend_node); // 设置混合权重 graph.set_blend_weight(blend_node, idle_node, 0.5); graph.set_blend_weight(blend_node, walk_node, 0.3); graph.set_blend_weight(blend_node, run_node, 0.2); let graph_handle = graphs.add(graph); // 使用动画图 // ... 关键要点： 可以在多个动画之间进行混合 可以设置混合权重来控制混合比例 混合节点用于组合多个动画 可以动态调整混合权重 说明：动画混合是创建平滑动画过渡的关键。通过混合多个动画，可以创建更加自然和流畅的动画效果。 动画事件在动画播放时触发自定义事件。 源代码文件：bevy/examples/animation/animation_events.rs 代码示例： use bevy::prelude::*;#[derive(AnimationEvent, Clone)]struct SetMessage value: String, color: Color,fn setup( mut commands: Commands, mut animations: ResMutAssetsAnimationClip, mut graphs: ResMutAssetsAnimationGraph,) // 创建动画片段 let mut animation = AnimationClip::default(); animation.set_duration(2.0); // 添加事件 animation.add_event( 0.0, SetMessage value: HELLO.into(), color: Color::srgb(0.0, 0.5, 1.0), , ); animation.add_event( 1.0, SetMessage value: BYE.into(), color: Color::srgb(1.0, 0.0, 0.0), , ); // 创建动画图 let (graph, animation_index) = AnimationGraph::from_clip(animations.add(animation)); let mut player = AnimationPlayer::default(); player.play(animation_index).repeat(); commands.spawn(( AnimationGraphHandle(graphs.add(graph)), player, ));// 监听动画事件fn on_set_message( set_message: OnSetMessage, text: Single(mut Text2d, mut TextColor), WithMessageText,) let (mut text, mut color) = text.into_inner(); text.0 = set_message.value.clone(); color.0 = set_message.color; 关键要点： 动画事件可以在动画播放的特定时间点触发 需要实现 AnimationEvent trait 可以使用 OnT 观察者来监听动画事件 事件可以携带自定义数据 说明：动画事件是同步动画和其他系统的重要机制。通过动画事件，可以在动画播放时触发自定义逻辑，使动画更加交互和动态。 动画遮罩限制动画的作用范围。 源代码文件：bevy/examples/animation/animation_masks.rs 代码示例： use bevy::prelude::*;use std::collections::HashSet;// 定义遮罩组const MASK_GROUP_HEAD: u32 = 0;const MASK_GROUP_LEFT_ARM: u32 = 1;const MASK_GROUP_RIGHT_ARM: u32 = 2;fn setup_animation_with_mask( mut commands: Commands, mut graphs: ResMutAssetsAnimationGraph, asset_server: ResAssetServer,) // 加载动画 let clip_handle = asset_server.load(animations/character_walk.gltf#Animation0); // 创建动画图 let (graph, node_index) = AnimationGraph::from_clip(clip_handle); // 创建遮罩组 let mut mask_group = HashSet::new(); mask_group.insert(AnimationTargetId::from_name(Name::new(Head))); mask_group.insert(AnimationTargetId::from_name(Name::new(Neck))); // 应用遮罩 graph.set_mask(node_index, MASK_GROUP_HEAD, mask_group); let graph_handle = graphs.add(graph); let mut player = AnimationPlayer::default(); player.play(node_index).repeat(); commands.spawn(( AnimationGraphHandle(graph_handle), player, )); 关键要点： 动画遮罩可以限制动画的作用范围 可以创建多个遮罩组 遮罩组由动画目标 ID 集合定义 可以动态启用或禁用遮罩组 说明：动画遮罩是创建局部动画的重要工具。通过遮罩，可以对特定部位应用动画，而不会影响其他部位，使动画更加灵活和精细。 缓动函数使用缓动函数控制动画曲线。 源代码文件：bevy/examples/animation/easing_functions.rs 代码示例： use bevy::prelude::*;fn setup_animation_with_easing( mut commands: Commands, mut animations: ResMutAssetsAnimationClip, mut graphs: ResMutAssetsAnimationGraph,) // 创建动画片段 let mut animation = AnimationClip::default(); // 创建缓动曲线 let ease_function = EaseFunction::CubicInOut; // 添加动画曲线（使用缓动函数） animation.add_curve_to_target( target_id, AnimatableCurve::new( animated_field!(Transform::translation), AnimatableKeyframeCurve::new( [0.0, 1.0, 2.0].into_iter().zip([ Vec3::ZERO, Vec3::new(5.0, 0.0, 0.0), Vec3::ZERO, ]), ) .with_easing(ease_function) .expect(valid curve), ), ); let (graph, node_index) = AnimationGraph::from_clip(animations.add(animation)); let mut player = AnimationPlayer::default(); player.play(node_index).repeat(); commands.spawn(( AnimationGraphHandle(graphs.add(graph)), player, )); 关键要点： 缓动函数控制动画的加速和减速曲线 Bevy 提供了多种内置缓动函数 可以在动画曲线上应用缓动函数 缓动函数使动画更加自然 说明：缓动函数是创建自然动画的关键。通过使用不同的缓动函数，可以创建各种动画效果，从线性到弹性，从平滑到弹跳。 进阶用法动态调整动画权重在运行时动态调整动画混合权重。 源代码文件：bevy/examples/animation/animation_graph.rs 关键信息： 可以在运行时动态调整混合权重 权重调整会平滑过渡 可以基于游戏状态调整权重 权重总和应该为 1.0 说明：动态调整动画权重是创建响应式动画的关键。通过根据游戏状态调整权重，可以创建更加动态和交互的动画效果。 动画图序列化将动画图序列化为文件。 源代码文件：bevy/examples/animation/animation_graph.rs 关键信息： 动画图可以序列化为 RON 格式 可以从文件加载动画图 序列化可以保存复杂的动画配置 可以编辑序列化的动画图 说明：动画图序列化是保存和加载动画配置的重要功能。通过序列化，可以保存复杂的动画配置，并在需要时加载它们。 实际应用在游戏开发中的应用场景动画进阶功能在游戏开发中有广泛的应用： 角色动画：使用动画混合创建平滑的角色动画过渡 交互反馈：使用动画事件触发交互反馈 局部动画：使用动画遮罩创建局部动画效果 UI 动画：使用缓动函数创建自然的 UI 动画 常见问题问题 1：如何创建平滑的动画过渡？ 解决方案：使用动画混合和缓动函数。通过混合多个动画并应用缓动函数，可以创建平滑的动画过渡。 问题 2：如何在动画播放时触发其他系统？ 解决方案：使用动画事件。通过定义自定义动画事件并在动画播放时触发它们，可以同步动画和其他系统。 问题 3：如何只对特定部位应用动画？ 解决方案：使用动画遮罩。通过创建遮罩组并应用它们，可以限制动画的作用范围。 性能考虑 动画图优化：尽量减少动画图中的节点数量 遮罩优化：只对需要的部位应用遮罩 事件优化：避免在动画事件中执行耗时操作 缓动函数优化：选择简单的缓动函数以提高性能 相关资源相关源代码文件： bevy/examples/animation/animation_graph.rs - 动画图示例 bevy/examples/animation/animation_events.rs - 动画事件示例 bevy/examples/animation/animation_masks.rs - 动画遮罩示例 bevy/examples/animation/easing_functions.rs - 缓动函数示例 官方文档链接： Bevy Animation 官方文档 动画示例 进一步学习建议： 学习 UI 动画，了解如何对 UI 元素应用动画 学习变形目标，了解如何使用变形目标动画 学习 3D 图形，了解如何将动画应用于 3D 模型 索引：返回上级目录"},{"title":"Architecture（架构设计）","path":"/Luo-Haomin/wiki/BevyBook/Architecture/README.html","content":"Architecture（架构设计）本部分介绍如何组织和架构大型 Bevy 项目。 内容列表1. 代码组织 项目结构 模块化设计 文件组织 命名规范 代码分层 插件系统 创建插件 插件组织 插件依赖 插件配置 状态管理 AppState 模式 状态转换 状态清理 状态持久化 学习目标：能够组织大型项目的代码结构 2. 逻辑-渲染分离 架构概述 MainWorld 与 RenderApp ExtractSchedule 数据流向 Headless 模式 无渲染模式 实现方法 逻辑组件设计 渲染组件设计 数据提取 同步机制 最佳实践 性能优化 代码组织 常见问题 学习目标：理解并实现逻辑-渲染分离架构 3. 插件系统 插件基础 创建插件 插件注册 插件配置 插件组 创建插件组 插件组织 插件依赖 高级功能 插件依赖管理 条件插件 插件生命周期 学习目标：能够创建和管理 Bevy 插件 学习建议 模块化思维：将项目拆分为独立的模块 可维护性：编写易于维护和扩展的代码 性能考虑：在架构设计时考虑性能影响 团队协作：考虑多人协作的代码组织 相关资源 Bevy 插件系统 Bevy 状态管理 架构示例 下一步完成本部分学习后，建议继续学习： Advanced（高级主题） - 深入高级功能和优化 索引：返回主目录"},{"title":"逻辑-渲染分离","path":"/Luo-Haomin/wiki/BevyBook/Architecture/逻辑-渲染分离.html","content":"逻辑-渲染分离概述学习目标： 理解逻辑-渲染分离的基本概念 掌握 MainWorld 和 RenderApp 的使用 了解 ExtractSchedule 的作用 学会使用 Headless 模式和无渲染模式 前置知识要求： Bevy 快速入门 ECS 基础 代码组织基础 核心概念什么是逻辑-渲染分离？逻辑-渲染分离是 Bevy 的重要架构模式。它将游戏逻辑和渲染逻辑分离到不同的线程中，实现并行执行。 为什么需要逻辑-渲染分离？ 性能优化：逻辑和渲染可以并行执行，提高性能 架构清晰：逻辑和渲染分离，使架构更加清晰 灵活性：可以独立优化逻辑和渲染 可测试性：可以独立测试逻辑和渲染 逻辑-渲染分离的核心组件Bevy 逻辑-渲染分离包含以下核心组件： MainWorld：主世界，运行游戏逻辑 RenderApp：渲染应用，运行渲染逻辑 ExtractSchedule：提取调度，用于从 MainWorld 同步数据到 RenderApp SyncToRenderWorld：同步到渲染世界，用于同步组件数据 基础用法MainWorld 和 RenderApp理解 MainWorld 和 RenderApp 的关系。 架构： 主线程（MainWorld） 渲染线程（RenderApp）├─ 游戏逻辑更新 ├─ Extract（提取数据）├─ 物理模拟 ├─ Prepare（准备渲染）├─ AI 计算 ├─ Queue（队列渲染）└─ 输入处理 └─ Render（实际渲染） 关键要点： MainWorld 运行游戏逻辑 RenderApp 运行渲染逻辑 两者通过 ExtractSchedule 同步数据 渲染逻辑在独立线程中运行 说明：MainWorld 和 RenderApp 的分离是 Bevy 性能优化的关键。通过将逻辑和渲染分离，可以实现并行执行，提高性能。 ExtractSchedule使用 ExtractSchedule 同步数据。 关键信息： ExtractSchedule 在每帧开始时运行 从 MainWorld 提取数据到 RenderApp 可以提取组件、资源等数据 数据同步是单向的（MainWorld → RenderApp） 说明：ExtractSchedule 是逻辑-渲染分离的关键。通过 ExtractSchedule，可以将游戏逻辑数据同步到渲染世界，供渲染使用。 Headless 模式使用 Headless 模式运行无窗口应用。 源代码文件：bevy/examples/app/headless.rs 代码示例： use bevy::app::ScheduleRunnerPlugin, log::LogPlugin, prelude::*;use core::time::Duration;fn main() // 禁用默认特性，只启用需要的功能 // Cargo.toml: // [dependencies] // bevy = version = *, default-features = false, features = [bevy_log] // 运行一次的应用 App::new() .add_plugins(DefaultPlugins.set(ScheduleRunnerPlugin::run_once())) .add_systems(Update, hello_world_system) .run(); // 以 60 FPS 循环运行的应用 App::new() .add_plugins( DefaultPlugins .set(ScheduleRunnerPlugin::run_loop(Duration::from_secs_f64(1.0 / 60.0))) .disable::LogPlugin(), ) .add_systems(Update, counter) .run();fn hello_world_system() println!(hello world);fn counter(mut state: LocalCounterState) if state.count.is_multiple_of(60) println!(, state.count); state.count += 1;#[derive(Default)]struct CounterState count: u32, 关键要点： Headless 模式不需要窗口 可以用于服务器端应用 可以用于纯逻辑处理 需要禁用默认特性并只启用需要的功能 说明：Headless 模式适合服务器端应用、纯逻辑处理等场景。通过禁用窗口和渲染功能，可以减少资源消耗。 无渲染模式使用无渲染模式运行有窗口但无渲染的应用。 源代码文件：bevy/examples/app/no_renderer.rs 代码示例： use bevy:: prelude::*, render::settings::WgpuSettings, RenderPlugin,;fn main() App::new() .add_plugins( DefaultPlugins.set(RenderPlugin render_creation: WgpuSettings backends: None, ..default() .into(), ..default() ), ) .run(); 关键要点： 无渲染模式显示窗口但不渲染 可以用于集成测试或 CI 可以用于调试逻辑 需要禁用渲染后端 说明：无渲染模式适合集成测试、CI 等场景。通过禁用渲染后端，可以运行应用但不进行实际渲染。 进阶用法数据同步在 MainWorld 和 RenderApp 之间同步数据。 关键信息： 使用 Extract 系统提取数据 使用 SyncToRenderWorld 同步组件 数据同步是单向的 可以同步组件、资源等数据 说明：数据同步是逻辑-渲染分离的关键。通过正确同步数据，可以确保渲染世界有正确的数据。 渲染世界访问从 MainWorld 访问渲染世界。 关键信息： 可以使用 RenderApp 访问渲染世界 可以添加渲染系统 可以配置渲染管线 需要注意线程安全 说明：渲染世界访问允许从主世界配置渲染。这对于创建自定义渲染效果非常有用。 Headless 渲染器创建 Headless 渲染器。 源代码文件：bevy/examples/app/headless_renderer.rs 关键信息： 可以创建无窗口的渲染器 可以渲染到图像 可以保存渲染结果 适合批量渲染、CI 等场景 说明：Headless 渲染器允许在没有窗口的情况下进行渲染。这对于批量渲染、CI 等场景非常有用。 实际应用在游戏开发中的应用场景逻辑-渲染分离在游戏开发中有广泛的应用： 性能优化：通过并行执行逻辑和渲染提高性能 服务器端应用：使用 Headless 模式创建服务器 集成测试：使用无渲染模式进行集成测试 批量渲染：使用 Headless 渲染器进行批量渲染 常见问题问题 1：如何确保数据同步正确？ 解决方案：使用 Extract 系统正确提取数据，并使用 SyncToRenderWorld 同步组件。 问题 2：如何在 Headless 模式下运行应用？ 解决方案：禁用默认特性，只启用需要的功能，并使用 ScheduleRunnerPlugin 控制运行方式。 问题 3：如何从 MainWorld 访问 RenderApp？ 解决方案：使用 App::sub_app_mut() 访问 RenderApp，但需要注意线程安全。 性能考虑 数据同步开销：尽量减少需要同步的数据量 线程安全：注意 MainWorld 和 RenderApp 之间的线程安全 内存使用：注意 MainWorld 和 RenderApp 之间的内存使用 同步频率：合理控制数据同步频率 相关资源相关源代码文件： bevy/examples/app/headless.rs - Headless 模式示例 bevy/examples/app/no_renderer.rs - 无渲染模式示例 bevy/examples/app/headless_renderer.rs - Headless 渲染器示例 官方文档链接： Bevy App 官方文档 渲染系统文档 进一步学习建议： 学习代码组织，了解如何组织逻辑-渲染分离的代码 学习性能优化，了解如何优化逻辑-渲染分离的性能 学习自定义渲染，了解如何在渲染世界中创建自定义效果 索引：返回上级目录"},{"title":"Assets（资源管理）","path":"/Luo-Haomin/wiki/BevyBook/Assets/README.html","content":"Assets（资源管理）本部分介绍如何在 Bevy 中加载、管理和使用各种资源（Assets）。 内容列表1. 资源管理 资源系统概述 什么是 Assets Assets 的生命周期 资源加载流程 资源类型 图像资源（Image） 网格资源（Mesh） 材质资源（Material） 音频资源（Audio） 字体资源（Font） 自定义资源 资源加载 同步加载 异步加载 资源预加载 资源热重载 资源管理 资源句柄（Handle） 资源生命周期 资源清理 资源缓存 学习目标：能够加载和管理各种类型的资源 2. 场景系统（Scene） 场景保存 场景加载 动态场景 场景序列化 学习目标：能够保存和加载游戏场景 学习建议 理解生命周期：理解资源的加载、使用和卸载流程 实践加载：尝试加载不同类型的资源 性能考虑：注意资源加载对性能的影响 错误处理：学会处理资源加载失败的情况 相关资源 Bevy Assets 官方文档 资源加载示例 下一步完成本部分学习后，建议继续学习： Input（输入处理） - 处理用户输入 Graphics（图形渲染） - 使用资源进行渲染 索引：返回主目录"},{"title":"资源管理","path":"/Luo-Haomin/wiki/BevyBook/Assets/资源管理.html","content":"资源管理概述学习目标： 理解资源管理系统的基本概念 掌握资源类型的定义和使用 学会加载资源（同步、异步、预加载、热重载） 了解资源管理（句柄、生命周期、清理、缓存） 前置知识要求： Bevy 快速入门 ECS 基础 资源（Resources）基础 核心概念什么是资源管理？资源管理是 Bevy 中用于加载和管理游戏资源的功能。Bevy 的资源管理系统支持多种资源类型，包括模型、纹理、音频、字体等。 为什么需要资源管理？ 资源加载：游戏需要加载各种资源，如模型、纹理、音频等 异步加载：资源加载是异步的，不会阻塞游戏运行 资源缓存：资源管理系统会自动缓存已加载的资源 热重载：支持热重载，可以在运行时重新加载资源 资源管理的核心组件Bevy 资源管理系统包含以下核心组件： AssetServer：资源服务器，用于加载资源 Assets：资源集合，存储已加载的资源 Handle：资源句柄，用于引用资源 AssetLoader：资源加载器，用于加载特定类型的资源 基础用法资源加载加载资源的基本方法。 源代码文件：bevy/examples/asset/asset_loading.rs 代码示例： use bevy::asset::LoadedFolder, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();fn setup( mut commands: Commands, asset_server: ResAssetServer, meshes: ResAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) // 默认情况下，AssetServer 将从 assets 文件夹内加载资源 // 例如，下一行将加载 ROOT/assets/models/cube/cube.gltf // 其中 ROOT 是应用程序的目录 // // 这可以通过设置 [`AssetPlugin.file_path`] 来覆盖 let cube_handle = asset_server.load( GltfAssetLabel::Primitive mesh: 0, primitive: 0, .from_asset(models/cube/cube.gltf), ); let sphere_handle = asset_server.load( GltfAssetLabel::Primitive mesh: 0, primitive: 0, .from_asset(models/sphere/sphere.gltf), ); // 所有资源在加载完成后都会进入它们的 AssetsT 集合 if let Some(sphere) = meshes.get(sphere_handle) // 你可能会注意到这不会运行！这是因为资源在并行加载时不会阻塞 // 当资源加载完成时，它将出现在相关的 AssetsT 集合中 info!(:?, sphere.primitive_topology()); else info!(sphere 尚未加载); // 你可以像这样加载文件夹中的所有资源。它们将在不阻塞的情况下并行加载 // LoadedFolder 资源保存文件夹中每个资源的句柄 // 这些都是 LoadedFolder 资源的依赖项，这意味着如果你想要等待文件夹中的所有资源加载 // 可以等待 LoadedFolder 资源触发 AssetEvent::LoadedWithDependencies // 如果你想保持文件夹中的资源存活，请确保存储返回的句柄 let _loaded_folder: HandleLoadedFolder = asset_server.load_folder(models/torus); // 如果你想要文件夹中特定资源的句柄，最简单的方法是调用 load // 它不会再次加载 // LoadedFolder 资源最终也会保存资源的句柄，但等待它加载并找到正确的句柄需要更多工作 let torus_handle = asset_server.load( GltfAssetLabel::Primitive mesh: 0, primitive: 0, .from_asset(models/torus/torus.gltf), ); // 你也可以直接将资源添加到它们的 AssetsT 存储中 let material_handle = materials.add(StandardMaterial base_color: Color::srgb(0.8, 0.7, 0.6), ..default() ); // 使用加载的资源创建实体 commands.spawn(( Mesh3d(torus_handle), MeshMaterial3d(material_handle.clone()), Transform::from_xyz(-3.0, 0.0, 0.0), )); 关键要点： 使用 AssetServer 加载资源 资源加载是异步的，不会阻塞游戏运行 使用 AssetsT 集合访问已加载的资源 可以使用 load_folder() 加载整个文件夹的资源 可以使用 add() 方法直接添加资源到集合中 说明：资源加载是资源管理系统的基础。通过 AssetServer 加载资源，资源会在后台异步加载，不会阻塞游戏运行。加载完成后，资源会出现在相应的 AssetsT 集合中。 资源句柄使用资源句柄引用资源。 关键信息： HandleT 是资源的引用 句柄可以在资源加载完成之前使用 句柄可以克隆，多个句柄可以引用同一个资源 资源只有在所有句柄都被丢弃后才会被卸载 说明：资源句柄是资源管理系统的核心。它允许在资源加载完成之前就使用资源，并且可以安全地共享资源引用。 资源生命周期理解资源的生命周期。 关键信息： 资源在加载时创建 资源在最后一个句柄被丢弃时卸载 资源可以被缓存以提高性能 资源可以被热重载 说明：资源的生命周期由句柄管理。只要还有句柄引用资源，资源就会保持在内存中。当所有句柄都被丢弃时，资源会被卸载。 进阶用法自定义资源类型创建自定义资源类型。 源代码文件：bevy/examples/asset/custom_asset.rs 代码示例： use bevy:: asset::io::Reader, AssetLoader, LoadContext, prelude::*, reflect::TypePath,;use serde::Deserialize;#[derive(Asset, TypePath, Debug, Deserialize)]struct CustomAsset value: i32,#[derive(Default)]struct CustomAssetLoader;impl AssetLoader for CustomAssetLoader type Asset = CustomAsset; type Settings = (); type Error = CustomAssetLoaderError; async fn load( self, reader: mut dyn Reader, _settings: (), _load_context: mut LoadContext_, ) - ResultSelf::Asset, Self::Error let mut bytes = Vec::new(); reader.read_to_end(mut bytes).await?; let custom_asset = ron::de::from_bytes::CustomAsset(bytes)?; Ok(custom_asset) fn extensions(self) - [str] [custom] fn main() App::new() .add_plugins(DefaultPlugins) .init_asset::CustomAsset() .init_asset_loader::CustomAssetLoader() .run(); 关键要点： 使用 #[derive(Asset, TypePath)] 定义资源类型 实现 AssetLoader trait 来创建资源加载器 在应用中初始化资源类型和加载器 可以支持自定义文件格式 说明：自定义资源类型允许你创建自己的资源格式。这对于游戏特定的数据格式非常有用。 热重载在运行时重新加载资源。 源代码文件：bevy/examples/asset/hot_asset_reloading.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();fn setup(mut commands: Commands, asset_server: ResAssetServer) // 加载我们的网格 let scene_handle = asset_server.load(GltfAssetLabel::Scene(0).from_asset(models/torus/torus.gltf)); // 对网格的任何更改都会自动重新加载！尝试修改 torus.gltf // 你应该会立即看到更改出现在应用中 commands.spawn(SceneRoot(scene_handle)); 关键要点： 热重载允许在运行时修改资源文件 修改后的资源会自动重新加载 需要启用 file_watcher cargo feature 适合开发时快速迭代 说明：热重载功能允许在开发时快速迭代。修改资源文件后，资源会自动重新加载，无需重启游戏。 嵌入资源将资源嵌入到可执行文件中。 源代码文件：bevy/examples/asset/embedded_asset.rs 关键信息： 可以使用 embedded_asset! 宏嵌入资源 嵌入的资源包含在可执行文件中 适合小型资源或需要快速加载的资源 可以与其他资源加载方式结合使用 说明：嵌入资源允许将资源直接包含在可执行文件中。这对于小型资源或需要快速加载的资源非常有用。 额外资源源从多个源加载资源。 源代码文件：bevy/examples/asset/extra_source.rs 关键信息： 可以配置多个资源源 可以从不同的目录或服务器加载资源 可以设置资源源的优先级 适合模块化资源管理 说明：额外资源源允许从多个位置加载资源。这对于模块化资源管理或从服务器加载资源非常有用。 实际应用在游戏开发中的应用场景资源管理在游戏开发中有广泛的应用： 模型加载：加载 3D 模型和场景 纹理加载：加载纹理和材质 音频加载：加载音频文件 字体加载：加载字体文件 配置文件：加载游戏配置数据 常见问题问题 1：如何等待资源加载完成？ 解决方案：可以监听 AssetEvent::LoadedWithDependencies 事件，或者使用 AssetsT 的 get() 方法检查资源是否已加载。 问题 2：如何管理资源的生命周期？ 解决方案：资源的生命周期由句柄管理。只要还有句柄引用资源，资源就会保持在内存中。确保在不再需要资源时丢弃句柄。 问题 3：如何优化资源加载性能？ 解决方案：可以使用资源预加载、资源缓存、资源压缩等技术来优化资源加载性能。 性能考虑 资源预加载：在需要之前预加载资源 资源缓存：合理使用资源缓存以减少重复加载 资源压缩：使用压缩格式减少资源大小 异步加载：利用异步加载避免阻塞游戏运行 相关资源相关源代码文件： bevy/examples/asset/asset_loading.rs - 资源加载示例 bevy/examples/asset/custom_asset.rs - 自定义资源类型示例 bevy/examples/asset/hot_asset_reloading.rs - 热重载示例 bevy/examples/asset/embedded_asset.rs - 嵌入资源示例 bevy/examples/asset/extra_source.rs - 额外资源源示例 官方文档链接： Bevy Asset 官方文档 资源示例 进一步学习建议： 学习场景系统，了解如何加载和管理场景 学习资源管理，了解如何优化资源加载性能 学习自定义资源类型，了解如何创建自己的资源格式 索引：返回上级目录"},{"title":"代码组织","path":"/Luo-Haomin/wiki/BevyBook/Architecture/代码组织.html","content":"代码组织Bevy 代码组织指南本指南介绍Bevy引擎中推荐的代码组织方式，帮助您构建可维护、可扩展的游戏项目。 模块 (Module) 组织Rust模块基础Rust的模块系统是代码组织的基础，在Bevy项目中尤为重要： // lib.rs 或 main.rsmod player;mod enemy;mod ui;mod systems;mod resources;// 重新导出常用类型pub use player::PlayerPlugin;pub use enemy::EnemyPlugin;pub use ui::UiPlugin; 按功能组织模块// player/mod.rsmod components;mod systems;mod resources;pub use components::*;pub use systems::*;pub use resources::*;pub struct PlayerPlugin;impl Plugin for PlayerPlugin fn build(self, app: mut App) app.add_systems(Startup, systems::spawn_player) .add_systems(Update, systems::player_movement); 按层级组织模块// 游戏逻辑层mod game mod player; mod enemy; mod combat;// 系统层mod systems mod movement; mod collision; mod rendering;// 资源层mod resources mod assets; mod config; mod state; 插件 (Plugin) 系统插件基础插件是Bevy中最重要的代码组织方式，将相关功能打包成可重用的单元： use bevy::prelude::*;pub struct GamePlugin;impl Plugin for GamePlugin fn build(self, app: mut App) app // 添加子插件 .add_plugins(( PlayerPlugin, EnemyPlugin, UiPlugin, )) // 添加资源 .init_resource::GameState() .insert_resource(GameConfig::default()) // 添加事件 .add_event::PlayerDied() .add_event::EnemySpawned() // 添加系统 .add_systems(Startup, setup_game) .add_systems(Update, game_loop); 条件插件根据配置或环境决定是否启用插件： pub struct DebugPlugin;impl Plugin for DebugPlugin fn build(self, app: mut App) #[cfg(debug_assertions)] app.add_systems(Update, debug_system); // 或者使用特性标志#[cfg(feature = debug)]pub struct DebugPlugin;impl Plugin for DebugPlugin fn build(self, app: mut App) app.add_systems(Update, debug_system); 插件配置通过配置结构体自定义插件行为： #[derive(Resource)]pub struct PlayerConfig pub speed: f32, pub health: f32, pub spawn_position: Vec3,impl Default for PlayerConfig fn default() - Self Self speed: 5.0, health: 100.0, spawn_position: Vec3::ZERO, pub struct PlayerPlugin config: PlayerConfig,impl PlayerPlugin pub fn new(config: PlayerConfig) - Self Self config pub fn with_speed(mut self, speed: f32) - Self self.config.speed = speed; self impl Plugin for PlayerPlugin fn build(self, app: mut App) app.insert_resource(self.config.clone()) .add_systems(Startup, spawn_player) .add_systems(Update, player_movement); // 使用fn main() App::new() .add_plugins(DefaultPlugins) .add_plugins(PlayerPlugin::new(PlayerConfig speed: 10.0, health: 150.0, spawn_position: Vec3::new(0.0, 0.0, 0.0), )) .run(); 插件依赖管理pub struct CombatPlugin;impl Plugin for CombatPlugin fn build(self, app: mut App) // 确保依赖的插件已经添加 if !app.is_plugin_added::PlayerPlugin() app.add_plugins(PlayerPlugin); app.add_systems(Update, combat_system); Bundle 组件集合Bundle基础Bundle是组件的集合，用于一次性添加多个相关组件： #[derive(Bundle)]struct PlayerBundle player: Player, health: Health, transform: Transform, sprite: Sprite, collider: Collider,impl Default for PlayerBundle fn default() - Self Self player: Player, health: Health::new(100.0), transform: Transform::from_xyz(0.0, 0.0, 0.0), sprite: Sprite::new(Vec2::new(32.0, 32.0)), collider: Collider::circle(16.0), 参数化Bundle#[derive(Bundle)]struct PlayerBundle player: Player, health: Health, transform: Transform, sprite: Sprite, collider: Collider,impl PlayerBundle pub fn new(position: Vec3, health: f32) - Self Self player: Player, health: Health::new(health), transform: Transform::from_translation(position), sprite: Sprite::new(Vec2::new(32.0, 32.0)), collider: Collider::circle(16.0), pub fn with_sprite(mut self, size: Vec2) - Self self.sprite = Sprite::new(size); self pub fn with_collider(mut self, radius: f32) - Self self.collider = Collider::circle(radius); self 组合Bundle#[derive(Bundle)]struct PhysicsBundle transform: Transform, velocity: Velocity, collider: Collider,#[derive(Bundle)]struct RenderBundle sprite: Sprite, material: HandleColorMaterial,#[derive(Bundle)]struct PlayerBundle #[bundle] physics: PhysicsBundle, #[bundle] render: RenderBundle, player: Player, health: Health,// 使用commands.spawn(PlayerBundle physics: PhysicsBundle transform: Transform::from_xyz(0.0, 0.0, 0.0), velocity: Velocity::default(), collider: Collider::circle(16.0), , render: RenderBundle sprite: Sprite::new(Vec2::new(32.0, 32.0)), material: materials.add(Color::RED), , player: Player, health: Health::new(100.0),); 动态Bundlefn spawn_player( mut commands: Commands, asset_server: ResAssetServer, mut materials: ResMutAssetsColorMaterial,) let mut bundle = PlayerBundle::default(); // 根据配置动态修改 if let Some(texture) = asset_server.get_handle(player.png) bundle.sprite = Sprite::new(Vec2::new(64.0, 64.0)); bundle.material = materials.add(ColorMaterial::from(texture)); commands.spawn(bundle); 系统集 (SystemSet)系统集基础系统集用于组织和排序相关的系统： #[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]enum GameSet Input, Movement, Combat, Rendering,fn main() App::new() .add_plugins(DefaultPlugins) .configure_sets(Update, ( GameSet::Input, GameSet::Movement, GameSet::Combat, GameSet::Rendering, ).chain()) .add_systems(Update, ( handle_input.in_set(GameSet::Input), player_movement.in_set(GameSet::Movement), enemy_movement.in_set(GameSet::Movement), combat_system.in_set(GameSet::Combat), render_system.in_set(GameSet::Rendering), )) .run(); 条件系统集#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]enum GameSet Input, Movement, Combat, Rendering,#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]enum PauseSet Paused, Unpaused,fn main() App::new() .add_plugins(DefaultPlugins) .configure_sets(Update, ( GameSet::Input, GameSet::Movement, GameSet::Combat, GameSet::Rendering, ).chain()) .configure_sets(Update, ( PauseSet::Paused, PauseSet::Unpaused, ).chain()) .add_systems(Update, ( handle_input.in_set(GameSet::Input), player_movement.in_set((GameSet::Movement, PauseSet::Unpaused)), pause_menu.in_set((GameSet::Input, PauseSet::Paused)), )) .run(); 动态系统集#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]enum GameState Menu, Playing, Paused, GameOver,fn main() App::new() .add_plugins(DefaultPlugins) .add_state::GameState() .add_systems(Update, ( menu_system.run_if(in_state(GameState::Menu)), game_system.run_if(in_state(GameState::Playing)), pause_system.run_if(in_state(GameState::Paused)), game_over_system.run_if(in_state(GameState::GameOver)), )) .run(); 完整的项目结构示例目录结构src/├── main.rs├── lib.rs├── game/│ ├── mod.rs│ ├── player/│ │ ├── mod.rs│ │ ├── components.rs│ │ ├── systems.rs│ │ ├── resources.rs│ │ └── plugin.rs│ ├── enemy/│ │ ├── mod.rs│ │ ├── components.rs│ │ ├── systems.rs│ │ └── plugin.rs│ └── combat/│ ├── mod.rs│ ├── components.rs│ ├── systems.rs│ └── plugin.rs├── systems/│ ├── mod.rs│ ├── movement.rs│ ├── collision.rs│ └── rendering.rs├── resources/│ ├── mod.rs│ ├── assets.rs│ ├── config.rs│ └── state.rs└── ui/ ├── mod.rs ├── components.rs ├── systems.rs └── plugin.rs 主入口文件// main.rsuse bevy::prelude::*;use game::GamePlugin;fn main() App::new() .add_plugins(DefaultPlugins) .add_plugins(GamePlugin) .run(); 游戏模块// game/mod.rsmod player;mod enemy;mod combat;pub use player::PlayerPlugin;pub use enemy::EnemyPlugin;pub use combat::CombatPlugin;pub struct GamePlugin;impl Plugin for GamePlugin fn build(self, app: mut App) app.add_plugins(( PlayerPlugin, EnemyPlugin, CombatPlugin, )) .add_systems(Startup, setup_game) .add_systems(Update, game_loop); fn setup_game(mut commands: Commands) // 游戏初始化逻辑fn game_loop() // 游戏主循环逻辑 玩家模块// game/player/mod.rsmod components;mod systems;mod resources;pub use components::*;pub use systems::*;pub use resources::*;pub struct PlayerPlugin;impl Plugin for PlayerPlugin fn build(self, app: mut App) app.init_resource::PlayerConfig() .add_systems(Startup, spawn_player) .add_systems(Update, ( player_movement, player_animation, player_health, )); // game/player/components.rsuse bevy::prelude::*;#[derive(Component)]pub struct Player;#[derive(Component)]pub struct PlayerHealth pub current: f32, pub maximum: f32,#[derive(Bundle)]pub struct PlayerBundle pub player: Player, pub health: PlayerHealth, pub transform: Transform, pub sprite: Sprite,// game/player/systems.rsuse bevy::prelude::*;use super::components::*;pub fn spawn_player(mut commands: Commands) commands.spawn(PlayerBundle player: Player, health: PlayerHealth current: 100.0, maximum: 100.0, , transform: Transform::from_xyz(0.0, 0.0, 0.0), sprite: Sprite::new(Vec2::new(32.0, 32.0)), );pub fn player_movement( keyboard_input: ResButtonInputKeyCode, mut query: Querymut Transform, WithPlayer,) for mut transform in mut query if keyboard_input.pressed(KeyCode::KeyW) transform.translation.y += 1.0; if keyboard_input.pressed(KeyCode::KeyS) transform.translation.y -= 1.0; if keyboard_input.pressed(KeyCode::KeyA) transform.translation.x -= 1.0; if keyboard_input.pressed(KeyCode::KeyD) transform.translation.x += 1.0; 最佳实践1. 模块组织 按功能划分模块，而不是按类型 使用清晰的模块层次结构 在模块根文件中重新导出常用类型 避免过深的模块嵌套 2. 插件设计 每个主要功能创建一个插件 使用配置结构体自定义插件行为 实现插件依赖管理 使用条件编译控制插件功能 3. Bundle设计 将经常一起使用的组件组合成Bundle 提供便捷的构造方法 支持参数化配置 使用组合模式构建复杂Bundle 4. 系统集管理 使用系统集组织相关系统 明确定义系统执行顺序 使用条件系统集控制执行 避免系统集之间的循环依赖 5. 代码组织原则 单一职责: 每个模块、插件、系统只负责一个功能 开闭原则: 对扩展开放，对修改封闭 依赖倒置: 依赖抽象而不是具体实现 接口隔离: 提供小而专注的接口 6. 性能考虑 合理使用系统集避免不必要的系统执行 使用Bundle减少实体创建开销 避免在插件初始化时进行复杂计算 使用条件系统减少运行时开销 常见模式1. 功能模块模式// 每个功能一个模块mod player pub struct PlayerPlugin; impl Plugin for PlayerPlugin /* ... */ mod enemy pub struct EnemyPlugin; impl Plugin for EnemyPlugin /* ... */ // 主插件组合所有功能pub struct GamePlugin;impl Plugin for GamePlugin fn build(self, app: mut App) app.add_plugins(( player::PlayerPlugin, enemy::EnemyPlugin, )); 2. 分层架构模式// 数据层mod data mod components; mod resources;// 逻辑层mod logic mod systems; mod events;// 表现层mod presentation mod ui; mod rendering; 3. 特性模块模式// 核心功能mod core pub struct CorePlugin;// 可选功能#[cfg(feature = debug)]mod debug pub struct DebugPlugin;#[cfg(feature = networking)]mod networking pub struct NetworkingPlugin; 通过合理的代码组织，您可以构建出可维护、可扩展、高性能的Bevy游戏项目。记住，好的代码组织不仅能提高开发效率，还能让团队协作更加顺畅。"},{"title":"场景系统（Scene）","path":"/Luo-Haomin/wiki/BevyBook/Assets/场景系统（Scene）.html","content":"场景系统（Scene）概述学习目标： 理解 Bevy 场景系统的基本概念 掌握场景的保存和加载 了解动态场景的使用 学会使用场景序列化和反序列化 前置知识要求： Bevy 快速入门 ECS 基础 资源管理基础 反射系统基础 核心概念什么是场景系统？场景系统是 Bevy 中用于保存和加载场景数据的功能。场景系统允许您将实体、组件和资源序列化到文件中，并在需要时加载它们。 为什么需要场景系统？ 场景保存：场景系统可以保存游戏场景到文件 场景加载：场景系统可以从文件加载游戏场景 数据持久化：场景系统可以实现数据持久化 场景编辑：场景系统可以用于场景编辑工具 场景系统的核心组件Bevy 场景系统包含以下核心组件： Scene：场景，包含序列化的实体和组件 DynamicScene：动态场景，用于运行时创建场景 DynamicSceneRoot：动态场景根，用于加载场景 SceneSpawner：场景生成器，用于生成场景实体 基础用法场景保存保存场景到文件。 源代码文件：bevy/examples/scene/scene.rs 代码示例： use bevy::asset::LoadState, prelude::*, tasks::IoTaskPool;use core::time::Duration;use std::fs::File, io::Write;/// 入口点////// 设置默认插件，注册所有必要的组件/资源类型/// 以进行序列化/反射，并在正确的调度中运行各种系统。fn main() App::new() .add_plugins(DefaultPlugins) .add_systems( Startup, (save_scene_system, load_scene_system, infotext_system), ) .add_systems(Update, (log_system, panic_on_fail)) .run();/// 演示如何从头开始创建新场景，填充数据，/// 然后将其序列化到文件。新文件写入 `NEW_SCENE_FILE_PATH`。////// 此系统创建一个新世界，复制类型注册表以便我们的/// 自定义组件类型被识别，生成一些示例实体和资源，/// 然后序列化生成的动态场景。fn save_scene_system(world: mut World) // 场景可以从任何 ECS World 创建。 // 您可以创建一个新场景或使用当前 World。 // 为了演示目的，我们将创建一个新的。 let mut scene_world = World::new(); // `TypeRegistry` 资源包含有关所有已注册类型（包括组件）的信息。 // 这用于构建场景，因此我们希望确保之前的类型注册 // 也存在于这个新场景世界中。 // 为此，我们可以简单地克隆 `AppTypeRegistry` 资源。 let type_registry = world.resource::AppTypeRegistry().clone(); scene_world.insert_resource(type_registry); let mut component_b = ComponentB::from_world(world); component_b.value = hello.to_string(); scene_world.spawn(( component_b, ComponentA x: 1.0, y: 2.0 , Transform::IDENTITY, Name::new(joe), )); scene_world.spawn(ComponentA x: 3.0, y: 4.0 ); scene_world.insert_resource(ResourceA score: 1 ); // 准备好我们的示例世界后，我们现在可以使用 DynamicScene 或 DynamicSceneBuilder 创建场景。 // 为了简单起见，我们将使用 DynamicScene 创建场景： let scene = DynamicScene::from_world(scene_world); // 场景可以像这样序列化： let type_registry = world.resource::AppTypeRegistry(); let type_registry = type_registry.read(); let serialized_scene = scene.serialize(type_registry).unwrap(); // 在控制台中显示场景 info!(, serialized_scene); // 将场景写入新文件。使用任务避免在系统中调用文件系统 API， // 因为它们是阻塞的。 // // 这在 Wasm 中无法工作，因为没有文件系统访问。 #[cfg(not(target_arch = wasm32))] IoTaskPool::get() .spawn(async move // 写入场景文件 File::create(scenes/load_scene_example-new.scn.ron) .and_then(|mut file| file.write_all(serialized_scene.as_bytes())) .expect(Error while writing scene to file); ) .detach();/// 从资源文件加载场景并将其动态应用到 Bevy World 中的实体。////// 生成 `DynamicSceneRoot` 会创建一个新的父实体，然后生成场景的/// 新实例作为其子实体。如果您修改 `SCENE_FILE_PATH` 场景文件，/// 或者如果您启用文件监视，您可以看到更改立即反映。fn load_scene_system(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(DynamicSceneRoot(asset_server.load(scenes/load_scene_example.scn.ron)));/// 记录对 `ComponentA` 实体所做的更改，并检查 `ResourceA` 是否最近被添加。////// 每当修改 `ComponentA` 时，该更改将出现在这里。此系统/// 演示了如何在运行时检测和处理场景更新。fn log_system( query: Query(Entity, ComponentA), ChangedComponentA, res: OptionResResourceA,) for (entity, component_a) in query info!( Entity(), entity.index()); info!( ComponentA: x: y: , component_a.x, component_a.y ); if let Some(res) = res res.is_added() info!( New ResourceA: score: , res.score); /// 一个示例组件，完全可序列化。////// 此组件具有将包含在场景文件中的公共 `x` 和 `y` 字段。/// 注意它如何派生 `Default`、`Reflect`，并使用 `#[reflect(Component)]` 声明自己为反射组件。#[derive(Component, Reflect, Default)]#[reflect(Component)] // 这告诉反射派生也反射组件行为struct ComponentA /// 示例 `f32` 字段 pub x: f32, /// 另一个示例 `f32` 字段 pub y: f32,/// 一个示例组件，包括可序列化和不可序列化字段。////// 这对于跳过运行时数据的序列化或您不想要写入场景文件的字段很有用。#[derive(Component, Reflect)]#[reflect(Component)]struct ComponentB /// 将被序列化的字符串字段。 pub value: String, /// 一个 `Duration` 字段，永远不应该序列化到场景文件，所以我们跳过它。 #[reflect(skip_serializing)] pub _time_since_startup: Duration,/// 这为 `ComponentB` 实现了 `FromWorld`，让我们通过访问当前 ECS 资源来初始化运行时字段。/// 在这种情况下，我们获取 `Time` 资源并存储当前经过的时间。impl FromWorld for ComponentB fn from_world(world: mut World) - Self let time = world.resource::Time(); ComponentB _time_since_startup: time.elapsed(), value: Default Value.to_string(), /// 一个简单的资源，也派生 `Reflect`，允许它存储在场景中。////// 就像组件一样，如果需要，您可以跳过序列化字段或实现 `FromWorld`。#[derive(Resource, Reflect, Default)]#[reflect(Resource)]struct ResourceA /// 此资源跟踪 `score` 值。 pub score: u32, 关键要点： 使用 DynamicScene::from_world() 从世界创建场景 使用 scene.serialize() 序列化场景 使用 DynamicSceneRoot 加载场景 使用 #[reflect(Component)] 和 #[reflect(Resource)] 使类型可序列化 使用 #[reflect(skip_serializing)] 跳过序列化字段 说明：场景保存是场景系统的基础。通过使用场景保存，可以将游戏场景保存到文件，实现数据持久化。 场景加载从文件加载场景。 关键信息： 使用 AssetServer::load() 加载场景文件 使用 DynamicSceneRoot 生成场景根实体 场景会自动生成为场景根的子实体 使用文件监视可以实时更新场景 说明：场景加载是场景系统的基础。通过使用场景加载，可以从文件加载游戏场景，实现场景的复用。 进阶用法动态场景使用动态场景在运行时创建场景。 关键信息： 使用 DynamicScene::from_world() 从世界创建动态场景 使用 DynamicSceneBuilder 构建动态场景 使用 DynamicScene::write_to_world() 将场景写入世界 说明：动态场景是场景系统的高级功能。通过使用动态场景，可以在运行时创建场景，实现更灵活的场景管理。 场景序列化使用反射系统序列化和反序列化场景。 关键信息： 使用 #[derive(Reflect)] 使类型可反射 使用 #[reflect(Component)] 使组件可序列化 使用 #[reflect(Resource)] 使资源可序列化 使用 #[reflect(skip_serializing)] 跳过序列化字段 说明：场景序列化是场景系统的重要功能。通过使用反射系统，可以序列化和反序列化场景，实现场景的保存和加载。 实际应用在游戏开发中的应用场景场景系统在游戏开发中有广泛的应用： 场景保存：保存游戏场景到文件 场景加载：从文件加载游戏场景 数据持久化：实现游戏数据的持久化 场景编辑：用于场景编辑工具 常见问题问题 1：如何使类型可序列化？ 解决方案： 使用 #[derive(Reflect)] 使类型可反射 使用 #[reflect(Component)] 使组件可序列化 使用 #[reflect(Resource)] 使资源可序列化 使用 AppTypeRegistry 注册类型 问题 2：如何跳过序列化字段？ 解决方案： 使用 #[reflect(skip_serializing)] 跳过序列化字段 使用 FromWorld 实现初始化运行时字段 问题 3：如何加载场景？ 解决方案： 使用 AssetServer::load() 加载场景文件 使用 DynamicSceneRoot 生成场景根实体 场景会自动生成为场景根的子实体 性能考虑 场景序列化：场景序列化是阻塞操作，应使用异步任务 场景加载：场景加载是异步操作，应使用 AssetServer 类型注册：类型注册应在应用启动时完成 相关资源相关源代码文件： bevy/examples/scene/scene.rs - 场景系统示例 官方文档链接： Bevy 场景系统 Bevy 反射系统 进一步学习建议： 学习资源管理，了解资源加载和管理 学习反射系统，了解类型反射和序列化 索引：返回上级目录 ```markdown ## 内容列表 ### 1. [资源管理](/Luo-Haomin/wiki/BevyBook/Assets/资源管理) - 资源系统概述 - 资源类型 - 资源加载 - 资源管理 **学习目标**：能够加载和管理资源 ### 2. [场景系统（Scene）](/Luo-Haomin/wiki/BevyBook/Assets/场景系统（Scene）) - 场景保存 - 场景加载 - 动态场景 - 场景序列化 **学习目标**：能够保存和加载场景"},{"title":"Bevy——Rust框架","path":"/Luo-Haomin/wiki/BevyBook/Foundation/Bevy——Rust框架.html","content":"Bevy——Rust框架概述学习目标： 理解 Bevy 是什么以及它的设计目标 了解 Bevy 与 Rust 的关系 理解 Bevy 的模块化架构 了解 Bevy 的 Cargo features 理解 Bevy 的 ECS 实现 了解 Bevy 的插件系统 前置知识要求： Rust 基础语法 基本的 Rust 项目结构 Cargo 包管理器使用 核心概念什么是 Bevy？Bevy 是一个用 Rust 构建的简单、数据驱动的游戏引擎。它是免费且开源的。 源代码文件：bevy/README.md 关键信息： Bevy 是一个数据驱动的游戏引擎 Bevy 使用 ECS（Entity Component System）架构 Bevy 是模块化的，可以按需使用功能 Bevy 专注于开发者生产力和性能 说明：Bevy 的设计目标是创建一个简单易用但功能强大的游戏引擎。它使用数据导向的架构，通过 ECS 模式实现高性能的游戏逻辑。 Bevy 的设计目标Bevy 有以下几个核心设计目标： 源代码文件：bevy/README.md 设计目标： Capable（功能完整）：提供完整的 2D 和 3D 功能集 Simple（简单易用）：新手容易上手，但为高级用户提供无限灵活性 Data Focused（数据导向）：使用 ECS 范式的数据导向架构 Modular（模块化）：只使用你需要的功能，替换你不喜欢的部分 Fast（快速）：应用逻辑应该快速运行，尽可能并行执行 Productive（高效）：更改应该快速编译，等待不有趣 说明：这些设计目标指导了 Bevy 的开发和设计决策。Bevy 试图在简单性和功能完整性之间找到平衡。 Bevy 与 Rust 的关系Bevy 是用 Rust 构建的，充分利用了 Rust 的特性。 源代码文件：bevy/src/lib.rs 关键信息： Bevy 使用 Rust 的所有权系统管理内存 Bevy 利用 Rust 的类型系统确保安全性 Bevy 使用 Rust 的并发特性实现并行执行 Bevy 的模块化架构与 Rust 的模块系统完美契合 说明：Rust 的所有权系统和类型系统使 Bevy 能够在编译时捕获许多错误，同时提供高性能。Rust 的并发特性使 Bevy 能够实现大规模并行执行。 Bevy 的模块化架构Bevy 采用模块化架构，每个模块都是独立的 crate。 源代码文件：bevy/src/lib.rs 代码示例： // bevy crate 是一个容器 crate，使消费 Bevy 子 crate 更容易// 默认提供完整的引擎体验，但你可以轻松地在项目的 Cargo.toml 中启用/禁用功能 关键要点： Bevy 由多个独立的 crate 组成 每个模块都可以单独使用 可以通过 Cargo features 控制功能 可以替换不喜欢的模块 说明：Bevy 的模块化架构允许开发者只使用需要的功能，减少编译时间和二进制大小。每个模块都是独立的 crate，可以在 crates.io 上找到。 Bevy 的 Cargo FeaturesBevy 支持通过 Cargo features 自定义功能集。 源代码文件：bevy/docs/cargo_features.md 关键信息： 可以通过 Cargo features 启用禁用功能 默认功能提供完整的引擎体验 可以只启用需要的功能以减少编译时间 某些功能是互斥的 说明：Cargo features 允许开发者根据项目需求自定义 Bevy 功能集。这对于减少编译时间、减小二进制大小或创建特定用途的构建非常有用。 Bevy 的 ECS 实现Bevy 使用 ECS（Entity Component System）作为核心架构。 源代码文件：bevy/crates/bevy_ecs/README.md 关键信息： Bevy 的 ECS 实现是高性能的 支持大规模并行执行 使用数据导向的设计 提供类型安全的查询系统 说明：ECS 是 Bevy 的核心架构模式。它允许开发者以数据导向的方式组织游戏逻辑，实现高性能和可扩展性。 Bevy 的插件系统Bevy 使用插件系统组织功能。 源代码文件：bevy/src/lib.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .run(); 关键要点： 插件是封装相关功能的模块 可以使用 add_plugins() 添加插件 DefaultPlugins 包含窗口、输入、渲染等基本功能 可以创建自定义插件来组织功能 说明：Bevy 的插件系统允许开发者将功能组织成模块。这使得代码更加模块化和可维护。 实际应用在游戏开发中的应用场景Bevy 适用于各种游戏开发场景： 2D 游戏开发：Bevy 提供完整的 2D 功能集 3D 游戏开发：Bevy 提供完整的 3D 功能集 原型开发：Bevy 的简单性和快速编译使其适合原型开发 学习游戏开发：Bevy 的简单性和文档使其适合学习游戏开发 常见问题问题 1：Bevy 适合初学者吗？ 解决方案：是的，Bevy 的设计目标之一是简单易用，新手容易上手。Bevy 的 API 简洁，文档完善，适合初学者学习游戏开发。 问题 2：Bevy 的性能如何？ 解决方案：Bevy 的性能很好。Bevy 使用数据导向的架构和 ECS 模式，支持大规模并行执行，性能接近 C++ 游戏引擎。 问题 3：Bevy 的稳定性如何？ 解决方案：Bevy 仍在积极开发中，API 可能会发生变化。Bevy 大约每 3 个月发布一个新版本，可能包含破坏性更改。Bevy 提供迁移指南，但不能保证迁移总是容易的。 问题 4：Bevy 支持哪些平台？ 解决方案：Bevy 支持多个平台，包括 Windows、macOS、Linux、Android、iOS 和 Web（WebAssembly）。 性能考虑 编译时间：Bevy 的编译时间可能较长，特别是首次编译。可以通过禁用不需要的 features 来减少编译时间。 运行时性能：Bevy 的运行时性能很好，使用数据导向的架构和 ECS 模式，支持大规模并行执行。 内存使用：Bevy 的内存使用合理，使用 Rust 的所有权系统管理内存，无需垃圾回收。 相关资源相关源代码文件： bevy/README.md - Bevy 主 README bevy/src/lib.rs - Bevy 主库文件 bevy/crates/bevy_ecs/README.md - Bevy ECS README bevy/docs/cargo_features.md - Bevy Cargo Features 文档 官方文档链接： Bevy 官方网站 Bevy 快速入门指南 Bevy 官方文档 Bevy 官方示例 进一步学习建议： 学习快速入门，创建第一个 Bevy 应用 学习 ECS 基础，理解 Bevy 的核心编程范式 学习游戏引擎基础，理解游戏引擎的基本工作原理 索引：返回上级目录"},{"title":"Foundation（基础）","path":"/Luo-Haomin/wiki/BevyBook/Foundation/README.html","content":"Foundation（基础）本部分介绍 Bevy 的基础知识，适合完全新手。 内容列表1. 快速入门 Bevy 安装与配置 创建第一个 Bevy 项目 基本项目结构 Hello World 示例 学习目标：能够创建并运行一个基本的 Bevy 项目 2. Bevy 与 Rust 框架 Bevy 是什么 Bevy 的特点和优势 Rust 基础回顾 Bevy 与 Rust 的关系 为什么选择 Bevy 学习目标：理解 Bevy 的定位和 Rust 在 Bevy 中的作用 3. 游戏引擎基础 游戏引擎核心概念 游戏循环（Game Loop） 场景图（Scene Graph） 渲染管线（Render Pipeline） 物理引擎基础 资源管理基础 学习目标：理解游戏引擎的基本工作原理 学习建议 按顺序学习：建议按照上述顺序依次学习 动手实践：每学完一个概念，尝试编写代码 理解概念：不要急于求成，确保理解每个概念 查阅文档：遇到问题及时查阅官方文档 下一步完成本部分学习后，建议继续学习： ECS（实体组件系统） - Bevy 的核心编程范式 索引：返回主目录"},{"title":"Examples（示例项目）","path":"/Luo-Haomin/wiki/BevyBook/Examples/README.html","content":"Examples（示例项目）本部分包含完整的 Bevy 项目示例，展示如何将所学知识应用到实际项目中。 示例列表基础示例 Hello World - 最简单的 Bevy 程序 ECS 示例 - ECS 基础用法示例 输入处理示例 - 键盘、鼠标、手柄输入 2D 游戏示例 2D 平台游戏 - 完整的 2D 平台游戏实现 2D 射击游戏 - 2D 射击游戏示例 2D 益智游戏 - 2D 益智游戏示例 3D 游戏示例 3D 场景漫游 - 3D 场景和相机控制 3D 物理示例 - 3D 物理系统示例 3D 游戏示例 - 完整的 3D 游戏实现 综合示例 完整游戏项目 - 包含所有功能的完整游戏 多人游戏示例 - 网络多人游戏实现 插件示例 - 自定义插件示例 如何使用 查看示例：浏览示例代码了解实现方式 运行示例：运行示例查看效果 修改示例：尝试修改示例代码 学习实践：参考示例实现自己的项目 贡献示例欢迎提交你的示例项目！ 索引：返回主目录"},{"title":"快速入门","path":"/Luo-Haomin/wiki/BevyBook/Foundation/快速入门.html","content":"快速入门概述学习目标： 创建第一个 Bevy 应用 理解 Bevy 应用的基本结构 学会定义和注册系统 理解 Bevy 应用的生命周期 前置知识要求： Rust 基础语法 基本的 Rust 项目结构 Cargo 包管理器使用 核心概念Bevy 应用是什么？Bevy 应用是使用 Bevy 游戏引擎创建的程序。每个 Bevy 应用都基于 ECS（Entity Component System）模式构建。 为什么使用 Bevy？ 数据导向：功能由数据驱动，而非继承层次 高性能：大规模并行执行，缓存友好 易用性：简洁的 API，易于学习和使用 模块化：插件化架构，易于扩展 Bevy 应用的基本结构Bevy 应用由以下部分组成： App：应用主入口，管理应用生命周期 System：系统函数，处理游戏逻辑 Schedule：系统调度，控制系统的执行顺序 Plugin：插件，封装相关功能 基础用法创建最简单的 Bevy 应用创建一个输出 “hello world” 的最简单 Bevy 应用。 源代码文件：bevy/examples/hello_world.rs 代码示例： use bevy::prelude::*;fn main() App::new().add_systems(Update, hello_world_system).run();fn hello_world_system() println!(hello world); 关键要点： 使用 App::new() 创建应用 使用 add_systems() 注册系统 Update 是系统调度，表示系统在每次更新时运行 使用 run() 启动应用 系统是普通 Rust 函数 说明：这是最简单的 Bevy 应用。App::new() 创建了一个新的应用实例，add_systems(Update, hello_world_system) 将系统注册到 Update 调度中，run() 启动应用并进入主循环。系统 hello_world_system 在每次应用更新时运行，输出 “hello world”。 配置 Bevy 项目在开始编写 Bevy 应用之前，需要配置项目依赖。 配置步骤： 在 Cargo.toml 中添加 Bevy 依赖 [dependencies]bevy = 0.15 # 确保这是最新版本 或者使用 Cargo 命令添加 cargo add bevy 关键要点： 确保使用最新版本的 Bevy Bevy 版本可能会影响 API 使用方式 建议使用 cargo add 命令自动管理依赖 说明：Bevy 是一个快速发展的项目，API 可能会发生变化。使用最新版本可以确保获得最新的功能和修复。 应用生命周期Bevy 应用有不同的调度阶段，控制系统的执行顺序。 源代码文件：bevy/examples/hello_world.rs 代码示例： fn main() App::new() .add_systems(Startup, startup_system) // 启动系统，运行一次 .add_systems(Update, update_system) // 更新系统，每次更新运行 .run();fn startup_system() println!(应用启动); fn update_system() println!(应用更新); 关键要点： Startup：启动系统，在应用启动时运行一次 Update：更新系统，在每次应用更新时运行 系统按调度顺序执行 启动系统在更新系统之前执行 说明：启动系统用于初始化应用状态，如创建初始实体、加载资源等。更新系统用于处理游戏逻辑，如处理输入、更新游戏状态等。 进阶用法系统执行顺序可以通过 .before() 和 .after() 方法控制系统的执行顺序。 代码示例： fn main() App::new() .add_systems(Update, ( system_a, system_b.after(system_a), // system_b 在 system_a 之后运行 system_c.before(system_b), // system_c 在 system_b 之前运行 )) .run(); 注意事项： 系统执行顺序影响游戏逻辑 确保依赖关系正确 避免循环依赖 最佳实践： 使用 .before() 和 .after() 明确指定顺序 将相关系统组织在一起 避免不必要的顺序依赖 使用插件插件是封装相关功能的模块，可以简化应用配置。 代码示例： fn main() App::new() .add_plugins(DefaultPlugins) // 添加默认插件 .add_systems(Update, hello_world_system) .run(); 注意事项： DefaultPlugins 包含窗口、输入、渲染等基本功能 可以根据需要选择插件 插件可以自定义配置 最佳实践： 使用 DefaultPlugins 快速开始 根据需要添加或移除插件 创建自定义插件封装功能 实际应用在游戏开发中的应用场景快速入门是学习 Bevy 的第一步，为后续学习打下基础： 项目初始化：创建新的 Bevy 项目 系统注册：注册游戏逻辑系统 应用配置：配置应用的基本设置 常见问题问题 1：如何运行 Bevy 应用？ 解决方案：使用 cargo run 命令运行应用。确保在项目根目录下执行。 问题 2：系统什么时候运行？ 解决方案：系统在注册的调度阶段运行。Startup 系统运行一次，Update 系统每次更新运行。 问题 3：如何调试 Bevy 应用？ 解决方案：使用 println! 输出调试信息，或使用 Bevy 的诊断工具。 性能考虑 系统优化：尽量减少系统的执行时间 并行执行：系统可以并行执行，提高性能 资源管理：合理管理资源，避免内存泄漏 相关资源相关源代码文件： bevy/examples/hello_world.rs - Hello World 示例 bevy/examples/app/empty.rs - 空应用示例 bevy/examples/app/empty_defaults.rs - 带默认插件的空应用示例 官方文档链接： Bevy 快速入门指南 Bevy 官方文档 Bevy 官方示例 进一步学习建议： 学习 ECS 基础，理解 Bevy 的核心编程范式 学习资源管理，了解如何加载和管理资源 学习输入处理，了解如何处理用户输入 索引：返回上级目录"},{"title":"游戏引擎基础","path":"/Luo-Haomin/wiki/BevyBook/Foundation/游戏引擎基础.html","content":"游戏引擎基础概述学习目标： 理解游戏引擎的核心概念 了解游戏循环的工作原理 理解渲染管线的基本概念 了解资源管理的基础知识 理解相机系统的作用 前置知识要求： 快速入门 Bevy 与 Rust 框架 Rust 基础语法 核心概念什么是游戏引擎？游戏引擎是一个软件框架，用于开发游戏。它提供了游戏开发所需的核心功能，如渲染、物理、音频、输入处理等。 为什么使用游戏引擎？ 提高效率：游戏引擎提供了游戏开发所需的核心功能，减少重复工作 跨平台支持：游戏引擎通常支持多个平台，简化跨平台开发 性能优化：游戏引擎经过优化，提供高性能的游戏运行环境 工具支持：游戏引擎通常提供丰富的工具和编辑器 游戏引擎的核心组件游戏引擎通常包含以下核心组件： 游戏循环（Game Loop）：控制游戏的更新和渲染 渲染管线（Render Pipeline）：处理图形渲染 物理引擎（Physics Engine）：处理物理模拟 资源管理（Asset Management）：管理游戏资源 输入处理（Input Handling）：处理用户输入 音频系统（Audio System）：处理音频播放 基础用法游戏循环游戏循环是游戏引擎的核心，控制游戏的更新和渲染。 源代码文件：bevy/examples/app/custom_loop.rs 代码示例： use bevy::app::AppExit, prelude::*;use std::io;#[derive(Resource)]struct Input(String);fn my_runner(mut app: App) - AppExit // 完成插件构建，包括运行任何必要的清理 // 这通常由默认运行器完成 app.finish(); app.cleanup(); println!(在控制台中输入内容); for line in io::stdin().lines() let mut input = app.world_mut().resource_mut::Input(); input.0 = line.unwrap(); app.update(); if let Some(exit) = app.should_exit() return exit; AppExit::Successfn print_system(input: ResInput) println!(你输入了: , input.0);fn exit_system(input: ResInput, mut app_exit_reader: MessageWriterAppExit) if input.0 == exit app_exit_reader.write(AppExit::Success); fn main() - AppExit App::new() .insert_resource(Input(String::new())) .set_runner(my_runner) .add_systems(Update, (print_system, exit_system)) .run() 关键要点： 游戏循环控制游戏的更新和渲染 Bevy 使用 app.update() 来更新应用 可以自定义运行器来控制游戏循环 游戏循环通常包括输入处理、更新逻辑、渲染等步骤 说明：游戏循环是游戏引擎的核心。它控制游戏的更新和渲染，确保游戏以稳定的帧率运行。Bevy 使用 ECS 模式，通过系统来处理游戏逻辑。 相机系统相机系统负责配置要绘制什么、如何绘制以及在哪里绘制。必须至少有一个相机实体，才能显示任何内容！ 源代码文件：bevy/examples/camera/2d_on_ui.rs 代码示例： use bevy::camera::visibility::RenderLayers, color::palettes::tailwind, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, rotate_sprite) .run();fn setup(mut commands: Commands, asset_server: ResAssetServer) // 默认相机。`IsDefaultUiCamera` 使这成为渲染 UI 元素的默认相机 commands.spawn((Camera2d, IsDefaultUiCamera)); // 第二个相机。更高的 order 意味着这个相机将在第一个相机之后渲染 // 我们将渲染到这个相机以在 UI 上绘制 commands.spawn(( Camera2d, Camera order: 1, // 不在背景中绘制任何内容，以查看前一个相机 clear_color: ClearColorConfig::None, ..default() , // 此相机将只渲染在同一渲染层上的实体 RenderLayers::layer(1), )); 关键要点： 相机负责配置要绘制什么、如何绘制以及在哪里绘制 必须至少有一个相机实体，才能显示任何内容 可以使用多个相机来渲染不同的内容 相机的 order 属性控制渲染顺序 说明：相机是游戏引擎中非常重要的组件。它决定了玩家看到的内容。Bevy 支持 2D 和 3D 相机，可以配置相机的属性，如视野、投影类型等。 资源管理资源管理是游戏引擎的重要组成部分，负责加载和管理游戏资源。 源代码文件：bevy/examples/asset/asset_loading.rs 代码示例： use bevy::asset::LoadedFolder, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();fn setup( mut commands: Commands, asset_server: ResAssetServer, meshes: ResAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) // 默认情况下，AssetServer 将从 assets 文件夹内加载资源 // 例如，下一行将加载 ROOT/assets/models/cube/cube.gltf // 其中 ROOT 是应用程序的目录 // // 这可以通过设置 [`AssetPlugin.file_path`] 来覆盖 let cube_handle = asset_server.load( GltfAssetLabel::Primitive mesh: 0, primitive: 0, .from_asset(models/cube/cube.gltf), ); let sphere_handle = asset_server.load( GltfAssetLabel::Primitive mesh: 0, primitive: 0, .from_asset(models/sphere/sphere.gltf), ); // 所有资源在加载完成后都会进入它们的 AssetsT 集合 if let Some(sphere) = meshes.get(sphere_handle) // 你可能会注意到这不会运行！这是因为资源在并行加载时不会阻塞 // 当资源加载完成时，它将出现在相关的 AssetsT 集合中 info!(:?, sphere.primitive_topology()); else info!(sphere 尚未加载); // 你可以像这样加载文件夹中的所有资源。它们将在不阻塞的情况下并行加载 // LoadedFolder 资源保存文件夹中每个资源的句柄 // 这些都是 LoadedFolder 资源的依赖项，这意味着如果你想要等待文件夹中的所有资源加载 // 可以等待 LoadedFolder 资源触发 AssetEvent::LoadedWithDependencies // 如果你想保持文件夹中的资源存活，请确保存储返回的句柄 关键要点： 资源管理负责加载和管理游戏资源 Bevy 使用 AssetServer 来加载资源 资源在并行加载时不会阻塞 可以使用 AssetsT 集合来访问已加载的资源 说明：资源管理是游戏引擎的重要组成部分。游戏需要加载各种资源，如模型、纹理、音频等。Bevy 的资源管理系统支持异步加载，不会阻塞游戏运行。 进阶用法渲染管线渲染管线是游戏引擎的核心，负责处理图形渲染。 源代码文件：bevy/examples/shader/compute_shader_game_of_life.rs 关键信息： 渲染管线负责处理图形渲染 Bevy 使用现代图形 API（如 WebGPU）进行渲染 渲染管线包括多个阶段，如顶点着色、片段着色等 可以使用自定义着色器来自定义渲染效果 说明：渲染管线是游戏引擎的核心。它负责将游戏世界转换为屏幕上的图像。Bevy 使用现代图形 API，支持高性能渲染。 物理引擎基础物理引擎负责处理物理模拟，如碰撞检测、重力等。 源代码文件：bevy/examples/movement/physics_in_fixed_timestep.rs 关键信息： 物理引擎负责处理物理模拟 Bevy 支持固定时间步长物理模拟 物理模拟通常在固定时间步长中运行 可以使用物理引擎来处理碰撞检测、重力等 说明：物理引擎是游戏引擎的重要组成部分。它负责处理物理模拟，使游戏世界更加真实。Bevy 支持固定时间步长物理模拟，确保物理模拟的稳定性。 实际应用在游戏开发中的应用场景游戏引擎基础是游戏开发的基础，为后续学习打下基础： 游戏循环：控制游戏的更新和渲染 相机系统：配置游戏视角 资源管理：加载和管理游戏资源 渲染管线：处理图形渲染 物理引擎：处理物理模拟 常见问题问题 1：游戏循环是如何工作的？ 解决方案：游戏循环是游戏引擎的核心。它控制游戏的更新和渲染，确保游戏以稳定的帧率运行。Bevy 使用 ECS 模式，通过系统来处理游戏逻辑。 问题 2：为什么需要相机？ 解决方案：相机负责配置要绘制什么、如何绘制以及在哪里绘制。必须至少有一个相机实体，才能显示任何内容。相机决定了玩家看到的内容。 问题 3：资源管理是如何工作的？ 解决方案：资源管理负责加载和管理游戏资源。Bevy 使用 AssetServer 来加载资源。资源在并行加载时不会阻塞，可以使用 AssetsT 集合来访问已加载的资源。 性能考虑 游戏循环优化：尽量减少游戏循环的执行时间 渲染优化：合理使用渲染管线，减少渲染开销 资源管理优化：合理管理资源，避免内存泄漏 相关资源相关源代码文件： bevy/examples/app/custom_loop.rs - 自定义游戏循环示例 bevy/examples/camera/2d_on_ui.rs - 2D 相机示例 bevy/examples/asset/asset_loading.rs - 资源加载示例 bevy/examples/shader/compute_shader_game_of_life.rs - 渲染管线示例 bevy/examples/movement/physics_in_fixed_timestep.rs - 物理引擎示例 官方文档链接： Bevy 官方文档 Bevy 官方示例 进一步学习建议： 学习 ECS 基础，理解 Bevy 的核心编程范式 学习资源管理，了解如何加载和管理资源 学习输入处理，了解如何处理用户输入 索引：返回上级目录"},{"title":"拾取系统（Picking）","path":"/Luo-Haomin/wiki/BevyBook/Input/拾取系统（Picking）.html","content":"拾取系统（Picking）概述学习目标： 理解 Bevy 拾取系统的基本概念 掌握网格拾取的使用 了解精灵拾取的使用 学会使用拾取事件 前置知识要求： Bevy 快速入门 ECS 基础 输入处理基础 3D 开发基础（用于网格拾取） 核心概念什么是拾取系统？拾取系统是 Bevy 中用于检测鼠标或触摸输入是否与实体交互的功能。拾取系统可以用于实现点击、悬停、拖拽等交互功能。 为什么需要拾取系统？ 交互检测：拾取系统可以检测鼠标或触摸输入是否与实体交互 点击事件：拾取系统可以触发点击事件 悬停效果：拾取系统可以实现悬停效果 拖拽功能：拾取系统可以实现拖拽功能 拾取系统的核心组件Bevy 拾取系统包含以下核心组件： Pickable：可拾取组件，标记实体为可拾取 MeshPickingPlugin：网格拾取插件，用于 3D 网格拾取 Pointer：指针事件，用于处理鼠标和触摸输入 PointerInteraction：指针交互，用于处理交互状态 基础用法简单拾取使用拾取系统实现简单的点击和拖拽功能。 源代码文件：bevy/examples/picking/simple_picking.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins((DefaultPlugins, MeshPickingPlugin)) .add_systems(Startup, setup_scene) .run();fn setup_scene( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) commands .spawn(( Text::new(Click Me to get a box Drag cubes to rotate), Node position_type: PositionType::Absolute, top: percent(12), left: percent(12), ..default() , )) .observe(on_click_spawn_cube) .observe(|out: OnPointerOut, mut texts: Querymut TextColor| let mut text_color = texts.get_mut(out.entity).unwrap(); text_color.0 = Color::WHITE; ) .observe( |over: OnPointerOver, mut texts: Querymut TextColor| let mut color = texts.get_mut(over.entity).unwrap(); color.0 = bevy::color::palettes::tailwind::CYAN_400.into(); , ); // 基础 commands.spawn(( Mesh3d(meshes.add(Circle::new(4.0))), MeshMaterial3d(materials.add(Color::WHITE)), Transform::from_rotation(Quat::from_rotation_x(-std::f32::consts::FRAC_PI_2)), )); // 光源 commands.spawn(( PointLight shadows_enabled: true, ..default() , Transform::from_xyz(4.0, 8.0, 4.0), )); // 相机 commands.spawn(( Camera3d::default(), Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y), ));fn on_click_spawn_cube( _click: OnPointerClick, mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial, mut num: Localusize,) commands .spawn(( Mesh3d(meshes.add(Cuboid::new(0.5, 0.5, 0.5))), MeshMaterial3d(materials.add(Color::srgb_u8(124, 144, 255))), Transform::from_xyz(0.0, 0.25 + 0.55 * *num as f32, 0.0), )) // 添加 MeshPickingPlugin 后，您可以向网格添加指针事件观察者： .observe(on_drag_rotate); *num += 1;fn on_drag_rotate(drag: OnPointerDrag, mut transforms: Querymut Transform) if let Ok(mut transform) = transforms.get_mut(drag.entity) transform.rotate_y(drag.delta.x * 0.02); transform.rotate_x(drag.delta.y * 0.02); 关键要点： 使用 MeshPickingPlugin 启用网格拾取 使用 observe() 注册指针事件观察者 使用 OnPointerClick 处理点击事件 使用 OnPointerDrag 处理拖拽事件 使用 OnPointerOver 处理悬停事件 使用 OnPointerOut 处理离开事件 说明：简单拾取是拾取系统的基础。通过使用简单拾取，可以实现点击和拖拽功能。 网格拾取使用网格拾取实现 3D 网格的交互。 源代码文件：bevy/examples/picking/mesh_picking.rs 代码示例： use bevy::color::palettes::tailwind::*, picking::pointer::PointerInteraction, prelude::*;fn main() App::new() // MeshPickingPlugin 不是默认插件 .add_plugins((DefaultPlugins, MeshPickingPlugin)) .add_systems(Startup, setup_scene) .add_systems(Update, (draw_mesh_intersections, rotate)) .run();/// 一个标记组件，用于我们的形状，以便我们可以将它们与地平面分开查询。#[derive(Component)]struct Shape;fn setup_scene( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) // 设置材质。 let white_matl = materials.add(Color::WHITE); let ground_matl = materials.add(Color::from(GRAY_300)); let hover_matl = materials.add(Color::from(CYAN_300)); let pressed_matl = materials.add(Color::from(YELLOW_300)); let shapes = [ meshes.add(Cuboid::default()), meshes.add(Tetrahedron::default()), meshes.add(Capsule3d::default()), meshes.add(Torus::default()), meshes.add(Cylinder::default()), meshes.add(Cone::default()), meshes.add(ConicalFrustum::default()), meshes.add(Sphere::default().mesh().ico(5).unwrap()), meshes.add(Sphere::default().mesh().uv(32, 18)), ]; // 生成形状。默认情况下，网格是可拾取的。 for (i, shape) in shapes.into_iter().enumerate() commands .spawn(( Mesh3d(shape), MeshMaterial3d(white_matl.clone()), Transform::from_xyz( -SHAPES_X_EXTENT / 2. + i as f32 / (num_shapes - 1) as f32 * SHAPES_X_EXTENT, 2.0, Z_EXTENT / 2., ) .with_rotation(Quat::from_rotation_x(-PI / 4.)), Shape, )) .observe(update_material_on::PointerOver(hover_matl.clone())) .observe(update_material_on::PointerOut(white_matl.clone())) .observe(update_material_on::PointerPress(pressed_matl.clone())) .observe(update_material_on::PointerRelease(hover_matl.clone())) .observe(rotate_on_drag); 关键要点： 使用 MeshPickingPlugin 启用网格拾取 使用 observe() 注册指针事件观察者 使用 OnPointerOver 处理悬停事件 使用 OnPointerPress 处理按下事件 使用 OnPointerRelease 处理释放事件 说明：网格拾取是拾取系统的重要功能。通过使用网格拾取，可以实现 3D 网格的交互，如悬停效果和点击事件。 精灵拾取使用精灵拾取实现 2D 精灵的交互。 源代码文件：bevy/examples/picking/sprite_picking.rs 代码示例： use bevy::prelude::*, sprite::Anchor;fn main() App::new() .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest())) .add_systems(Startup, (setup, setup_atlas)) .add_systems(Update, (move_sprite, animate_sprite)) .run();fn setup(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Camera2d); let len = 128.0; let sprite_size = Vec2::splat(len / 2.0); commands .spawn((Transform::default(), Visibility::default())) .with_children(|commands| for (anchor_index, anchor) in [ Anchor::TOP_LEFT, Anchor::TOP_CENTER, Anchor::TOP_RIGHT, Anchor::CENTER_LEFT, Anchor::CENTER, Anchor::CENTER_RIGHT, Anchor::BOTTOM_LEFT, Anchor::BOTTOM_CENTER, Anchor::BOTTOM_RIGHT, ] .iter() .enumerate() let i = (anchor_index % 3) as f32; let j = (anchor_index / 3) as f32; // 在精灵后面生成黑色方块以显示锚点 commands .spawn(( Sprite::from_color(Color::BLACK, sprite_size), Transform::from_xyz(i * len - len, j * len - len, -1.0), Pickable::default(), )) .observe(recolor_on::PointerOver(Color::srgb(0.0, 1.0, 1.0))) .observe(recolor_on::PointerOut(Color::BLACK)) .observe(recolor_on::PointerPress(Color::srgb(1.0, 1.0, 0.0))) .observe(recolor_on::PointerRelease(Color::srgb(0.0, 1.0, 1.0))); commands .spawn(( Sprite image: asset_server.load(branding/bevy_bird_dark.png), custom_size: Some(sprite_size), color: Color::srgb(1.0, 0.0, 0.0), ..default() , anchor.to_owned(), // 通过更改变换创建 3x3 锚点示例网格 Transform::from_xyz(i * len - len, j * len - len, 0.0) .with_scale(Vec3::splat(1.0 + (i - 1.0) * 0.2)) .with_rotation(Quat::from_rotation_z((j - 1.0) * 0.2)), Pickable::default(), )) .observe(recolor_on::PointerOver(Color::srgb(0.0, 1.0, 0.0))) .observe(recolor_on::PointerOut(Color::srgb(1.0, 0.0, 0.0))) .observe(recolor_on::PointerPress(Color::srgb(0.0, 0.0, 1.0))) .observe(recolor_on::PointerRelease(Color::srgb(0.0, 1.0, 0.0))); ); 关键要点： 使用 Pickable 组件标记实体为可拾取 使用 observe() 注册指针事件观察者 使用 OnPointerOver 处理悬停事件 使用 OnPointerPress 处理按下事件 使用 OnPointerRelease 处理释放事件 说明：精灵拾取是拾取系统的重要功能。通过使用精灵拾取，可以实现 2D 精灵的交互，如悬停效果和点击事件。 进阶用法拾取事件使用拾取事件处理复杂的交互。 关键信息： 使用 OnPointerClick 处理点击事件 使用 OnPointerDrag 处理拖拽事件 使用 OnPointerOver 处理悬停事件 使用 OnPointerOut 处理离开事件 使用 OnPointerPress 处理按下事件 使用 OnPointerRelease 处理释放事件 说明：拾取事件是拾取系统的重要功能。通过使用拾取事件，可以实现复杂的交互，如点击、拖拽、悬停等。 拾取调试使用拾取调试工具调试拾取问题。 源代码文件：bevy/examples/picking/debug_picking.rs 关键信息： 使用 DebugPickingPlugin 启用拾取调试 使用 DebugPickingMode 控制调试模式 使用 DebugPickingBackend 控制调试后端 说明：拾取调试是拾取系统的重要功能。通过使用拾取调试，可以调试拾取问题，了解拾取系统的行为。 实际应用在游戏开发中的应用场景拾取系统在游戏开发中有广泛的应用： 点击交互：实现点击实体触发事件 悬停效果：实现鼠标悬停时的视觉效果 拖拽功能：实现拖拽实体移动 选择功能：实现选择实体的功能 UI 交互：实现 UI 元素的交互 常见问题问题 1：如何启用拾取系统？ 解决方案： 使用 MeshPickingPlugin 启用网格拾取 使用 Pickable 组件标记实体为可拾取 使用 observe() 注册指针事件观察者 问题 2：如何处理拾取事件？ 解决方案： 使用 OnPointerClick 处理点击事件 使用 OnPointerDrag 处理拖拽事件 使用 OnPointerOver 处理悬停事件 使用 OnPointerOut 处理离开事件 问题 3：如何实现悬停效果？ 解决方案： 使用 OnPointerOver 处理悬停事件 使用 OnPointerOut 处理离开事件 在事件处理中更新实体的材质或颜色 性能考虑 拾取插件：拾取插件是高效的，可以频繁使用 拾取事件：拾取事件处理是高效的，可以大量使用 拾取调试：拾取调试应仅在开发时使用，避免影响性能 相关资源相关源代码文件： bevy/examples/picking/simple_picking.rs - 简单拾取示例 bevy/examples/picking/mesh_picking.rs - 网格拾取示例 bevy/examples/picking/sprite_picking.rs - 精灵拾取示例 bevy/examples/picking/debug_picking.rs - 拾取调试示例 官方文档链接： Bevy 拾取系统 Bevy 拾取示例 进一步学习建议： 学习输入处理，了解输入系统 学习 3D 开发，了解 3D 渲染基础 学习 UI 系统，了解 UI 交互 索引：返回上级目录"},{"title":"输入处理","path":"/Luo-Haomin/wiki/BevyBook/Input/输入处理.html","content":"输入处理input基础 本教程基于Bevy官方示例，提供了完整的输入系统开发指南。 教程结构基础教程 (Bevy_Input_基础教程.md) 键盘输入: 基础按键、事件监听、修饰键、字符输入 鼠标输入: 按钮、移动、滚轮、事件监听、光标控制 触摸输入: 基础触摸、事件监听、多点触摸 游戏手柄输入: 基础手柄、事件监听、连接管理 文本输入: IME支持、多语言输入、特殊键处理 高级教程 (Bevy_Input_高级教程.md) 游戏手柄震动: 力反馈、自定义震动模式 输入映射和绑定: 动态绑定、配置管理 输入事件处理: 优先级、过滤、转换 输入状态管理: 状态机、上下文管理 自定义输入系统: 扩展输入类型、模拟回放 输入优化: 缓存、批处理、预测插值 核心概念速查基础输入资源// 键盘输入ResButtonInputKeyCode// 鼠标输入ResButtonInputMouseButtonResAccumulatedMouseMotionResAccumulatedMouseScroll// 触摸输入ResTouches// 游戏手柄Query(Entity, Gamepad) 输入事件// 键盘事件EventReaderKeyboardInput// 鼠标事件EventReaderMouseButtonInputEventReaderMouseMotionEventReaderCursorMovedEventReaderMouseWheel// 触摸事件EventReaderTouchInput// 游戏手柄事件EventReaderGamepadConnectionEventEventReaderGamepadAxisChangedEventEventReaderGamepadButtonChangedEvent 输入状态检查// 按键状态keyboard_input.pressed(KeyCode::KeyA) // 正在按下keyboard_input.just_pressed(KeyCode::KeyA) // 刚刚按下keyboard_input.just_released(KeyCode::KeyA) // 刚刚释放// 组合键检查input.any_pressed([KeyCode::ShiftLeft, KeyCode::ShiftRight]) 常用模式1. 基础输入处理fn input_system(keyboard_input: ResButtonInputKeyCode) if keyboard_input.pressed(KeyCode::KeyW) // 处理持续输入 if keyboard_input.just_pressed(KeyCode::Space) // 处理单次输入 2. 组合键处理fn combo_input_system(input: ResButtonInputKeyCode) let ctrl = input.any_pressed([KeyCode::ControlLeft, KeyCode::ControlRight]); let shift = input.any_pressed([KeyCode::ShiftLeft, KeyCode::ShiftRight]); if ctrl shift input.just_pressed(KeyCode::KeyS) // 处理 Ctrl+Shift+S 3. 游戏手柄输入fn gamepad_system(gamepads: Query(Entity, Gamepad)) for (entity, gamepad) in gamepads if gamepad.just_pressed(GamepadButton::South) // 处理按钮按下 let left_stick_x = gamepad.get(GamepadAxis::LeftStickX).unwrap(); if left_stick_x.abs() 0.01 // 处理摇杆输入 4. 触摸输入fn touch_system(touches: ResTouches) for touch in touches.iter_just_pressed() info!(触摸按下 - ID: , 位置: , touch.id(), touch.position()); for touch in touches.iter() if touches.pressed(touch.id()) // 处理持续触摸 5. 输入事件监听fn event_system(mut events: EventReaderKeyboardInput) for event in events.read() match event.logical_key Key::Character(c) = // 处理字符输入 Key::Enter = // 处理回车键 _ = 高级功能1. 游戏手柄震动fn rumble_system( gamepads: Query(Entity, Gamepad), mut rumble_requests: EventWriterGamepadRumbleRequest,) for (entity, gamepad) in gamepads if gamepad.just_pressed(GamepadButton::North) rumble_requests.send(GamepadRumbleRequest::Add gamepad: entity, intensity: GamepadRumbleIntensity::strong_motor(0.5), duration: Duration::from_secs(2), ); 2. 输入映射系统#[derive(Resource)]struct InputMapping keyboard_bindings: HashMapInputAction, VecKeyCode, mouse_bindings: HashMapInputAction, VecMouseButton, gamepad_bindings: HashMapInputAction, VecGamepadButton,fn input_processing_system( keyboard_input: ResButtonInputKeyCode, input_mapping: ResInputMapping,) for (action, keys) in input_mapping.keyboard_bindings let is_pressed = keys.iter().any(|key| keyboard_input.pressed(*key)); // 处理映射的输入 3. 输入状态机#[derive(States)]enum InputState Normal, Menu, Combat,fn input_state_system( mut input_context: ResMutInputContext, keyboard_input: ResButtonInputKeyCode,) match input_context.current_state InputState::Normal = if keyboard_input.just_pressed(KeyCode::Escape) input_context.current_state = InputState::Menu; InputState::Menu = if keyboard_input.just_pressed(KeyCode::Escape) input_context.current_state = InputState::Normal; _ = 性能优化技巧1. 输入缓存#[derive(Resource)]struct InputCache keyboard_cache: HashMapKeyCode, bool, last_update: f32, cache_duration: f32,fn optimized_input_system( mut input_cache: ResMutInputCache, keyboard_input: ResButtonInputKeyCode, time: ResTime,) let current_time = time.elapsed_secs(); if input_cache.needs_update(current_time) input_cache.update_cache(keyboard_input, current_time); // 使用缓存的数据 if input_cache.is_key_pressed(KeyCode::KeyW) // 处理输入 2. 输入批处理fn batched_input_system( mut input_events: EventReaderInputEvent, mut batched_actions: EventWriterBatchedAction,) let mut actions = Vec::new(); for event in input_events.read() actions.push(event.action.clone()); if !actions.is_empty() batched_actions.send(BatchedAction actions ); 3. 事件优先级fn priority_input_system( mut high_priority: EventReaderHighPriorityEvent, mut normal_priority: EventReaderNormalPriorityEvent,) // 先处理高优先级事件 for event in high_priority.read() // 处理紧急输入 // 再处理正常优先级事件 for event in normal_priority.read() // 处理常规输入 常见问题解决1. 输入延迟// 使用缓存减少重复检查let cached_state = input_cache.get_key_state(key);// 使用批处理减少事件处理开销let batched_events = collect_events();process_batch(batched_events); 2. 输入冲突// 使用状态机管理输入上下文match current_input_state InputState::Gameplay = // 处理游戏输入 InputState::UI = // 处理UI输入 3. 多设备支持// 统一输入映射fn unified_input_system( keyboard_input: ResButtonInputKeyCode, gamepads: QueryGamepad, input_mapping: ResInputMapping,) // 检查键盘输入 if keyboard_input.pressed(input_mapping.get_key(InputAction::MoveForward)) // 处理移动 // 检查游戏手柄输入 for gamepad in gamepads if gamepad.pressed(input_mapping.get_gamepad_button(InputAction::MoveForward)) // 处理移动 4. 输入验证// 输入过滤器fn input_filter_system( keyboard_input: ResButtonInputKeyCode, input_filter: ResInputFilter, mut filtered_events: EventWriterFilteredInputEvent,) for key_code in KeyCode::iter() if keyboard_input.just_pressed(key_code) if !input_filter.is_disabled(key_code) filtered_events.send(FilteredInputEvent key: key_code ); 最佳实践1. 输入系统设计 使用状态机管理不同的输入上下文 实现输入映射系统支持自定义绑定 使用事件系统处理输入，避免直接修改游戏状态 实现输入缓冲和预测提高响应性 2. 性能优化 缓存输入状态减少重复检查 使用批处理减少事件处理开销 实现输入预测和插值 优化输入事件的分发和处理 3. 用户体验 支持多种输入设备 提供输入配置选项 实现输入反馈（震动、音效等） 处理输入冲突和优先级 4. 错误处理 验证输入数据的有效性 处理设备连接和断开 提供合理的默认输入配置 记录输入错误便于调试 扩展资源官方文档 Bevy Input Book Bevy Input Examples Bevy Input API Reference 社区资源 Bevy Discord Bevy GitHub Bevy Assets 学习路径建议 初学者: 从基础教程开始，掌握各种输入设备的基本使用 进阶用户: 学习高级教程，了解输入映射、状态管理等 高级用户: 探索自定义输入系统、性能优化、输入预测等 结语Bevy的输入系统提供了强大而灵活的输入处理能力，从基础的键盘鼠标输入到高级的游戏手柄震动和自定义输入类型。通过本教程的学习，您应该能够： 处理各种输入设备的输入 实现复杂的输入映射和绑定 管理输入状态和上下文 优化输入系统的性能 创建自定义输入类型 实现输入预测和插值 建议在实际项目中逐步应用这些知识，并根据具体需求选择合适的特性组合。Bevy的ECS架构和模块化设计使得输入系统易于扩展和维护，是开发高质量交互体验的优秀选择。"},{"title":"3D开发","path":"/Luo-Haomin/wiki/BevyBook/3D_Graphics/3D开发.html","content":"3D开发概述学习目标： 理解 Bevy 3D 渲染的基本概念 掌握如何创建简单的 3D 场景 学会使用 PBR 材质和光照系统 了解如何加载 GLTF 模型 掌握后处理效果的使用 理解透明度和多相机渲染 前置知识要求： Bevy 快速入门 ECS 基础 资源管理基础 2D 基础（可选） 核心概念什么是 3D 渲染？3D 渲染是在三维空间中显示模型和场景。Bevy 提供了强大的 3D 渲染系统，支持 PBR 材质、多种光照类型、阴影、后处理等功能。 为什么需要 3D 渲染？ 游戏开发：大多数 3D 游戏需要 3D 渲染 视觉效果：3D 渲染可以提供更真实的视觉效果 沉浸感：3D 渲染可以增强游戏的沉浸感 灵活性：3D 渲染提供了更多的创作空间 3D 渲染的核心组件Bevy 3D 渲染系统包含以下核心组件： Mesh3d：3D 网格，用于定义 3D 模型的形状 MeshMaterial3d：3D 材质，用于定义 3D 模型的外观 Camera3d：3D 相机，用于控制 3D 视图 Transform：变换，用于控制位置、旋转、缩放 Light：光照，用于照亮场景 基础用法创建简单的 3D 场景创建并显示一个简单的 3D 场景。 源代码文件：bevy/examples/3d/3d_scene.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();/// 设置简单的 3D 场景fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) // 圆形底座 commands.spawn(( Mesh3d(meshes.add(Circle::new(4.0))), MeshMaterial3d(materials.add(Color::WHITE)), Transform::from_rotation(Quat::from_rotation_x(-std::f32::consts::FRAC_PI_2)), )); // 立方体 commands.spawn(( Mesh3d(meshes.add(Cuboid::new(1.0, 1.0, 1.0))), MeshMaterial3d(materials.add(Color::srgb_u8(124, 144, 255))), Transform::from_xyz(0.0, 0.5, 0.0), )); // 光照 commands.spawn(( PointLight shadows_enabled: true, ..default() , Transform::from_xyz(4.0, 8.0, 4.0), )); // 相机 commands.spawn(( Camera3d::default(), Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y), )); 关键要点： 使用 Mesh3d 创建 3D 网格 使用 MeshMaterial3d 应用材质 使用 Transform 控制位置、旋转、缩放 使用 PointLight 添加点光源 使用 Camera3d 创建 3D 相机 说明：这是最简单的 3D 场景示例。它展示了如何创建基本的 3D 对象、添加光照和相机。 PBR 材质使用 PBR（Physically Based Rendering）材质创建真实的材质效果。 源代码文件：bevy/examples/3d/pbr.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) let sphere_mesh = meshes.add(Sphere::new(0.45)); // 创建网格的球体，每个球体有不同的 PBR 参数 for y in -2..=2 for x in -5..=5 let x01 = (x + 5) as f32 / 10.0; let y01 = (y + 2) as f32 / 4.0; // 球体 commands.spawn(( Mesh3d(sphere_mesh.clone()), MeshMaterial3d(materials.add(StandardMaterial base_color: Srgba::hex(#ffd891).unwrap().into(), // 在网格的球体上变化关键的 PBR 参数以显示效果 metallic: y01, perceptual_roughness: x01, ..default() )), Transform::from_xyz(x as f32, y as f32 + 0.5, 0.0), )); // 无光照球体 commands.spawn(( Mesh3d(sphere_mesh), MeshMaterial3d(materials.add(StandardMaterial base_color: Srgba::hex(#ffd891).unwrap().into(), unlit: true, ..default() )), Transform::from_xyz(-5.0, -2.5, 0.0), )); // 方向光 commands.spawn(( DirectionalLight illuminance: 1_500., ..default() , Transform::from_xyz(50.0, 50.0, 50.0).looking_at(Vec3::ZERO, Vec3::Y), )); 关键要点： 使用 StandardMaterial 创建 PBR 材质 metallic 控制金属度 perceptual_roughness 控制粗糙度 base_color 控制基础颜色 unlit 可以禁用光照 说明：PBR 材质使用物理属性来模拟真实材质的外观。通过调整金属度和粗糙度，可以创建各种材质效果。 光照系统使用不同类型的光照照亮场景。 源代码文件：bevy/examples/3d/lighting.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, (update_exposure, toggle_ambient_light, movement, animate_light_direction)) .run();fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) // 地面平面 commands.spawn(( Mesh3d(meshes.add(Plane3d::default().mesh().size(10.0, 10.0))), MeshMaterial3d(materials.add(StandardMaterial base_color: Color::WHITE, perceptual_roughness: 1.0, ..default() )), )); // 立方体 commands.spawn(( Mesh3d(meshes.add(Cuboid::new(1.0, 1.0, 1.0))), MeshMaterial3d(materials.add(StandardMaterial base_color: Color::srgb_u8(124, 144, 255), ..default() )), Transform::from_xyz(0.0, 0.5, 0.0), )); // 环境光 commands.insert_resource(AmbientLight color: Color::WHITE, brightness: 150.0, ); // 方向光 commands.spawn(( DirectionalLight illuminance: 1_500., shadows_enabled: true, ..default() , Transform::from_xyz(4.0, 8.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y), )); // 点光源 commands.spawn(( PointLight intensity: 1_500_000.0, shadows_enabled: true, ..default() , Transform::from_xyz(4.0, 8.0, 4.0), )); // 聚光灯 commands.spawn(( SpotLight intensity: 1_500_000.0, shadows_enabled: true, ..default() , Transform::from_xyz(4.0, 8.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y), )); // 相机 commands.spawn(( Camera3d::default(), Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y), )); 关键要点： AmbientLight 提供环境光 DirectionalLight 提供方向光（如太阳光） PointLight 提供点光源（如灯泡） SpotLight 提供聚光灯 可以启用阴影来增强真实感 说明：光照系统是 3D 渲染的重要组成部分。不同类型的光照可以创建不同的视觉效果。Bevy 支持环境光、方向光、点光源和聚光灯。 加载 GLTF 模型加载和使用 GLTF 模型。 源代码文件：bevy/examples/3d/load_gltf.rs 代码示例： use bevy::prelude::*;fn main() App::new() .insert_resource(DirectionalLightShadowMap size: 4096 ) .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, animate_light_direction) .run();fn setup(mut commands: Commands, asset_server: ResAssetServer) // 相机 commands.spawn(( Camera3d::default(), Transform::from_xyz(0.7, 0.7, 1.0).looking_at(Vec3::new(0.0, 0.3, 0.0), Vec3::Y), EnvironmentMapLight diffuse_map: asset_server.load(environment_maps/pisa_diffuse_rgb9e5_zstd.ktx2), specular_map: asset_server.load(environment_maps/pisa_specular_rgb9e5_zstd.ktx2), intensity: 250.0, ..default() , )); // 方向光 commands.spawn(( DirectionalLight shadows_enabled: true, ..default() , CascadeShadowConfigBuilder num_cascades: 1, maximum_distance: 1.6, ..default() .build(), )); // 加载 GLTF 场景 commands.spawn(SceneRoot(asset_server.load( GltfAssetLabel::Scene(0).from_asset(models/FlightHelmet/FlightHelmet.gltf), ))); 关键要点： 使用 SceneRoot 加载 GLTF 场景 使用 GltfAssetLabel::Scene(0) 指定场景索引 GLTF 文件可以包含多个场景、网格、材质等 可以使用环境贴图增强渲染效果 说明：GLTF 是一种标准的 3D 模型格式。Bevy 支持加载 GLTF 文件，包括场景、网格、材质、动画等。 进阶用法后处理效果使用后处理效果增强渲染效果。 源代码文件：bevy/examples/3d/post_processing.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, handle_keyboard_input) .run();fn setup(mut commands: Commands, asset_server: ResAssetServer) // 相机，包含色差效果 commands.spawn(( Camera3d::default(), Hdr, Transform::from_xyz(0.7, 0.7, 1.0).looking_at(Vec3::new(0.0, 0.3, 0.0), Vec3::Y), DistanceFog color: Color::srgb_u8(43, 44, 47), falloff: FogFalloff::Linear start: 1.0, end: 8.0, , ..default() , EnvironmentMapLight diffuse_map: asset_server.load(environment_maps/pisa_diffuse_rgb9e5_zstd.ktx2), specular_map: asset_server.load(environment_maps/pisa_specular_rgb9e5_zstd.ktx2), intensity: 2000.0, ..default() , // 包含色差效果组件 ChromaticAberration::default(), )); 关键要点： 使用 ChromaticAberration 添加色差效果 使用 Hdr 启用 HDR 渲染 使用 DistanceFog 添加距离雾效果 后处理效果可以组合使用 说明：后处理效果可以在渲染完成后对图像进行处理。Bevy 支持多种后处理效果，如色差、色调映射、泛光等。 透明度处理透明对象。 源代码文件：bevy/examples/3d/transparency_3d.rs 关键信息： 使用 AlphaMode 控制透明度模式 AlphaMode::Blend 用于半透明对象 AlphaMode::Mask 用于带透明度的纹理 透明对象需要正确的渲染顺序 说明：透明度是 3D 渲染中的重要特性。Bevy 支持多种透明度模式，可以创建玻璃、水、烟雾等效果。 多相机渲染使用多个相机渲染不同的视图。 源代码文件：bevy/examples/3d/multiple_windows.rs 关键信息： 可以创建多个相机 每个相机可以渲染到不同的窗口 可以使用 RenderTarget 指定渲染目标 适合创建分屏或多显示器应用 说明：多相机渲染允许同时显示多个视图。这对于创建分屏游戏、多显示器应用或调试视图非常有用。 实际应用在游戏开发中的应用场景3D 渲染在游戏开发中有广泛的应用： 3D 游戏：创建 3D 游戏场景和角色 可视化：创建数据可视化应用 模拟：创建物理模拟和训练应用 艺术创作：创建 3D 艺术作品和动画 常见问题问题 1：如何优化 3D 渲染性能？ 解决方案：可以使用 LOD（细节层次）、遮挡剔除、视锥剔除等技术来优化 3D 渲染性能。 问题 2：如何处理透明对象？ 解决方案：透明对象需要正确的渲染顺序。Bevy 会自动处理透明对象的排序。 问题 3：如何创建自定义材质？ 解决方案：可以实现 Material trait 来创建自定义材质。可以参考 StandardMaterial 的实现。 性能考虑 网格优化：使用优化的网格减少顶点数量 材质优化：使用简单的材质减少渲染开销 光照优化：合理使用光照类型和阴影 剔除优化：使用视锥剔除和遮挡剔除减少渲染对象 相关资源相关源代码文件： bevy/examples/3d/3d_scene.rs - 简单 3D 场景示例 bevy/examples/3d/pbr.rs - PBR 材质示例 bevy/examples/3d/lighting.rs - 光照系统示例 bevy/examples/3d/load_gltf.rs - GLTF 加载示例 bevy/examples/3d/post_processing.rs - 后处理效果示例 bevy/examples/3d/transparency_3d.rs - 透明度示例 bevy/examples/3d/multiple_windows.rs - 多相机渲染示例 官方文档链接： Bevy 3D 渲染文档 3D 示例 进一步学习建议： 学习相机系统，了解如何控制 3D 视图 学习动画系统，了解如何为 3D 模型添加动画 学习自定义渲染，了解如何创建自定义渲染效果 索引：返回上级目录"},{"title":"Input（输入处理）","path":"/Luo-Haomin/wiki/BevyBook/Input/README.html","content":"Input（输入处理）本部分介绍如何在 Bevy 中处理各种用户输入。 内容列表1. 输入基础 输入系统概述 输入事件类型 输入状态管理 输入处理流程 学习目标：理解 Bevy 的输入系统工作原理 2. 输入处理 键盘输入 按键检测 按键状态 按键组合 文本输入 鼠标输入 鼠标位置 鼠标按钮 鼠标滚轮 鼠标捕获 游戏手柄输入 手柄检测 手柄按钮 手柄摇杆 手柄震动 触摸输入 触摸事件 多点触控 手势识别 学习目标：能够处理各种类型的用户输入 3. 拾取系统（Picking） 拾取系统概述 鼠标拾取 射线拾取 拾取事件处理 学习目标：能够实现对象拾取和交互 学习建议 实践为主：多写代码处理不同的输入场景 理解事件：理解输入事件和状态的区别 平台差异：注意不同平台的输入差异 用户体验：考虑输入响应性和用户体验 相关资源 Bevy Input 官方文档 输入处理示例 下一步完成本部分学习后，建议继续学习： Graphics（图形渲染） - 结合输入实现交互 UI Audio（界面与音频） - 处理 UI 输入 索引：返回主目录"},{"title":"input基础","path":"/Luo-Haomin/wiki/BevyBook/Input/input基础.html","content":"input基础Bevy Input 基础教程本教程基于Bevy官方示例，按主题组织，提供易于理解的输入系统使用参考。 键盘输入基础键盘输入示例文件: keyboard_input.rs 最基本的键盘输入处理： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, keyboard_input_system) .run();/// 处理键盘输入的系统fn keyboard_input_system(keyboard_input: ResButtonInputKeyCode) // 检查按键是否正在被按下 if keyboard_input.pressed(KeyCode::KeyA) info!(A 键正在被按下); // 检查按键是否刚刚被按下 if keyboard_input.just_pressed(KeyCode::KeyA) info!(A 键刚刚被按下); // 检查按键是否刚刚被释放 if keyboard_input.just_released(KeyCode::KeyA) info!(A 键刚刚被释放); 关键要点: 使用 ResButtonInputKeyCode 获取键盘输入状态 pressed() 检查按键是否正在被按下 just_pressed() 检查按键是否刚刚被按下（只在按下瞬间触发一次） just_released() 检查按键是否刚刚被释放 键盘事件监听示例文件: keyboard_input_events.rs 监听所有键盘事件： use bevy::input::keyboard::KeyboardInput, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, print_keyboard_event_system) .run();/// 打印所有键盘事件的系统fn print_keyboard_event_system(mut keyboard_input_events: EventReaderKeyboardInput) for event in keyboard_input_events.read() info!(键盘事件: :?, event); 关键要点: 使用 EventReaderKeyboardInput 监听键盘事件 事件包含按键状态、物理键、逻辑键等信息 适合需要详细键盘信息的场景 键盘修饰键示例文件: keyboard_modifiers.rs 处理组合键和修饰键： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, keyboard_input_system) .run();/// 处理组合键的系统fn keyboard_input_system(input: ResButtonInputKeyCode) // 检查Shift键是否被按下（左Shift或右Shift） let shift = input.any_pressed([KeyCode::ShiftLeft, KeyCode::ShiftRight]); // 检查Ctrl键是否被按下（左Ctrl或右Ctrl） let ctrl = input.any_pressed([KeyCode::ControlLeft, KeyCode::ControlRight]); // 检查组合键 Ctrl + Shift + A if ctrl shift input.just_pressed(KeyCode::KeyA) info!(刚刚按下了 Ctrl + Shift + A!); // 检查其他组合键 if ctrl input.just_pressed(KeyCode::KeyS) info!(保存快捷键被触发); if ctrl input.just_pressed(KeyCode::KeyZ) info!(撤销快捷键被触发); 关键要点: any_pressed() 检查多个按键中是否有任意一个被按下 支持左右修饰键的检测 适合实现快捷键和组合键功能 字符输入示例文件: char_input_events.rs 处理字符输入（支持多语言）： use bevy:: input::keyboard::Key, KeyboardInput, prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, print_char_event_system) .run();/// 处理字符输入的系统fn print_char_event_system(mut char_input_events: EventReaderKeyboardInput) for event in char_input_events.read() // 只处理按键按下事件 if !event.state.is_pressed() continue; // 检查是否为字符输入 if let Key::Character(character) = event.logical_key info!(输入字符: , character); 关键要点: 使用 event.logical_key 获取逻辑键值 Key::Character 表示字符输入 支持多语言字符输入 适合文本输入和聊天功能 鼠标输入基础鼠标输入示例文件: mouse_input.rs 处理鼠标按钮和移动： use bevy:: input::mouse::AccumulatedMouseMotion, AccumulatedMouseScroll, prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, (mouse_click_system, mouse_move_system)) .run();/// 处理鼠标点击的系统fn mouse_click_system(mouse_button_input: ResButtonInputMouseButton) // 检查左键是否正在被按下 if mouse_button_input.pressed(MouseButton::Left) info!(左键正在被按下); // 检查左键是否刚刚被按下 if mouse_button_input.just_pressed(MouseButton::Left) info!(左键刚刚被按下); // 检查左键是否刚刚被释放 if mouse_button_input.just_released(MouseButton::Left) info!(左键刚刚被释放); // 检查右键 if mouse_button_input.just_pressed(MouseButton::Right) info!(右键刚刚被按下); // 检查中键 if mouse_button_input.just_pressed(MouseButton::Middle) info!(中键刚刚被按下); /// 处理鼠标移动和滚轮的系统fn mouse_move_system( accumulated_mouse_motion: ResAccumulatedMouseMotion, accumulated_mouse_scroll: ResAccumulatedMouseScroll,) // 处理鼠标移动 if accumulated_mouse_motion.delta != Vec2::ZERO let delta = accumulated_mouse_motion.delta; info!(鼠标移动了 (, ), delta.x, delta.y); // 处理鼠标滚轮 if accumulated_mouse_scroll.delta != Vec2::ZERO let delta = accumulated_mouse_scroll.delta; info!(鼠标滚动了 (, ), delta.x, delta.y); 关键要点: ButtonInputMouseButton 处理鼠标按钮 AccumulatedMouseMotion 处理鼠标移动 AccumulatedMouseScroll 处理滚轮滚动 支持左键、右键、中键检测 鼠标事件监听示例文件: mouse_input_events.rs 监听详细的鼠标事件： use bevy:: input:: gestures::*, mouse::MouseButtonInput, MouseMotion, MouseWheel, , prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, print_mouse_events_system) .run();/// 打印所有鼠标事件的系统fn print_mouse_events_system( mut mouse_button_input_events: EventReaderMouseButtonInput, mut mouse_motion_events: EventReaderMouseMotion, mut cursor_moved_events: EventReaderCursorMoved, mut mouse_wheel_events: EventReaderMouseWheel, mut pinch_gesture_events: EventReaderPinchGesture, mut rotation_gesture_events: EventReaderRotationGesture, mut double_tap_gesture_events: EventReaderDoubleTapGesture,) // 鼠标按钮事件 for event in mouse_button_input_events.read() info!(鼠标按钮事件: :?, event); // 鼠标移动事件 for event in mouse_motion_events.read() info!(鼠标移动事件: :?, event); // 光标移动事件 for event in cursor_moved_events.read() info!(光标移动事件: :?, event); // 鼠标滚轮事件 for event in mouse_wheel_events.read() info!(鼠标滚轮事件: :?, event); // 手势事件（仅macOS） for event in pinch_gesture_events.read() info!(捏合手势事件: :?, event); for event in rotation_gesture_events.read() info!(旋转手势事件: :?, event); for event in double_tap_gesture_events.read() info!(双击手势事件: :?, event); 关键要点: 多种事件类型提供不同粒度的鼠标信息 手势事件仅在macOS上可用 适合需要精确鼠标控制的场景 鼠标光标控制示例文件: mouse_grab.rs 控制鼠标光标的显示和锁定： use bevy::prelude::*, window::CursorGrabMode;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, grab_mouse) .run();/// 控制鼠标光标抓取的系统fn grab_mouse( mut window: Singlemut Window, mouse: ResButtonInputMouseButton, key: ResButtonInputKeyCode,) // 左键点击时隐藏光标并锁定鼠标 if mouse.just_pressed(MouseButton::Left) window.cursor_options.visible = false; window.cursor_options.grab_mode = CursorGrabMode::Locked; info!(鼠标已锁定); // ESC键释放鼠标 if key.just_pressed(KeyCode::Escape) window.cursor_options.visible = true; window.cursor_options.grab_mode = CursorGrabMode::None; info!(鼠标已释放); // 其他光标模式示例 if key.just_pressed(KeyCode::Key1) // 限制光标在窗口内 window.cursor_options.grab_mode = CursorGrabMode::Confined; if key.just_pressed(KeyCode::Key2) // 隐藏光标但不锁定 window.cursor_options.visible = false; window.cursor_options.grab_mode = CursorGrabMode::None; 关键要点: CursorGrabMode::Locked 锁定鼠标到窗口中心 CursorGrabMode::Confined 限制鼠标在窗口内 CursorGrabMode::None 正常模式 适合FPS游戏等需要鼠标控制的场景 触摸输入基础触摸输入示例文件: touch_input.rs 处理触摸屏输入： use bevy::input::touch::*, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, touch_system) .run();fn touch_system(touches: ResTouches) // 处理刚刚按下的触摸 for touch in touches.iter_just_pressed() info!( 触摸按下 - ID: , 位置: , touch.id(), touch.position() ); // 处理刚刚释放的触摸 for touch in touches.iter_just_released() info!( 触摸释放 - ID: , 位置: , touch.id(), touch.position() ); // 处理被取消的触摸 for touch in touches.iter_just_canceled() info!(触摸取消 - ID: , touch.id()); // 处理所有当前活动的触摸 for touch in touches.iter() info!(活动触摸: touch:?); info!( 是否刚刚按下: , touches.just_pressed(touch.id())); info!( 是否正在按下: , touches.pressed(touch.id())); info!( 位置: , touch.position()); info!( 压力: , touch.force().unwrap_or(0.0)); // 获取触摸数量 info!(当前触摸数量: , touches.count()); 关键要点: Touches 资源提供触摸状态 每个触摸有唯一ID 支持多点触摸 包含位置和压力信息 触摸事件监听示例文件: touch_input_events.rs 监听详细的触摸事件： use bevy::input::touch::*, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, touch_event_system) .run();fn touch_event_system(mut touch_events: EventReaderTouchInput) for event in touch_events.read() info!(触摸事件: :?, event); match event.phase TouchPhase::Started = info!(触摸开始 - ID: , 位置: , event.id, event.position); TouchPhase::Moved = info!(触摸移动 - ID: , 位置: , event.id, event.position); TouchPhase::Ended = info!(触摸结束 - ID: , 位置: , event.id, event.position); TouchPhase::Canceled = info!(触摸取消 - ID: , event.id); 关键要点: TouchInput 事件提供详细的触摸信息 TouchPhase 表示触摸的不同阶段 适合需要精确触摸控制的场景 游戏手柄输入基础游戏手柄输入示例文件: gamepad_input.rs 处理游戏手柄输入： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, gamepad_system) .run();fn gamepad_system(gamepads: Query(Entity, Gamepad)) for (entity, gamepad) in gamepads // 处理按钮输入 if gamepad.just_pressed(GamepadButton::South) info!(手柄 刚刚按下 South 按钮, entity); else if gamepad.just_released(GamepadButton::South) info!(手柄 刚刚释放 South 按钮, entity); // 处理扳机键（模拟输入） let right_trigger = gamepad.get(GamepadButton::RightTrigger2).unwrap(); if right_trigger.abs() 0.01 info!(手柄 右扳机值: , entity, right_trigger); // 处理摇杆输入 let left_stick_x = gamepad.get(GamepadAxis::LeftStickX).unwrap(); let left_stick_y = gamepad.get(GamepadAxis::LeftStickY).unwrap(); if left_stick_x.abs() 0.01 || left_stick_y.abs() 0.01 info!(手柄 左摇杆: (, ), entity, left_stick_x, left_stick_y); let right_stick_x = gamepad.get(GamepadAxis::RightStickX).unwrap(); let right_stick_y = gamepad.get(GamepadAxis::RightStickY).unwrap(); if right_stick_x.abs() 0.01 || right_stick_y.abs() 0.01 info!(手柄 右摇杆: (, ), entity, right_stick_x, right_stick_y); // 处理其他按钮 if gamepad.just_pressed(GamepadButton::North) info!(手柄 按下 North 按钮, entity); if gamepad.just_pressed(GamepadButton::East) info!(手柄 按下 East 按钮, entity); if gamepad.just_pressed(GamepadButton::West) info!(手柄 按下 West 按钮, entity); 关键要点: Gamepad 组件提供手柄输入状态 支持多个手柄同时连接 按钮有数字和模拟两种输入 摇杆提供X、Y轴模拟输入 游戏手柄事件监听示例文件: gamepad_input_events.rs 监听游戏手柄连接和输入事件： use bevy:: input::gamepad:: GamepadAxisChangedEvent, GamepadButtonChangedEvent, GamepadButtonStateChangedEvent, GamepadConnectionEvent, GamepadEvent, , prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Update, (gamepad_events, gamepad_ordered_events)) .run();fn gamepad_events( mut connection_events: EventReaderGamepadConnectionEvent, mut axis_changed_events: EventReaderGamepadAxisChangedEvent, mut button_changed_events: EventReaderGamepadButtonChangedEvent, mut button_input_events: EventReaderGamepadButtonStateChangedEvent,) // 处理连接事件 for connection_event in connection_events.read() info!(手柄连接事件: :?, connection_event); // 处理轴变化事件 for axis_changed_event in axis_changed_events.read() info!( 手柄轴变化 - 轴: :?, 手柄: , 值: , axis_changed_event.axis, axis_changed_event.entity, axis_changed_event.value ); // 处理按钮变化事件 for button_changed_event in button_changed_events.read() info!( 手柄按钮变化 - 按钮: :?, 手柄: , 值: , button_changed_event.button, button_changed_event.entity, button_changed_event.value ); // 处理按钮状态变化事件 for button_input_event in button_input_events.read() info!(手柄按钮状态变化: :?, button_input_event); // 处理有序的游戏手柄事件fn gamepad_ordered_events(mut gamepad_events: EventReaderGamepadEvent) for gamepad_event in gamepad_events.read() match gamepad_event GamepadEvent::Connection(connection_event) = info!(手柄连接事件: :?, connection_event); GamepadEvent::Button(button_event) = info!(手柄按钮事件: :?, button_event); GamepadEvent::Axis(axis_event) = info!(手柄轴事件: :?, axis_event); 关键要点: 多种事件类型提供不同粒度的手柄信息 连接事件处理手柄插拔 轴和按钮事件提供精确的输入变化 有序事件确保事件处理的正确顺序 文本输入基础文本输入示例文件: text_input.rs 处理文本输入和IME（输入法编辑器）： use std::mem;use bevy:: input::keyboard::Key, KeyboardInput, prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup_scene) .add_systems( Update, ( toggle_ime, listen_ime_events, listen_keyboard_input_events, bubbling_text, ), ) .run();fn setup_scene(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Camera2d); // 使用支持更多字符的字体 let font = asset_server.load(fonts/FiraMono-Medium.ttf); // 创建UI文本显示 commands.spawn(( Text::default(), Node position_type: PositionType::Absolute, top: Val::Px(12.0), left: Val::Px(12.0), ..default() , children![ TextSpan::new(点击切换IME。按回车开始新行。\\ \\ ), TextSpan::new(IME启用: ), TextSpan::new(false\\ ), TextSpan::new(IME激活: ), TextSpan::new(false\\ ), TextSpan::new(IME缓冲区: ), ( TextSpan::new(\\ ), TextFont font: font.clone(), ..default() , ), ], )); // 创建2D文本用于输入 commands.spawn(( Text2d::new(), TextFont font, font_size: 100.0, ..default() , ));// 切换IME状态fn toggle_ime( input: ResButtonInputMouseButton, mut window: Singlemut Window, status_text: SingleEntity, (WithNode, WithText), mut ui_writer: TextUiWriter,) if input.just_pressed(MouseButton::Left) window.ime_position = window.cursor_position().unwrap(); window.ime_enabled = !window.ime_enabled; *ui_writer.text(*status_text, 3) = format!(\\ , window.ime_enabled); // 监听IME事件fn listen_ime_events( mut events: EventReaderIme, status_text: SingleEntity, (WithNode, WithText), mut edit_text: Singlemut Text2d, (WithoutNode, WithoutBubble), mut ui_writer: TextUiWriter,) for event in events.read() match event Ime::Preedit value, cursor = *ui_writer.text(*status_text, 5) = format!(\\ , value); *ui_writer.text(*status_text, 4) = true\\ .to_string(); Ime::Commit value = edit_text.0 = format!(, edit_text.0, value); *ui_writer.text(*status_text, 5) = \\ .to_string(); *ui_writer.text(*status_text, 4) = false\\ .to_string(); Ime::Enabled .. = *ui_writer.text(*status_text, 4) = true\\ .to_string(); Ime::Disabled .. = *ui_writer.text(*status_text, 4) = false\\ .to_string(); // 监听键盘输入事件fn listen_keyboard_input_events( mut commands: Commands, mut events: EventReaderKeyboardInput, edit_text: Single(mut Text2d, TextFont), (WithoutNode, WithoutBubble),) for event in events.read() if !event.state.is_pressed() continue; match event.logical_key Key::Character(character) = if is_printable_char(*character) edit_text.0 .0 = format!(, edit_text.0 .0, character); Key::Enter = edit_text.0 .0 = format!(\\ , edit_text.0 .0); Key::Backspace = edit_text.0 .0.pop(); _ = // 检查是否为可打印字符fn is_printable_char(chr: char) - bool !chr.is_control() || chr == \\ || chr == \\\\t 关键要点: IME支持多语言输入 处理预编辑和提交事件 支持特殊键如回车、退格 需要合适的字体支持多语言字符 总结Bevy的输入系统提供了全面的输入处理能力： 键盘输入: 基础按键、组合键、字符输入 鼠标输入: 按钮、移动、滚轮、光标控制 触摸输入: 多点触摸、手势识别 游戏手柄: 按钮、摇杆、扳机、震动 文本输入: IME支持、多语言输入 这些输入系统可以组合使用，创建丰富的交互体验。建议根据项目需求选择合适的输入方式。"},{"title":"Advanced（高级主题）","path":"/Luo-Haomin/wiki/BevyBook/Advanced/README.html","content":"Advanced（高级主题）本部分介绍 Bevy 的高级功能和优化技巧。 内容列表1. 性能优化 性能分析 性能分析工具 性能瓶颈识别 性能指标 优化技巧 ECS 查询优化 系统调度优化 资源管理优化 渲染优化 内存优化 最佳实践 避免常见性能问题 性能测试 性能监控 学习目标：能够优化 Bevy 应用的性能 2. 自定义渲染 渲染管线 渲染管线概述 自定义渲染管线 渲染阶段（Render Stages） 着色器 着色器语言（WGSL） 顶点着色器 片段着色器 计算着色器 自定义材质 材质系统 自定义材质 材质属性 后处理效果 后处理管线 自定义后处理 常见效果实现 学习目标：能够实现自定义渲染效果 3. 网络编程 网络基础 网络架构 客户端-服务器模型 同步机制 实现方法 网络库选择 消息协议 状态同步 预测与插值 多人游戏 房间系统 玩家管理 游戏状态同步 学习目标：能够开发多人网络游戏 4. 拆解学习 深入理解 Bevy Bevy 内部机制 源码阅读 架构分析 扩展 Bevy 自定义系统 自定义组件 自定义资源 学习目标：深入理解 Bevy 的内部机制 学习建议 循序渐进：先掌握基础，再学习高级主题 实践为主：通过实际项目应用高级功能 阅读源码：阅读 Bevy 源码加深理解 社区参与：参与 Bevy 社区讨论 注意：插件开发内容已移至 Architecture（架构设计） 部分。 相关资源 Bevy 官方文档 Bevy 源码 Bevy Discord Bevy 插件仓库 下一步完成本部分学习后，你已经掌握了 Bevy 的核心功能。建议： 开始实际项目开发 参与 Bevy 社区 贡献代码和文档 分享你的经验 索引：返回主目录"},{"title":"3D Graphics（3D 图形）","path":"/Luo-Haomin/wiki/BevyBook/3D_Graphics/README.html","content":"3D Graphics（3D 图形）本部分介绍如何在 Bevy 中进行 3D 图形渲染和开发。 内容列表1. 3D 开发 3D 基础 3D 坐标系 3D 变换（Transform） 3D 渲染管线 3D 模型 加载 3D 模型 模型格式（GLTF、OBJ） 模型动画 模型优化 材质系统 标准材质（Standard Material） PBR 材质（Physically Based Rendering） 自定义材质 材质属性 光照系统 环境光（Ambient Light） 方向光（Directional Light） 点光源（Point Light） 聚光灯（Spot Light） 阴影（Shadows） 3D 相机 透视相机（Perspective Camera） 正交相机（Orthographic Camera） 相机控制 相机跟随 3D 物理 3D 刚体 3D 碰撞检测 物理材质 物理约束 学习目标：能够开发完整的 3D 游戏 2. 相机系统（Camera） 相机系统概述 透视相机 正交相机 相机控制 相机跟随 多相机渲染 学习目标：能够控制 3D 视图和相机 学习建议 理解 3D 数学：理解向量、矩阵、四元数等 3D 数学基础 学习 PBR：理解基于物理的渲染原理 性能优化：注意 3D 渲染的性能优化 实践项目：通过实际项目加深理解 相关资源 Bevy 3D 官方文档 3D 渲染示例 GLTF 格式文档 下一步完成本部分学习后，建议继续学习： UI Audio（界面与音频） - 添加 UI 和音效 Architecture（架构设计） - 组织大型 3D 项目 Advanced（高级主题） - 自定义渲染、性能优化 索引：返回主目录"},{"title":"性能优化","path":"/Luo-Haomin/wiki/BevyBook/Advanced/性能优化.html","content":"性能优化概述学习目标： 理解 Bevy 性能优化的基本概念 掌握性能分析工具的使用 学会优化 ECS 查询和系统调度 了解渲染优化技巧 掌握内存优化方法 理解大规模实体处理 前置知识要求： ECS 基础 系统调度基础 渲染基础 资源管理基础 核心概念什么是性能优化？性能优化是提高应用运行效率的过程。在 Bevy 中，性能优化涉及多个方面，包括 ECS 查询优化、系统调度优化、渲染优化、内存优化等。 为什么需要性能优化？ 提高帧率：优化可以提高游戏的帧率，提供更流畅的体验 减少延迟：优化可以减少输入延迟，提高响应性 降低资源消耗：优化可以降低 CPU 和内存使用 支持更大规模：优化可以支持更多实体和更复杂的场景 性能优化的核心原则 测量优先：在优化之前先测量性能 识别瓶颈：找到真正的性能瓶颈 针对性优化：针对瓶颈进行优化 验证效果：优化后验证效果 基础用法性能分析工具使用 Bevy 的诊断插件进行性能分析。 源代码文件：bevy/examples/stress_tests/bevymark.rs 代码示例： use bevy:: diagnostic::DiagnosticsStore, FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin, prelude::*,;fn main() App::new() .add_plugins(DefaultPlugins) .add_plugins(FrameTimeDiagnosticsPlugin) .add_plugins(LogDiagnosticsPlugin::default()) .add_systems(Update, print_diagnostics) .run();fn print_diagnostics(diagnostics: ResDiagnosticsStore) if let Some(fps) = diagnostics.get(FrameTimeDiagnosticsPlugin::FPS) if let Some(value) = fps.smoothed() println!(FPS: :.2, value); 关键要点： 使用 FrameTimeDiagnosticsPlugin 监控帧率 使用 LogDiagnosticsPlugin 记录诊断信息 使用 DiagnosticsStore 访问诊断数据 可以监控 FPS、帧时间等指标 说明：性能分析是优化的第一步。通过诊断插件，可以监控应用的性能指标，识别性能瓶颈。 ECS 查询优化优化 ECS 查询以提高性能。 源代码文件：bevy/examples/stress_tests/many_cubes.rs 关键信息： 使用精确的查询过滤器减少查询范围 避免不必要的组件访问 使用并行查询提高性能 合理使用 Changed 过滤器 说明：ECS 查询是性能的关键。通过优化查询，可以减少不必要的组件访问，提高系统执行效率。 系统调度优化优化系统调度以提高性能。 关键信息： 合理组织系统集（SystemSet） 使用运行条件（Run Conditions）避免不必要的执行 利用并行执行提高性能 避免系统间的数据竞争 说明：系统调度优化可以提高系统的执行效率。通过合理组织系统，可以充分利用并行执行，提高性能。 渲染优化优化渲染以提高性能。 源代码文件：bevy/examples/stress_tests/many_cubes.rs 代码示例： use bevy:: camera::visibility::NoCpuCulling, NoFrustumCulling, render:: batching::NoAutomaticBatching, view::NoIndirectDrawing, , prelude::*,;// 禁用视锥剔除（用于压力测试）commands.spawn(( Camera3d::default(), NoFrustumCulling, NoCpuCulling,));// 禁用自动批处理（用于压力测试）commands.spawn(( Mesh3d(mesh_handle), MeshMaterial3d(material_handle), NoAutomaticBatching, NoIndirectDrawing,)); 关键要点： 使用视锥剔除（Frustum Culling）减少渲染对象 使用遮挡剔除（Occlusion Culling）进一步优化 使用批处理（Batching）减少绘制调用 使用实例化渲染（Instancing）提高性能 说明：渲染优化是性能优化的重要部分。通过使用剔除、批处理、实例化等技术，可以显著提高渲染性能。 内存优化优化内存使用以提高性能。 关键信息： 合理使用资源生命周期 及时清理不再使用的资源 使用对象池减少分配 避免不必要的克隆 说明：内存优化可以减少内存分配和垃圾回收，提高性能。通过合理管理资源生命周期，可以避免内存泄漏。 大规模实体处理处理大规模实体以提高性能。 源代码文件：bevy/examples/stress_tests/bevymark.rs 代码示例： use bevy::prelude::*;const BIRDS_PER_SECOND: u32 = 10000;fn spawn_birds( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial, time: ResTime,) let bird_count = (BIRDS_PER_SECOND as f32 * time.delta_secs()) as u32; for _ in 0..bird_count commands.spawn(( Mesh3d(meshes.add(Cuboid::new(0.1, 0.1, 0.1))), MeshMaterial3d(materials.add(Color::srgb(0.5, 0.5, 1.0))), Transform::from_xyz( rand::random::f32() * 100.0 - 50.0, rand::random::f32() * 100.0 - 50.0, rand::random::f32() * 100.0 - 50.0, ), Bird velocity: Vec3::new( rand::random::f32() * 2.0 - 1.0, rand::random::f32() * 2.0 - 1.0, rand::random::f32() * 2.0 - 1.0, ), , )); 关键要点： 使用批处理减少绘制调用 使用实例化渲染提高性能 合理使用剔除减少渲染对象 优化实体创建和销毁 说明：大规模实体处理是性能优化的挑战。通过使用批处理、实例化、剔除等技术，可以支持更多实体。 进阶用法高级性能分析使用更高级的性能分析工具。 关键信息： 使用性能分析器（如 tracy、puffin） 分析系统执行时间 识别热点函数 优化关键路径 说明：高级性能分析可以提供更详细的性能信息，帮助识别性能瓶颈。 自定义批处理实现自定义批处理策略。 关键信息： 理解批处理原理 实现自定义批处理逻辑 优化批处理性能 处理批处理边界情况 说明：自定义批处理可以根据具体需求优化批处理策略，提高性能。 实际应用在游戏开发中的应用场景性能优化在游戏开发中有广泛的应用： 大规模场景：优化大规模场景的渲染性能 复杂系统：优化复杂系统的执行效率 移动平台：优化移动平台的性能 实时应用：优化实时应用的响应性 常见问题问题 1：如何识别性能瓶颈？ 解决方案：使用性能分析工具，如 FrameTimeDiagnosticsPlugin、LogDiagnosticsPlugin，或者使用外部性能分析器。 问题 2：如何优化 ECS 查询？ 解决方案：使用精确的查询过滤器，避免不必要的组件访问，使用并行查询，合理使用 Changed 过滤器。 问题 3：如何优化渲染性能？ 解决方案：使用视锥剔除、遮挡剔除、批处理、实例化渲染等技术。 性能考虑 测量优先：在优化之前先测量性能 识别瓶颈：找到真正的性能瓶颈 针对性优化：针对瓶颈进行优化 验证效果：优化后验证效果 相关资源相关源代码文件： bevy/examples/stress_tests/bevymark.rs - 2D 性能测试示例 bevy/examples/stress_tests/many_cubes.rs - 3D 性能测试示例 bevy/examples/stress_tests/many_sprites.rs - 精灵性能测试示例 bevy/examples/stress_tests/README.md - 性能测试说明 官方文档链接： Bevy 性能优化文档 性能测试示例 进一步学习建议： 学习自定义渲染，了解如何优化渲染管线 学习大规模实体开发，了解如何处理大规模场景 学习性能分析工具，了解如何识别性能瓶颈 索引：返回上级目录"},{"title":"拆解学习","path":"/Luo-Haomin/wiki/BevyBook/Advanced/拆解学习.html","content":"拆解学习概述学习目标： 理解如何深入理解 Bevy 的内部机制 掌握源代码阅读方法 学会架构分析方法 了解如何扩展 Bevy 功能 理解性能优化原理 前置知识要求： Bevy 基础 Rust 高级特性 系统编程基础 游戏引擎原理 核心概念什么是拆解学习？拆解学习是通过阅读和分析 Bevy 源代码，深入理解 Bevy 的内部机制和设计原理。这包括理解架构设计、实现细节、性能优化等。 为什么需要拆解学习？ 深入理解：深入理解 Bevy 的工作原理 扩展功能：基于 Bevy 扩展自己的功能 性能优化：理解性能优化原理 问题解决：更好地解决遇到的问题 拆解学习的核心方法 源代码阅读：阅读 Bevy 源代码 架构分析：分析 Bevy 的架构设计 功能扩展：基于 Bevy 扩展功能 性能分析：分析性能优化原理 基础用法源代码阅读阅读 Bevy 源代码的方法。 关键信息： 从 bevy/src/lib.rs 开始，了解 Bevy 的整体结构 阅读各个模块的源代码，理解实现细节 参考示例代码，理解使用方法 阅读文档注释，理解设计思想 说明：源代码阅读是拆解学习的基础。通过阅读源代码，可以理解 Bevy 的实现细节和设计思想。 架构分析分析 Bevy 的架构设计。 关键信息： 理解 ECS 架构的设计和实现 理解渲染管线的设计和实现 理解插件系统的设计和实现 理解资源管理系统的设计和实现 说明：架构分析帮助理解 Bevy 的整体设计。通过分析架构，可以理解 Bevy 的设计思想和实现原理。 功能扩展基于 Bevy 扩展功能。 关键信息： 创建自定义插件 实现自定义系统 创建自定义组件和资源 扩展渲染功能 说明：功能扩展是拆解学习的应用。通过扩展功能，可以深入理解 Bevy 的扩展机制。 性能分析分析性能优化原理。 关键信息： 理解 ECS 的性能优化原理 理解渲染性能优化原理 理解内存管理优化原理 理解系统调度优化原理 说明：性能分析帮助理解 Bevy 的性能优化原理。通过分析性能优化，可以学习如何优化自己的应用。 进阶用法深入理解 ECS深入理解 Bevy ECS 的实现。 关键信息： 理解组件存储机制 理解系统调度机制 理解查询优化原理 理解变更检测机制 说明：ECS 是 Bevy 的核心。通过深入理解 ECS 的实现，可以更好地使用和扩展 Bevy。 深入理解渲染系统深入理解 Bevy 渲染系统的实现。 关键信息： 理解渲染管线设计 理解材质系统实现 理解着色器编译流程 理解批处理机制 说明：渲染系统是 Bevy 的重要组成部分。通过深入理解渲染系统的实现，可以更好地优化渲染性能。 深入理解插件系统深入理解 Bevy 插件系统的实现。 关键信息： 理解插件注册机制 理解插件依赖管理 理解插件生命周期 理解插件配置机制 说明：插件系统是 Bevy 的扩展机制。通过深入理解插件系统的实现，可以更好地创建和使用插件。 实际应用在游戏开发中的应用场景拆解学习在游戏开发中有广泛的应用： 问题调试：通过理解源代码更好地调试问题 功能扩展：基于 Bevy 扩展自己的功能 性能优化：理解性能优化原理，优化自己的应用 学习提升：通过学习 Bevy 的设计提升自己的编程能力 常见问题问题 1：如何开始阅读 Bevy 源代码？ 解决方案：从 bevy/src/lib.rs 开始，了解整体结构，然后阅读感兴趣的模块。 问题 2：如何理解 Bevy 的架构设计？ 解决方案：阅读架构文档，分析源代码结构，理解设计思想。 问题 3：如何基于 Bevy 扩展功能？ 解决方案：创建自定义插件，实现自定义系统，参考 Bevy 的扩展机制。 学习建议 循序渐进：从简单到复杂，逐步深入 实践为主：通过实践加深理解 参考文档：参考官方文档和示例 社区参与：参与 Bevy 社区讨论 相关资源相关源代码文件： bevy/src/lib.rs - Bevy 主库文件 bevy/crates/bevy_ecs/ - ECS 实现 bevy/crates/bevy_render/ - 渲染系统实现 bevy/crates/bevy_app/ - 应用系统实现 官方文档链接： Bevy 源代码 Bevy 架构文档 Bevy 社区 进一步学习建议： 阅读 Bevy 源代码，深入理解实现细节 参与 Bevy 社区，学习最佳实践 贡献代码，提升编程能力 学习游戏引擎原理，理解设计思想 索引：返回上级目录"},{"title":"网络编程","path":"/Luo-Haomin/wiki/BevyBook/Advanced/网络编程.html","content":"网络编程概述学习目标： 理解 Bevy 网络编程的基本概念 了解 RemotePlugin 的使用 掌握服务器端开发 掌握客户端开发 理解网络同步机制 前置知识要求： ECS 基础 系统调度基础 HTTP 基础 JSON-RPC 基础 核心概念什么是网络编程？网络编程是在 Bevy 应用中实现网络通信的功能。Bevy 提供了 RemotePlugin 和 RemoteHttpPlugin，允许通过网络连接远程访问和控制 Bevy 应用。 为什么需要网络编程？ 远程调试：通过网络远程调试 Bevy 应用 远程控制：通过网络远程控制 Bevy 应用 多人游戏：实现多人游戏功能 工具集成：与外部工具集成 网络编程的核心组件Bevy 网络编程系统包含以下核心组件： RemotePlugin：远程插件，提供基本的远程功能 RemoteHttpPlugin：HTTP 远程插件，提供 HTTP 接口 BRP：Bevy Remote Protocol，Bevy 远程协议 JSON-RPC：JSON-RPC 协议，用于通信 基础用法服务器端开发创建服务器端应用。 源代码文件：bevy/examples/remote/server.rs 代码示例： use bevy:: prelude::*, remote::http::RemoteHttpPlugin, RemotePlugin,;fn main() App::new() .add_plugins(DefaultPlugins) .add_plugins(RemotePlugin::default()) .add_plugins(RemoteHttpPlugin::default()) .add_systems(Startup, setup) .add_systems(Update, move_cube) .run();fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) // 创建场景 commands.spawn(( Mesh3d(meshes.add(Cuboid::new(1.0, 1.0, 1.0))), MeshMaterial3d(materials.add(Color::srgb_u8(124, 144, 255))), Transform::from_xyz(0.0, 0.5, 0.0), Cube(1.0), )); // 创建资源（可以被远程访问和修改） commands.insert_resource(TestResource foo: Vec2::new(1.0, -1.0), bar: false, ); // 创建光照和相机 commands.spawn(( PointLight shadows_enabled: true, ..default() , Transform::from_xyz(4.0, 8.0, 4.0), )); commands.spawn(( Camera3d::default(), Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y), ));#[derive(Resource, Reflect, Serialize, Deserialize)]#[reflect(Resource, Serialize, Deserialize)]pub struct TestResource pub foo: Vec2, pub bar: bool,#[derive(Component, Reflect, Serialize, Deserialize)]#[reflect(Component, Serialize, Deserialize)]struct Cube(f32);fn move_cube(mut query: Querymut Transform, WithCube, time: ResTime) for mut transform in mut query transform.translation.y = -time.elapsed_secs().cos() + 1.5; 关键要点： 使用 RemotePlugin 启用远程功能 使用 RemoteHttpPlugin 启用 HTTP 接口 使用 #[derive(Reflect, Serialize, Deserialize)] 使资源可远程访问 使用 #[reflect(Resource)] 或 #[reflect(Component)] 标记可远程访问的类型 说明：服务器端应用提供远程访问接口。通过 RemotePlugin 和 RemoteHttpPlugin，可以启用 HTTP 接口，允许客户端通过网络访问和控制应用。 客户端开发创建客户端应用。 源代码文件：bevy/examples/remote/client.rs 代码示例： use bevy:: prelude::*, remote:: builtin_methods:: BrpQuery, BrpQueryFilter, BrpQueryParams, ComponentSelector, BRP_QUERY_METHOD, , http::DEFAULT_ADDR, DEFAULT_PORT, BrpRequest, , transform::components::Transform,;fn main() - Result(), anyhow::Error let host_part = format!(DEFAULT_ADDR:DEFAULT_PORT); let url = format!(http://host_part/); // 查询所有 Transform 组件 run_transform_only_query(url)?; // 查询根实体 run_query_root_entities(url)?; // 查询所有组件和实体 run_query_all_components_and_entities(url)?; Ok(())fn run_transform_only_query(url: str) - Result(), anyhow::Error let request = BrpRequest jsonrpc: String::from(2.0), method: String::from(BRP_QUERY_METHOD), id: Some(serde_json::to_value(1)?), params: Some( serde_json::to_value(BrpQueryParams data: BrpQuery components: vec![std::any::type_name::Transform().to_string()], ..Default::default() , strict: false, filter: BrpQueryFilter::default(), )?, ), ; let response = ureq::post(url) .send_json(request)? .body_mut() .read_json::serde_json::Value()?; println!(Transform query response: response:#); Ok(()) 关键要点： 使用 BrpRequest 创建 JSON-RPC 请求 使用 BrpQuery 查询实体和组件 使用 ComponentSelector 选择组件 通过 HTTP POST 发送请求 说明：客户端应用通过网络访问服务器端应用。通过 JSON-RPC 协议，可以查询实体、组件、资源等，并可以修改它们。 网络同步机制理解网络同步机制。 关键信息： 使用 Reflect trait 使类型可序列化 使用 Serialize 和 Deserialize 进行序列化 通过 JSON-RPC 协议进行通信 支持查询、修改、调用方法等操作 说明：网络同步机制允许客户端和服务器端同步数据。通过 Reflect、Serialize 和 Deserialize，可以将 Bevy 的类型序列化并通过网络传输。 进阶用法自定义远程方法实现自定义远程方法。 关键信息： 可以定义自定义的远程方法 可以在服务器端实现自定义逻辑 客户端可以调用这些方法 说明：自定义远程方法允许你实现自己的远程功能。这对于实现特定的网络功能非常有用。 网络优化优化网络性能。 关键信息： 减少网络请求频率 使用批量查询减少请求数量 合理使用缓存 优化序列化性能 说明：网络优化可以提高网络通信的性能。通过减少请求频率、使用批量查询、合理使用缓存等技术，可以显著提高性能。 实际应用在游戏开发中的应用场景网络编程在游戏开发中有广泛的应用： 远程调试：通过网络远程调试游戏 远程控制：通过网络远程控制游戏 多人游戏：实现多人游戏功能 工具集成：与外部工具集成 常见问题问题 1：如何启用远程功能？ 解决方案：添加 RemotePlugin 和 RemoteHttpPlugin 到应用中，使用 #[derive(Reflect)] 标记可远程访问的类型。 问题 2：如何查询远程实体？ 解决方案：使用 BrpQuery 创建查询请求，通过 JSON-RPC 协议发送请求。 问题 3：如何修改远程资源？ 解决方案：使用 BrpRequest 创建修改请求，通过 JSON-RPC 协议发送请求。 性能考虑 请求频率：减少网络请求频率 批量操作：使用批量查询和操作 缓存：合理使用缓存减少网络请求 序列化：优化序列化性能 相关资源相关源代码文件： bevy/examples/remote/server.rs - 服务器端示例 bevy/examples/remote/client.rs - 客户端示例 官方文档链接： Bevy Remote 文档 JSON-RPC 规范 远程示例 进一步学习建议： 学习 JSON-RPC 协议，了解通信机制 学习 Reflect 系统，了解序列化机制 学习网络编程，了解如何实现多人游戏 索引：返回上级目录"},{"title":"ECS 进阶","path":"/Luo-Haomin/wiki/BevyBook/ECS/ECS进阶.html","content":"ECS 进阶概述学习目标： 掌握变更检测（Change Detection）的使用方法 理解组件生命周期钩子（Component Hooks）的应用场景 学会使用关系系统（Relationships）建立实体间的关系 掌握并行查询（Parallel Queries）的性能优化技巧 理解查询组合（Query Combinations）的使用方法 学会使用观察者模式（Observers）响应组件变化 了解消息系统、错误处理、动态 ECS 等高级功能 前置知识要求： 核心编程框架（ECS） 组件（Components） 实体（Entities） 系统（Systems） 查询（Queries） 资源（Resources） 系统调度（Schedule App） 核心概念为什么需要高级 ECS 功能？在复杂的游戏开发中，我们需要： 性能优化：通过并行查询提高系统执行效率 变更响应：检测组件和资源的变化，及时响应 关系管理：建立和维护实体间的复杂关系 生命周期管理：在组件的生命周期关键点执行逻辑 事件驱动：使用消息系统和观察者模式实现事件驱动逻辑 ECS 进阶功能概览 变更检测：检测组件和资源的变化 组件生命周期钩子：在组件添加、插入、替换、移除时执行逻辑 关系系统：建立自定义的实体关系 并行查询：使用并行迭代器提高性能 查询组合：处理实体间的交互 观察者模式：响应组件生命周期事件和自定义事件 消息系统：使用消息实现系统间通信 错误处理：处理系统执行中的错误 动态 ECS：动态创建组件和实体 基础用法变更检测（Change Detection）变更检测用于检测组件和资源的变化，是响应式编程的基础。 源代码文件：bevy/examples/ecs/change_detection.rs 代码示例： use bevy::prelude::*;#[derive(Component, PartialEq, Debug)]struct MyComponent(f32);#[derive(Resource, PartialEq, Debug)]struct MyResource(f32);fn change_component(time: ResTime, mut query: Query(Entity, mut MyComponent)) for (entity, mut component) in mut query if rand::rng().random_bool(0.1) let new_component = MyComponent(time.elapsed_secs().round()); info!(New value: new_component:? entity); // 变更检测发生在可变解引用时，不考虑值是否实际相等 // 为了避免在值未实际改变时触发变更检测，可以使用 `set_if_neq` 方法 // 该方法要求组件实现 PartialEq component.set_if_neq(new_component); fn change_detection( changed_components: QueryRefMyComponent, ChangedMyComponent, my_resource: ResMyResource,) for component in changed_components // 默认情况下，你只能知道组件被改变了 // 但如果有多个系统修改同一个组件，如何知道是哪个系统导致的改变？ warn!( Change detected! \\t- value: :? \\t- added: \\t- changed: \\t- changed by: , component, component.is_added(), component.is_changed(), // 如果启用 `track_location` 特性，可以解锁 `changed_by()` 方法 // 它返回组件或资源被改变的文件和行号 // 不建议在发布的游戏中使用，但对调试很有用！ component.changed_by() ); if my_resource.is_changed() warn!( Change detected! \\t- value: :? \\t- added: \\t- changed: \\t- changed by: , my_resource, my_resource.is_added(), my_resource.is_changed(), my_resource.changed_by() // 与组件一样，需要 `track_location` 特性 ); 关键要点： 使用 ChangedT 过滤器查询已变更的组件 使用 AddedT 过滤器查询新添加的组件 使用 RefT 系统参数访问变更检测信息，但不过滤查询 使用 set_if_neq() 方法避免不必要的变更检测 使用 is_changed() 和 is_added() 检查变更状态 使用 changed_by() 方法（需要 track_location 特性）获取变更位置 说明：变更检测是 Bevy ECS 的核心功能之一。当组件或资源被修改时，Bevy 会自动跟踪这些变更。使用 ChangedT 过滤器可以只查询已变更的组件，这对于性能优化很重要。set_if_neq() 方法可以避免在值未实际改变时触发变更检测，这对于实现 PartialEq 的组件很有用。 组件生命周期钩子（Component Hooks）组件生命周期钩子允许在组件的生命周期关键点执行逻辑。 源代码文件：bevy/examples/ecs/component_hooks.rs 代码示例： use bevy:: ecs::component::Mutable, StorageType, ecs::lifecycle::ComponentHook, HookContext, prelude::*,;use std::collections::HashMap;#[derive(Debug)]struct MyComponent(KeyCode);impl Component for MyComponent const STORAGE_TYPE: StorageType = StorageType::Table; type Mutability = Mutable; fn on_add() - OptionComponentHook // 如果没有 on_add 钩子，返回 None // 注意这是不实现钩子时的默认行为 None fn setup(world: mut World) // 为了注册组件钩子，组件必须： // - 当前未被世界中的任何实体使用 // - 尚未注册该类型的钩子 // 这是为了防止覆盖插件和其他 crate 中定义的钩子，并保持性能 world .register_component_hooks::MyComponent() // 有 4 种组件生命周期钩子：`on_add`、`on_insert`、`on_replace` 和 `on_remove` // 钩子有 2 个参数： // - 一个 `DeferredWorld`，允许访问资源和组件数据以及 `Commands` // - 一个 `HookContext`，提供以下上下文信息： // - 触发钩子的实体 // - 触发组件的组件 ID，主要用于动态组件 // - 导致钩子触发的代码位置 // // `on_add` 将在组件插入到没有该组件的实体上时触发 .on_add( |mut world, HookContext entity, component_id, caller, .. | // 可以在钩子内访问组件数据 let value = world.get::MyComponent(entity).unwrap().0; println!( component_id:? added to entity with value value:?, caller .map(|location| format!(due to location)) .unwrap_or_default() ); // 或访问资源 world .resource_mut::MyComponentIndex() .insert(value, entity); , ) // `on_insert` 将在组件插入到实体上时触发，无论实体是否已有该组件 // 如果 `on_add` 运行了，则在 `on_add` 之后运行 .on_insert(|world, _| println!(Current Index: :?, world.resource::MyComponentIndex()); ) // `on_replace` 将在组件插入到已有该组件的实体上时触发 // 在值被替换之前运行 // 当组件从实体移除时也会触发，在 `on_remove` 之前运行 .on_replace(|mut world, context| let value = world.get::MyComponent(context.entity).unwrap().0; world.resource_mut::MyComponentIndex().remove(value); ) // `on_remove` 将在组件从实体移除时触发 // 由于它在组件移除之前运行，你仍然可以访问组件数据 .on_remove( |mut world, HookContext entity, component_id, caller, .. | let value = world.get::MyComponent(entity).unwrap().0; println!( component_id:? removed from entity with value value:?, caller .map(|location| format!(due to location)) .unwrap_or_default() ); // 也可以通过 `.commands()` 发出命令 world.commands().entity(entity).despawn(); , ); 关键要点： 有 4 种组件生命周期钩子：on_add、on_insert、on_replace、on_remove 钩子可以访问 DeferredWorld 和 HookContext 钩子可以访问组件数据、资源和 Commands 钩子可以发送消息 组件必须未被使用且未注册钩子才能注册钩子 说明：组件生命周期钩子用于在组件的生命周期关键点执行逻辑。它们对于维护索引、强制执行结构规则等场景很有用。但要注意，尽可能使用 Bevy 的变更检测或事件来响应组件变化，因为事件通常提供更好的性能和更灵活的集成。 关系系统（Relationships）关系系统允许建立自定义的实体关系，类似于内置的 ChildOfChildren 关系。 源代码文件：bevy/examples/ecs/relationships.rs 代码示例： use bevy::prelude::*;/// 此实体正在瞄准的实体////// 这是关系的真实来源，可以直接修改以改变目标#[derive(Component, Debug)]#[relationship(relationship_target = TargetedBy)]struct Targeting(Entity);/// 所有正在瞄准此实体的实体////// 此组件使用派生 [`Relationship`] trait 引入的组件钩子进行响应式更新/// 我们不应该直接修改此组件，但可以安全地读取其字段#[derive(Component, Debug)]#[relationship_target(relationship = Targeting)]struct TargetedBy(VecEntity);fn spawning_entities_with_relationships(mut commands: Commands) // 调用 `.id()` 在生成实体后将返回生成实体的 `Entity` 标识符 // 即使实体本身尚未在世界中实例化 let alice = commands.spawn(Name::new(Alice)).id(); // 关系只是组件，所以我们可以将它们添加到正在生成的 bundle 中 let bob = commands.spawn((Name::new(Bob), Targeting(alice))).id(); // `with_related` 和 `with_related_entities` 辅助方法可以更符合人体工程学地添加关系 let charlie = commands .spawn((Name::new(Charlie), Targeting(bob))) // `with_related` 方法将生成一个带有 `Targeting` 关系的 bundle .with_related::Targeting(Name::new(James)) // `with_related_entities` 方法将自动将 `Targeting` 组件添加到闭包内生成的任何实体 .with_related_entities::Targeting(|related_spawner_commands| // 我们可以在这里生成多个实体，它们都会瞄准 `charlie` related_spawner_commands.spawn(Name::new(Devon)); ) .id(); // 简单地插入 `Targeting` 组件将自动创建并更新目标实体上的 `TargetedBy` 组件 // 我们可以在任何时候这样做；不仅仅是在实体生成时 commands.entity(alice).insert(Targeting(charlie)); fn mutate_relationships(name_query: Query(Entity, Name), mut commands: Commands) // 关系组件是不可变的！我们不能可变地查询 `Targeting` 组件并直接修改它 // 但我们可以插入一个新的 `Targeting` 组件来替换旧的 // 这允许 `Targeting` 组件上的钩子正确更新 `TargetedBy` 组件 // `TargetedBy` 组件将自动更新！ let devon = name_query .iter() .find(|(_entity, name)| name.as_str() == Devon) .unwrap() .0; let alice = name_query .iter() .find(|(_entity, name)| name.as_str() == Alice) .unwrap() .0; println!(Making Devon target Alice. ); commands.entity(devon).insert(Targeting(alice)); 关键要点： 使用 #[relationship(relationship_target = TargetedBy)] 定义关系组件 使用 #[relationship_target(relationship = Targeting)] 定义关系目标组件 关系组件是真实来源，可以直接修改 关系目标组件是响应式更新的，不应直接修改 使用 with_related 和 with_related_entities 辅助方法添加关系 插入关系组件会自动更新关系目标组件 说明：关系系统允许建立自定义的实体关系。Bevy 内置了 ChildOfChildren 关系用于变换和可见性传播，但你可以定义自己的关系。关系组件是真实来源，可以直接修改，而关系目标组件是响应式更新的，不应直接修改。 并行查询（Parallel Queries）并行查询使用并行迭代器提高系统执行效率。 源代码文件：bevy/examples/ecs/parallel_query.rs 代码示例： use bevy::ecs::batching::BatchingStrategy, prelude::*;#[derive(Component, Deref)]struct Velocity(Vec2);// 根据速度移动精灵fn move_system(mut sprites: Query(mut Transform, Velocity)) // 在 ComputeTaskPool 上并行计算每个精灵的新位置 // // 此示例仅用于演示目的。对于像加法这样便宜的操作，在只有 128 个元素时 // 使用 ParallelIterator 通常不会比使用普通 Iterator 更快 // 有关何时使用或不使用 ParallelIterator 的更多信息，请参阅 ParallelIterator 文档 sprites .par_iter_mut() .for_each(|(mut transform, velocity)| transform.translation += velocity.extend(0.0); );// 在窗口外反弹精灵fn bounce_system(window: QueryWindow, mut sprites: Query(Transform, mut Velocity)) let Ok(window) = window.single() else return; ; let width = window.width(); let height = window.height(); // 也可以覆盖默认批次大小 // 在这种情况下，选择批次大小为 32 以限制 ParallelIterator 的开销 sprites .par_iter_mut() .batching_strategy(BatchingStrategy::fixed(32)) .for_each(|(transform, mut v)| // ... ); 关键要点： 使用 par_iter_mut() 获取并行迭代器 使用 batching_strategy() 自定义批处理策略 并行查询适用于计算密集型操作 对于简单操作，并行查询可能不会更快 注意事项： 并行查询适用于计算密集型操作 对于简单操作，并行查询可能不会更快 可以使用 batching_strategy() 自定义批处理策略 最佳实践： 只在计算密集型操作时使用并行查询 对于简单操作，使用普通查询 根据操作复杂度调整批处理策略 查询组合（Query Combinations）查询组合用于处理实体间的交互，如碰撞检测。 源代码文件：bevy/examples/ecs/iter_combinations.rs 代码示例： use bevy::prelude::*;const GRAVITY_CONSTANT: f32 = 0.001;#[derive(Component, Default)]struct Mass(f32);#[derive(Component, Default)]struct Acceleration(Vec3);fn interact_bodies(mut query: Query(Mass, GlobalTransform, mut Acceleration)) let mut iter = query.iter_combinations_mut(); while let Some([(Mass(m1), transform1, mut acc1), (Mass(m2), transform2, mut acc2)]) = iter.fetch_next() let delta = transform2.translation() - transform1.translation(); let distance_sq: f32 = delta.length_squared(); let f = GRAVITY_CONSTANT / distance_sq; let force_unit_mass = delta * f; acc1.0 += force_unit_mass * *m2; acc2.0 -= force_unit_mass * *m1; 关键要点： 使用 iter_combinations_mut() 获取可变组合迭代器 使用 fetch_next() 获取下一对实体 查询组合会跳过重复的组合（如 (A, B) 和 (B, A)） 查询组合用于处理实体间的成对交互 注意事项： 查询组合用于处理实体间的成对交互 查询组合会跳过重复的组合 查询组合对于大量实体可能较慢 最佳实践： 使用查询组合处理碰撞检测、物理交互等场景 注意性能影响，对于大量实体考虑使用空间分区 考虑使用并行查询组合提高性能 观察者模式（Observers）观察者模式用于响应组件生命周期事件和自定义事件。 源代码文件：bevy/examples/ecs/observers.rs 代码示例： use bevy::prelude::*;#[derive(Component)]struct Mine pos: Vec2, size: f32,/// 这是一个普通的 [`Event`]。任何观察它的观察者都会在它被触发时运行#[derive(Event)]struct ExplodeMines pos: Vec2, radius: f32,/// [`EntityEvent`] 是一种专门的 [`Event`] 类型，可以针对特定实体/// 除了在触发时运行正常的顶级观察者（针对任何爆炸的实体）外/// 它还会运行针对该事件的特定实体的任何观察者#[derive(EntityEvent)]struct Explode entity: Entity,fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, (draw_shapes, handle_click)) // 观察者是在事件被触发时运行的系统 // 此观察者在 `ExplodeMines` 被触发时运行 .add_observer( |explode_mines: OnExplodeMines, mines: QueryMine, index: ResSpatialIndex, mut commands: Commands| // 访问资源 for entity in index.get_nearby(explode_mines.pos) // 运行查询 let mine = mines.get(entity).unwrap(); if mine.pos.distance(explode_mines.pos) mine.size + explode_mines.radius // 并排队命令，包括触发其他事件 // 这里我们为实体 `e` 触发 `Explode` 事件 commands.trigger(Explode entity ); , ) // 此观察者在 `Mine` 组件添加到实体时运行，并将其放置在简单的空间索引中 .add_observer(on_add_mine) // 此观察者在 `Mine` 组件从实体移除时运行（包括销毁它） // 并将其从空间索引中移除 .add_observer(on_remove_mine) .run();fn on_add_mine(add: OnAdd, Mine, query: QueryMine, mut index: ResMutSpatialIndex) let mine = query.get(add.entity).unwrap(); let tile = ( (mine.pos.x / CELL_SIZE).floor() as i32, (mine.pos.y / CELL_SIZE).floor() as i32, ); index.map.entry(tile).or_default().insert(add.entity);fn on_remove_mine(remove: OnRemove, Mine, query: QueryMine, mut index: ResMutSpatialIndex) let mine = query.get(remove.entity).unwrap(); let tile = ( (mine.pos.x / CELL_SIZE).floor() as i32, (mine.pos.y / CELL_SIZE).floor() as i32, ); index.map.entry(tile).and_modify(|set| set.remove(remove.entity); ); 关键要点： 观察者用于响应组件生命周期事件和自定义事件 使用 OnAdd, T 响应组件添加 使用 OnRemove, T 响应组件移除 使用 OnEvent 响应自定义事件 观察者可以访问资源、运行查询、发出命令 注意事项： 观察者用于响应组件生命周期事件和自定义事件 观察者可以访问资源、运行查询、发出命令 观察者比组件钩子更灵活，但开销更大 最佳实践： 使用观察者响应组件生命周期事件 使用观察者响应自定义事件 考虑性能影响，观察者可能比组件钩子更灵活但开销更大 进阶用法消息系统（Messages）消息系统用于实现系统间通信。 源代码文件：bevy/examples/ecs/message.rs 代码示例： use bevy::prelude::*;/// 这是一个 [`Message`]，任何观察它的观察者都会在它被激活时运行#[derive(Message)]struct MyMessage;fn main() App::new() .add_plugins(DefaultPlugins) .add_message::MyMessage() .add_systems(Startup, setup) .add_systems(Update, send_message) .add_observer(receive_message) .run();fn send_message(mut commands: Commands) // 发送消息 commands.write_message(MyMessage);fn receive_message(_message: OnMyMessage) info!(Message received!); 关键要点： 使用 Message 派生宏定义消息 使用 add_message() 注册消息 使用 write_message() 发送消息 使用观察者接收消息 注意事项： 消息系统用于实现系统间通信 消息可以用于事件驱动逻辑 注意消息系统的性能影响 最佳实践： 对于系统间通信，使用消息系统 对于事件驱动逻辑，使用消息系统 注意消息系统的性能影响 错误处理系统可以返回 Result 来处理错误。 源代码文件：bevy/examples/ecs/error_handling.rs 代码示例： use bevy::ecs::error::warn;fn main() let mut app = App::new(); // 默认情况下，返回错误的可失败系统会 panic // // 我们可以通过设置自定义错误处理器来改变这一点 // 它适用于整个应用 // 这里我们使用内置错误处理器之一 app.set_error_handler(warn); app.add_plugins(DefaultPlugins); app.add_systems(Startup, setup); // 单个系统也可以通过管道输出结果来处理： app.add_systems( PostStartup, failing_system.pipe(|result: InResult| let _ = result.0.inspect_err(|err| info!(captured error: err)); ), ); app.run();/// 这个系统总是失败验证，因为我们从未创建同时具有 `Player` 和 `Enemy` 组件的实体fn failing_system(world: mut World) - Result world // `get_resource` 返回 `OptionT`，所以我们使用 `ok_or` 将其转换为 `Result` // 然后我们可以调用 `?` 来传播错误 .get_resource::UninitializedResource() // 我们可以在这里提供 `str`，因为 `BevyError` 实现了 `Fromstr` .ok_or(Resource not initialized)?; Ok(()) 关键要点： 系统可以返回 Result(), BevyError 来处理错误 使用 set_error_handler() 设置错误处理器 使用 .pipe() 方法处理系统错误 可失败系统可以用于错误处理 注意事项： 默认情况下，返回错误的系统会 panic 可以设置自定义错误处理器 系统错误可以通过管道处理 最佳实践： 对于可能失败的操作，使用可失败系统 设置适当的错误处理器 使用系统管道处理错误 动态 ECS动态 ECS 允许动态创建组件和实体。 源代码文件：bevy/examples/ecs/dynamic.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, query_dynamic_components) .run();fn setup(mut commands: Commands, mut world: mut World) // 动态创建组件 let component_id = world.register_component_with_descriptor(ComponentDescriptor::new( MyDynamicComponent, StorageType::Table, )); // 使用动态组件创建实体 let entity = commands.spawn_empty().id(); commands.entity(entity).insert_by_id(component_id, MyData(42));fn query_dynamic_components(world: mut World, component_id: ComponentId) // 查询动态组件 let query = Query::new((component_id,)); for (data,) in query.iter(world) // ... 关键要点： 使用 register_component_with_descriptor() 动态创建组件 使用 insert_by_id() 插入动态组件 使用 Query 查询动态组件 动态 ECS 可以用于运行时创建组件 注意事项： 动态 ECS 允许运行时创建组件 动态 ECS 可以用于插件系统 注意动态 ECS 的性能影响 最佳实践： 对于需要运行时创建组件的场景，使用动态 ECS 对于插件系统，使用动态 ECS 注意动态 ECS 的性能影响 实际应用在游戏开发中的应用场景ECS 进阶功能在游戏开发中有广泛的应用： 性能优化：使用并行查询提高系统执行效率 变更响应：使用变更检测和观察者响应组件变化 关系管理：使用关系系统建立实体间的复杂关系 生命周期管理：使用组件钩子管理组件的生命周期 事件驱动：使用消息系统和观察者实现事件驱动逻辑 常见问题问题 1：何时使用变更检测，何时使用观察者？ 解决方案： 变更检测适用于需要查询已变更组件的场景 观察者适用于需要响应组件生命周期事件的场景 对于简单场景，优先使用变更检测 问题 2：并行查询何时更快？ 解决方案： 并行查询适用于计算密集型操作 对于简单操作，并行查询可能不会更快 需要根据实际情况测试性能 问题 3：如何优化查询组合的性能？ 解决方案： 使用空间分区减少需要检查的实体对 使用查询过滤器减少查询的实体数量 考虑使用并行查询组合 性能考虑 并行查询：只在计算密集型操作时使用 查询组合：注意性能影响，考虑使用空间分区 观察者：考虑性能开销，优先使用变更检测 组件钩子：比观察者开销更小，但灵活性较低 相关资源相关源代码文件： bevy/examples/ecs/change_detection.rs - 变更检测示例 bevy/examples/ecs/component_hooks.rs - 组件生命周期钩子示例 bevy/examples/ecs/relationships.rs - 关系系统示例 bevy/examples/ecs/parallel_query.rs - 并行查询示例 bevy/examples/ecs/iter_combinations.rs - 查询组合示例 bevy/examples/ecs/observers.rs - 观察者模式示例 bevy/examples/ecs/removal_detection.rs - 移除检测示例 bevy/examples/ecs/message.rs - 消息系统示例 bevy/examples/ecs/error_handling.rs - 错误处理示例 bevy/examples/ecs/dynamic.rs - 动态 ECS 示例 官方文档链接： Bevy ECS 官方文档 变更检测文档 关系系统文档 观察者文档 进一步学习建议： 学习 Bevy 的其他高级功能，如自定义系统参数、系统调度等 阅读 Bevy ECS 源码，深入理解实现原理 实践编写自己的高级 ECS 系统，加深理解 索引：返回上级目录"},{"title":"自定义渲染","path":"/Luo-Haomin/wiki/BevyBook/Advanced/自定义渲染.html","content":"自定义渲染概述学习目标： 理解 Bevy 渲染系统的基本概念 掌握自定义材质的创建 学会编写自定义着色器（WGSL） 了解自定义后处理效果的实现 理解自定义渲染阶段和实例化 前置知识要求： 3D 渲染基础 着色器基础 WGSL 语言基础 渲染管线基础 核心概念什么是自定义渲染？自定义渲染是在 Bevy 默认渲染系统基础上，创建自定义的渲染效果。这包括自定义材质、自定义着色器、自定义后处理效果等。 为什么需要自定义渲染？ 特殊效果：实现默认渲染系统不支持的特殊效果 性能优化：针对特定场景优化渲染性能 艺术风格：实现特定的艺术风格和视觉效果 扩展功能：扩展 Bevy 的渲染功能 自定义渲染的核心组件Bevy 自定义渲染系统包含以下核心组件： Material：材质系统，用于定义材质属性 Shader：着色器，用于定义渲染逻辑 RenderGraph：渲染图，用于组织渲染管线 RenderPhase：渲染阶段，用于组织渲染对象 Instancing：实例化，用于批量渲染 基础用法自定义材质创建自定义材质。 源代码文件：bevy/examples/shader_advanced/custom_post_processing.rs 代码示例： use bevy:: prelude::*, render:: extract_component:: ExtractComponent, ExtractComponentPlugin, UniformComponentPlugin, , render_resource::*, ,;#[derive(Component, Clone, Copy)]struct PostProcessSettings intensity: f32,impl ExtractComponent for PostProcessSettings type Query = static Self; type Filter = (); type Out = Self; fn extract_component(item: QueryItemSelf::Query) - OptionSelf::Out Some(*item) fn main() App::new() .add_plugins(DefaultPlugins) .add_plugins(ExtractComponentPlugin::PostProcessSettings::default()) .add_plugins(UniformComponentPlugin::PostProcessSettings::default()) .run(); 关键要点： 使用 ExtractComponent trait 提取组件到渲染世界 使用 UniformComponentPlugin 将组件数据传递到 GPU 材质数据通过 uniform buffer 传递到着色器 可以在主世界控制材质属性 说明：自定义材质允许你创建自己的材质类型。通过 ExtractComponent 和 UniformComponentPlugin，可以将主世界的组件数据传递到渲染世界，并在着色器中使用。 自定义着色器（WGSL）编写自定义着色器。 源代码文件：bevy/examples/shader_advanced/custom_post_processing.rs 着色器示例： #import bevy_core_pipeline::tonemapping::tone_mapping@group(0) @binding(0)varuniform settings: PostProcessSettings;@group(0) @binding(1)var main_texture: texture_2df32;@group(0) @binding(2)var main_texture_sampler: sampler;@fragmentfn fragment(in: FragmentInput) - @location(0) vec4f32 let color = textureSample(main_texture, main_texture_sampler, in.uv); let tone_mapped = tone_mapping(color); return vec4f32(tone_mapped * settings.intensity, 1.0); 关键要点： 使用 WGSL 编写着色器 通过 uniform buffer 访问材质数据 使用 textureSample 采样纹理 可以应用后处理效果 说明：自定义着色器允许你实现自己的渲染逻辑。Bevy 使用 WGSL 作为着色器语言，支持现代图形 API。 自定义后处理效果创建自定义后处理效果。 源代码文件：bevy/examples/shader_advanced/custom_post_processing.rs 代码示例： use bevy:: core_pipeline::core_3d::graph::Core3d, Node3d, prelude::*, render:: render_graph::RenderGraphContext, RenderLabel, ViewNode, ViewNodeRunner, render_resource::*, RenderApp, RenderStartup, ,;#[derive(RenderLabel)]struct PostProcessLabel;struct PostProcessNode;impl ViewNode for PostProcessNode type ViewQuery = ( static ViewTarget, static PostProcessSettings, ); fn run( self, _graph: mut RenderGraphContext, render_context: mut RenderContext, (view_target, settings): QueryItemSelf::ViewQuery, world: World, ) - Result(), NodeRunError // 实现后处理逻辑 Ok(()) fn init_post_process_pipeline(mut render_app: ResMutRenderApp) render_app .add_render_graph_node::ViewNodeRunnerPostProcessNode( Core3d, PostProcessLabel, ) .add_render_graph_edges( Core3d, ( Node3d::Tonemapping, PostProcessLabel, Node3d::EndMainPassPostProcessing, ), ); 关键要点： 使用 ViewNode trait 创建自定义渲染节点 使用 RenderGraph 组织渲染管线 通过 ViewTarget 访问渲染目标 可以读取和写入渲染纹理 说明：自定义后处理效果允许你在渲染完成后对图像进行处理。通过 ViewNode 和 RenderGraph，可以创建自己的后处理管线。 自定义顶点属性创建自定义顶点属性。 源代码文件：bevy/examples/shader_advanced/custom_vertex_attribute.rs 关键信息： 使用 MeshVertexAttribute 定义自定义顶点属性 在着色器中访问自定义顶点属性 可以传递额外的顶点数据到着色器 说明：自定义顶点属性允许你传递额外的顶点数据到着色器。这对于实现特殊效果非常有用。 自定义实例化实现自定义实例化渲染。 源代码文件：bevy/examples/shader_advanced/custom_shader_instancing.rs 关键信息： 使用实例化渲染批量绘制相同对象 通过实例数据传递每个实例的属性 可以显著提高渲染性能 说明：自定义实例化允许你批量渲染相同对象，每个实例可以有不同的属性。这对于渲染大量相似对象非常有用。 自定义渲染阶段创建自定义渲染阶段。 源代码文件：bevy/examples/shader_advanced/custom_render_phase.rs 关键信息： 使用 RenderPhase 组织渲染对象 可以创建自己的渲染阶段 可以控制渲染顺序和方式 说明：自定义渲染阶段允许你组织渲染对象，控制渲染顺序和方式。这对于实现复杂的渲染效果非常有用。 进阶用法高级着色器技术使用高级着色器技术。 关键信息： 使用计算着色器进行 GPU 计算 使用纹理数组和采样器数组 实现复杂的渲染效果 说明：高级着色器技术可以让你实现更复杂的渲染效果。通过计算着色器和高级纹理技术，可以实现各种视觉效果。 渲染管线优化优化自定义渲染管线。 关键信息： 减少渲染目标切换 优化着色器性能 使用批处理和实例化 合理使用渲染阶段 说明：渲染管线优化可以提高自定义渲染的性能。通过减少状态切换、优化着色器、使用批处理等技术，可以显著提高性能。 实际应用在游戏开发中的应用场景自定义渲染在游戏开发中有广泛的应用： 特殊效果：实现水、火、烟雾等特殊效果 艺术风格：实现卡通、像素等艺术风格 后处理：实现泛光、色差、色调映射等后处理效果 性能优化：针对特定场景优化渲染性能 常见问题问题 1：如何创建自定义材质？ 解决方案：实现 Material trait，使用 ExtractComponent 和 UniformComponentPlugin 将数据传递到 GPU。 问题 2：如何编写自定义着色器？ 解决方案：使用 WGSL 编写着色器，通过 uniform buffer 访问材质数据，使用 textureSample 采样纹理。 问题 3：如何实现自定义后处理效果？ 解决方案：使用 ViewNode trait 创建自定义渲染节点，通过 RenderGraph 组织渲染管线。 性能考虑 着色器优化：优化着色器代码，减少计算量 批处理：使用批处理和实例化减少绘制调用 纹理优化：合理使用纹理格式和大小 渲染目标：减少渲染目标切换 相关资源相关源代码文件： bevy/examples/shader_advanced/custom_post_processing.rs - 自定义后处理示例 bevy/examples/shader_advanced/custom_vertex_attribute.rs - 自定义顶点属性示例 bevy/examples/shader_advanced/custom_shader_instancing.rs - 自定义实例化示例 bevy/examples/shader_advanced/custom_render_phase.rs - 自定义渲染阶段示例 bevy/examples/shader_advanced/specialized_mesh_pipeline.rs - 专用网格管线示例 官方文档链接： Bevy 渲染系统文档 WGSL 规范 着色器示例 进一步学习建议： 学习 WGSL 语言，了解着色器编程 学习渲染管线，了解渲染流程 学习性能优化，了解如何优化自定义渲染 索引：返回上级目录"},{"title":"ECS（实体组件系统）","path":"/Luo-Haomin/wiki/BevyBook/ECS/README.html","content":"ECS（实体组件系统）ECS 是 Bevy 的核心编程范式。理解 ECS 是掌握 Bevy 的关键。 内容列表1. 核心编程框架（ECS） ECS 概述 为什么使用 ECS ECS 的核心概念 Bevy ECS 的特点 学习目标：理解 ECS 的基本概念和优势 2. 组件（Components） 定义组件 组件类型 组件生命周期 组件存储 不可变组件 学习目标：能够定义和使用组件 3. 实体（Entities） 创建实体 实体 ID 实体操作 实体禁用 实体层次结构 学习目标：能够创建和操作实体 4. 命令（Commands） Commands 概念 创建实体 操作实体 管理资源 注册和运行系统 触发事件 发送消息 实体层次结构 学习目标：能够使用 Commands 安全地修改世界 5. 系统（Systems） 定义系统 系统参数 系统闭包 泛型系统 一次性系统 系统管道 独占系统 可失败系统参数 系统错误处理 学习目标：能够定义和使用系统 6. 查询（Queries） 基本查询 查询过滤器 自定义查询参数 查询组合 并行查询 学习目标：能够使用查询访问组件 7. 资源（Resources） 定义资源 访问资源 资源初始化 资源生命周期 资源变更检测 学习目标：能够定义和使用资源 8. 系统调度（Schedule App） Schedule 概念 系统执行顺序 系统集（SystemSet） 自定义 Schedule 固定时间步 运行条件 系统步进 非确定性系统顺序 学习目标：能够控制系统执行顺序和应用生命周期 9. ECS 进阶 变更检测（Change Detection） 检测组件变化 检测资源变化 变更检测方法 组件生命周期钩子（Component Hooks） 定义钩子 钩子类型 钩子应用场景 关系系统（Relationships） 定义自定义关系 使用关系 关系遍历 并行查询（Parallel Queries） 并行迭代器 批处理策略 性能优化 查询组合（Query Combinations） 实体间交互 组合查询方法 观察者模式（Observers） 响应组件生命周期事件 响应自定义事件 消息系统（Messages） 定义消息 发送和接收消息 错误处理（Error Handling） 系统错误处理 错误处理器 动态 ECS（Dynamic ECS） 动态创建组件 动态创建实体 学习目标：掌握 ECS 的高级功能和最佳实践 学习建议 理解概念：ECS 是一种新的编程范式，需要时间适应 多写代码：通过实践加深理解 阅读示例：查看 Bevy 官方示例中的 ECS 用法 思考设计：思考如何用 ECS 思维设计游戏逻辑 学习路径建议按照以下顺序学习： 核心编程框架（ECS）：理解 ECS 的基本概念和优势 组件（Components）：学习如何定义和使用组件 实体（Entities）：学习如何创建和操作实体 命令（Commands）：学习如何使用 Commands 安全地修改世界 系统（Systems）：学习如何定义和使用系统 查询（Queries）：学习如何使用查询访问组件 资源（Resources）：学习如何定义和使用资源 系统调度（Schedule App）：学习如何控制系统执行顺序和应用生命周期 ECS 进阶：掌握高级功能和最佳实践 每个章节都基于 Bevy 官方示例编写，确保内容的准确性和实用性。 相关资源 Bevy ECS 官方文档 ECS 设计模式 Bevy ECS 示例 下一步完成本部分学习后，建议继续学习： Assets（资源管理） - 学习如何加载和管理资源 Input（输入处理） - 处理用户输入 索引：返回主目录"},{"title":"命令（Commands）","path":"/Luo-Haomin/wiki/BevyBook/ECS/命令（Commands）.html","content":"命令（Commands）概述学习目标： 理解 Commands 的概念和作用 掌握如何使用 Commands 修改世界 了解 Commands 的各种操作方法 理解 Commands 的执行时机 前置知识要求： 核心编程框架（ECS） 组件（Components） 实体（Entities） 系统（Systems） Rust 基础语法 核心概念什么是 Commands？Commands 是一种安全的方式来修改世界（World）。由于系统可以并行执行，直接访问世界是不安全的。Commands 将修改操作排队，在系统执行完成后统一应用。 为什么使用 Commands？ 线程安全：Commands 允许系统安全地修改世界，即使系统并行执行 延迟执行：Commands 将修改操作排队，在系统执行完成后统一应用 命令缓冲：Commands 提供命令缓冲，允许批量操作 Commands 的设计思想Commands 采用命令模式，将修改操作封装为命令，在系统执行完成后统一应用。这种设计使得： 系统可以并行执行，同时安全地修改世界 修改操作可以延迟执行，提高性能 修改操作可以批量处理，减少开销 基础用法创建实体使用 spawn() 和 spawn_batch() 创建实体。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： fn startup_system(mut commands: Commands, mut game_state: ResMutGameState) // 创建游戏规则资源 commands.insert_resource(GameRules max_rounds: 10, winning_score: 4, max_players: 4, ); // 向我们的世界添加一些玩家。玩家从分数 0 开始 commands.spawn_batch(vec![ ( Player name: Alice.to_string(), , Score value: 0 , PlayerStreak::None, ), ( Player name: Bob.to_string(), , Score value: 0 , PlayerStreak::None, ), ]); // 设置总玩家数为 2 game_state.total_players = 2;// 这个系统使用命令缓冲区（可能）在每次迭代时向我们的游戏添加一个新玩家// 普通系统不能安全地直接访问 World 实例，因为它们并行运行// 我们的 World 包含所有组件，所以并行修改其任意部分不是线程安全的// 命令缓冲区使我们能够在不直接访问的情况下排队对 World 的更改fn new_player_system( mut commands: Commands, game_rules: ResGameRules, mut game_state: ResMutGameState,) // 随机添加一个新玩家 let add_new_player = random::bool(); if add_new_player game_state.total_players game_rules.max_players game_state.total_players += 1; commands.spawn(( Player name: format!(Player , game_state.total_players), , Score value: 0 , PlayerStreak::None, )); println!(Player joined the game!, game_state.total_players); 关键要点： 使用 spawn() 创建单个实体 使用 spawn_batch() 批量创建实体 可以在创建实体时同时添加多个组件 Commands 将修改操作排队，在系统执行完成后统一应用 说明：Commands 提供了一种安全的方式来修改世界。由于系统可以并行执行，直接访问世界是不安全的。Commands 将修改操作排队，在系统执行完成后统一应用。 操作实体使用 entity() 方法获取实体命令，然后可以插入、移除组件或销毁实体。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 调用 `.id()` 在生成实体后将返回生成实体的 `Entity` 标识符// 即使实体本身尚未在世界中实例化// 这有效是因为 Commands 会在实际生成实体之前通过原子计数器保留实体 IDlet alice = commands.spawn(Name::new(Alice)).id();let bob = commands.spawn((Name::new(Bob), Targeting(alice))).id();// 使用 entity() 方法获取实体命令commands.entity(alice).insert(Targeting(bob)); 源代码文件：bevy/examples/ecs/entity_disabling.rs 代码示例： fn disable_entities_on_click( click: OnPointerClick, valid_query: QueryDisableOnClick, mut commands: Commands,) if valid_query.contains(click.entity) // 只需将 `Disabled` 组件添加到实体即可禁用它 commands.entity(click.entity).insert(Disabled); fn reenable_entities_on_space( mut commands: Commands, disabled_entities: QueryEntity, WithDisabled, input: ResButtonInputKeyCode,) if input.just_pressed(KeyCode::Space) for entity in disabled_entities.iter() // 要重新启用实体，只需移除 `Disabled` 组件 commands.entity(entity).remove::Disabled(); 源代码文件：bevy/examples/ecs/fallible_params.rs 代码示例： fn user_input( mut commands: Commands, enemies: QueryEntity, WithEnemy, keyboard_input: ResButtonInputKeyCode, asset_server: ResAssetServer,) if keyboard_input.just_pressed(KeyCode::KeyR) let Some(entity) = enemies.iter().next() // 使用 despawn() 销毁实体 commands.entity(entity).despawn(); 关键要点： 使用 entity() 方法获取实体命令 使用 insert() 方法插入组件 使用 remove() 方法移除组件 使用 despawn() 方法销毁实体 可以链式调用多个操作 说明：entity() 方法返回一个 EntityCommands，可以用于操作实体。可以链式调用多个操作，如 commands.entity(entity).insert(component).remove::OtherComponent()。 管理资源使用 insert_resource() 和 init_resource() 管理资源。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： fn startup_system(mut commands: Commands, mut game_state: ResMutGameState) // 创建游戏规则资源 commands.insert_resource(GameRules max_rounds: 10, winning_score: 4, max_players: 4, ); 关键要点： 使用 insert_resource() 插入资源 使用 init_resource() 初始化资源（需要实现 Default 或 FromWorld trait） 资源可以在系统运行时插入或初始化 说明：Commands 可以用于管理资源。使用 insert_resource() 可以插入资源，使用 init_resource() 可以初始化资源。 进阶用法注册和运行系统使用 register_system() 和 run_system() 注册和运行一次性系统。 源代码文件：bevy/examples/ecs/one_shot_systems.rs 代码示例： use bevy:: ecs::system::RunSystemOnce, SystemId, prelude::*,;#[derive(Component)]struct Callback(SystemId);fn setup_with_commands(mut commands: Commands) // 注册系统并获取系统 ID let system_id = commands.register_system(system_a); commands.spawn((Callback(system_id), A));/// 如果实体也有 `Triggered` 组件，则运行与每个 `Callback` 组件关联的系统fn evaluate_callbacks(query: Query(Entity, Callback), WithTriggered, mut commands: Commands) for (entity, callback) in query.iter() // 运行一次性系统 commands.run_system(callback.0); commands.entity(entity).remove::Triggered(); 关键要点： 使用 register_system() 注册系统并获取系统 ID 使用 run_system() 运行一次性系统 一次性系统在触发时运行一次，而不是每次更新都运行 一次性系统可以用于推送式逻辑 注意事项： 一次性系统在触发时运行一次 一次性系统可以减少很少运行的系统开销 一次性系统可以提高调度灵活性 最佳实践： 对于很少运行的系统，使用一次性系统 对于事件驱动的逻辑，使用一次性系统 注意一次性系统的生命周期管理 触发事件使用 trigger() 方法触发事件。 源代码文件：bevy/examples/ecs/observers.rs 代码示例： /// [`EntityEvent`] 是一种专门的 [`Event`] 类型，可以针对特定实体/// 除了在触发时运行正常的顶级观察者（针对任何爆炸的实体）外/// 它还会运行针对该事件的特定实体的任何观察者#[derive(EntityEvent)]struct Explode entity: Entity,fn main() App::new() .add_plugins(DefaultPlugins) .add_observer( |explode_mines: OnExplodeMines, mines: QueryMine, index: ResSpatialIndex, mut commands: Commands| for entity in index.get_nearby(explode_mines.pos) let mine = mines.get(entity).unwrap(); if mine.pos.distance(explode_mines.pos) mine.size + explode_mines.radius // 触发事件 commands.trigger(Explode entity ); , ) .run(); 关键要点： 使用 trigger() 方法触发事件 事件可以是普通事件或实体事件 实体事件可以针对特定实体 观察者会响应触发的事件 注意事项： 事件可以是普通事件或实体事件 实体事件可以针对特定实体 观察者会响应触发的事件 最佳实践： 对于事件驱动的逻辑，使用事件 对于需要针对特定实体的逻辑，使用实体事件 注意事件的性能影响 发送消息使用 write_message() 方法发送消息。 源代码文件：bevy/examples/ecs/message.rs 代码示例： /// 这是一个 [`Message`]，任何观察它的观察者都会在它被激活时运行#[derive(Message)]struct MyMessage;fn send_message(mut commands: Commands) // 发送消息 commands.write_message(MyMessage);fn receive_message(_message: OnMyMessage) info!(Message received!); 关键要点： 使用 write_message() 方法发送消息 消息需要实现 Message trait 观察者会响应发送的消息 消息可以用于系统间通信 注意事项： 消息需要实现 Message trait 观察者会响应发送的消息 消息可以用于系统间通信 最佳实践： 对于系统间通信，使用消息 对于事件驱动逻辑，使用消息 注意消息的性能影响 实体层次结构使用 with_children() 和 add_child() 管理实体层次结构。 源代码文件：bevy/examples/ecs/hierarchy.rs 代码示例： fn setup(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Camera2d); let texture = asset_server.load(branding/icon.png); // 生成一个没有父实体的根实体 let parent = commands .spawn(( Sprite::from_image(texture.clone()), Transform::from_scale(Vec3::splat(0.75)), )) // 以该实体作为父实体，运行一个 lambda 来生成其子实体 .with_children(|parent| // parent 是一个 ChildSpawnerCommands，具有与 Commands 类似的 API parent.spawn(( Transform::from_xyz(250.0, 0.0, 0.0).with_scale(Vec3::splat(0.75)), Sprite image: texture.clone(), color: BLUE.into(), ..default() , )); ) .id(); // 另一种方法是使用 add_child 函数在父实体已经生成后添加子实体 let child = commands .spawn(( Sprite image: texture, color: LIME.into(), ..default() , Transform::from_xyz(0.0, 250.0, 0.0).with_scale(Vec3::splat(0.75)), )) .id(); // 将子实体添加到父实体 commands.entity(parent).add_child(child); 关键要点： 使用 with_children() 方法在创建实体时添加子实体 使用 add_child() 方法在实体创建后添加子实体 使用 remove_child() 方法移除子实体 销毁父实体会自动销毁所有子实体 注意事项： 层次结构通过 ChildOf 和 Children 组件实现 销毁父实体会自动销毁所有子实体 可以通过移除 ChildOf 组件来断开父子关系 最佳实践： 使用层次结构组织相关的实体 注意层次结构对变换和可见性传播的影响 合理使用层次结构，避免过深的嵌套 实际应用在游戏开发中的应用场景Commands 在游戏开发中有广泛的应用： 实体创建：创建玩家、敌人、道具等游戏对象 组件管理：添加、移除、修改组件 资源管理：插入和初始化资源 事件驱动：触发事件和发送消息 系统管理：注册和运行一次性系统 常见问题问题 1：Commands 何时执行？ 解决方案：Commands 在系统执行完成后统一应用。这意味着在系统执行期间，Commands 的修改不会立即生效。 问题 2：如何获取刚创建的实体 ID？ 解决方案：使用 .id() 方法在创建实体后立即获取实体 ID。即使实体本身尚未在世界中实例化，也可以获取 ID。 问题 3：Commands 和直接访问 World 有什么区别？ 解决方案： Commands 是线程安全的，可以在并行系统中使用 直接访问 World 需要独占系统，会阻止并行执行 Commands 将修改操作排队，在系统执行完成后统一应用 性能考虑 命令缓冲：Commands 将修改操作排队，批量处理，减少开销 延迟执行：Commands 的修改在系统执行完成后统一应用，提高性能 批量操作：使用 spawn_batch() 批量创建实体，比逐个创建更高效 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例（Commands 使用） bevy/examples/ecs/one_shot_systems.rs - 一次性系统示例（注册和运行系统） bevy/examples/ecs/observers.rs - 观察者模式示例（触发事件） bevy/examples/ecs/hierarchy.rs - 实体层次结构示例（管理层次结构） bevy/examples/ecs/entity_disabling.rs - 实体禁用示例（操作实体） 官方文档链接： Bevy Commands 官方文档 EntityCommands 文档 进一步学习建议： 学习实体（Entities），了解如何创建和操作实体 学习系统（Systems），了解如何在系统中使用 Commands 学习 ECS 进阶，了解 Commands 的高级功能 索引：返回上级目录"},{"title":"实体（Entities）","path":"/Luo-Haomin/wiki/BevyBook/ECS/实体（Entities）.html","content":"实体（Entities）概述学习目标： 理解实体的概念和作用 掌握如何创建和操作实体 了解实体 ID 的使用方法 理解实体禁用和层次结构 前置知识要求： 核心编程框架（ECS） 组件（Components） Rust 基础语法 核心概念什么是实体？实体是具有唯一 ID 的组件集合。实体本身不包含任何数据，它只是一个标识符，用于将组件组合在一起。 为什么使用实体？ 灵活组合：实体可以灵活组合不同的组件 唯一标识：每个实体都有唯一的 ID 高效查询：通过实体 ID 可以快速访问组件 实体的设计思想实体采用数据导向的设计思想，将数据（组件）和标识符（实体）分离。这种设计使得： 实体可以灵活组合不同的组件 系统可以高效查询具有特定组件的实体 实体可以动态添加和移除组件 基础用法创建实体使用 Commands 创建实体并添加组件。关于 Commands 的详细使用方法，请参考命令（Commands）章节。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 这是一个启动系统，在应用启动时恰好运行一次// 启动系统通常用于创建游戏的初始状态fn startup_system(mut commands: Commands, mut game_state: ResMutGameState) // 向我们的世界添加一些玩家。玩家从分数 0 开始 commands.spawn_batch(vec![ ( Player name: Alice.to_string(), , Score value: 0 , PlayerStreak::None, ), ( Player name: Bob.to_string(), , Score value: 0 , PlayerStreak::None, ), ]); // 设置总玩家数为 2 game_state.total_players = 2; 关键要点： 使用 Commands 创建实体 使用 spawn() 创建单个实体 使用 spawn_batch() 批量创建实体 可以在创建实体时同时添加多个组件 说明：实体通过 Commands 创建。Commands 提供了一种安全的方式来修改世界，允许系统并行执行。关于 Commands 的详细使用方法，请参考命令（Commands）章节。 实体 ID每个实体都有唯一的 ID，可以通过 .id() 方法获取。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 调用 `.id()` 在生成实体后将返回生成实体的 `Entity` 标识符// 即使实体本身尚未在世界中实例化// 这有效是因为 Commands 会在实际生成实体之前通过原子计数器保留实体 IDlet alice = commands.spawn(Name::new(Alice)).id();let bob = commands.spawn((Name::new(Bob), Targeting(alice))).id(); 关键要点： 使用 .id() 方法获取实体 ID 实体 ID 在实体创建之前就可以获取 实体 ID 是唯一的，可以用于引用实体 实体 ID 可以存储在组件中，用于建立实体间的关系 说明：实体 ID 是实体的唯一标识符。即使在实体创建之前，也可以通过 Commands 获取实体 ID。这使得可以在创建实体时建立实体间的关系。 进阶用法实体禁用实体禁用允许你隐藏实体而不删除它们。这对于实现”休眠”对象或管理网络实体很有用。 源代码文件：bevy/examples/ecs/entity_disabling.rs 代码示例： use bevy::ecs::entity_disabling::Disabled;use bevy::prelude::*;fn disable_entities_on_click( click: OnPointerClick, valid_query: QueryDisableOnClick, mut commands: Commands,) if valid_query.contains(click.entity) // 只需将 `Disabled` 组件添加到实体即可禁用它 // 注意 `Disabled` 组件只添加到实体本身，其子实体不受影响 commands.entity(click.entity).insert(Disabled); // 这里的查询不会找到具有 `Disabled` 组件的实体// 因为它没有明确包含它fn list_all_named_entities( query: QueryName, mut name_text_query: Querymut Text, WithEntityNameText, mut commands: Commands,) // 查询会自动跳过被禁用的实体 for name in query.iter().sort::Name() // ... fn reenable_entities_on_space( mut commands: Commands, // 这个查询可以找到被禁用的实体 // 因为它明确包含了 `Disabled` 组件 disabled_entities: QueryEntity, WithDisabled, input: ResButtonInputKeyCode,) if input.just_pressed(KeyCode::Space) for entity in disabled_entities.iter() // 要重新启用实体，只需移除 `Disabled` 组件 commands.entity(entity).remove::Disabled(); 关键要点： 使用 Disabled 组件禁用实体 被禁用的实体会被默认查询过滤器跳过 可以通过明确包含 Disabled 组件来查询被禁用的实体 禁用实体不会影响其子实体 注意事项： 禁用实体会使它们对 ECS 不可见，但这不是其主要目的 Visibility 应该用于隐藏实体 被禁用的实体会被完全跳过，这可能导致微妙的错误 最佳实践： 使用 Visibility 隐藏实体 使用 Disabled 禁用不需要处理的实体 注意禁用实体对查询的影响 实体层次结构实体可以形成层次结构，通过 ChildOf 和 Children 组件实现父子关系。 源代码文件：bevy/examples/ecs/hierarchy.rs 代码示例： fn setup(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Camera2d); let texture = asset_server.load(branding/icon.png); // 生成一个没有父实体的根实体 let parent = commands .spawn(( Sprite::from_image(texture.clone()), Transform::from_scale(Vec3::splat(0.75)), )) // 以该实体作为父实体，运行一个 lambda 来生成其子实体 .with_children(|parent| // parent 是一个 ChildSpawnerCommands，具有与 Commands 类似的 API parent.spawn(( Transform::from_xyz(250.0, 0.0, 0.0).with_scale(Vec3::splat(0.75)), Sprite image: texture.clone(), color: BLUE.into(), ..default() , )); ) .id(); // 另一种方法是使用 add_child 函数在父实体已经生成后添加子实体 let child = commands .spawn(( Sprite image: texture, color: LIME.into(), ..default() , Transform::from_xyz(0.0, 250.0, 0.0).with_scale(Vec3::splat(0.75)), )) .id(); // 将子实体添加到父实体 commands.entity(parent).add_child(child);// 一个简单的系统来旋转根实体，并分别旋转其所有子实体fn rotate( mut commands: Commands, time: ResTime, mut parents_query: Query(Entity, Children), WithSprite, mut transform_query: Querymut Transform, WithSprite,) for (parent, children) in mut parents_query if let Ok(mut transform) = transform_query.get_mut(parent) transform.rotate_z(-PI / 2. * time.delta_secs()); // 要遍历实体的子实体，只需将 Children 组件视为 Vec // 或者，你可以查询具有 ChildOf 组件的实体 for child in children if let Ok(mut transform) = transform_query.get_mut(*child) transform.rotate_z(PI * time.delta_secs()); 关键要点： 使用 with_children() 方法在创建实体时添加子实体 使用 add_child() 方法在实体创建后添加子实体 使用 Children 组件访问子实体列表 使用 ChildOf 组件访问父实体 当添加 DefaultPlugins 时，系统会自动传播 Transform 和 Visibility 从父实体到子实体 注意事项： 层次结构通过 ChildOf 和 Children 组件实现 销毁父实体会自动销毁所有子实体 可以通过移除 ChildOf 组件来断开父子关系 最佳实践： 使用层次结构组织相关的实体 注意层次结构对变换和可见性传播的影响 合理使用层次结构，避免过深的嵌套 实际应用在游戏开发中的应用场景实体在游戏开发中有广泛的应用： 游戏对象：玩家、敌人、道具等游戏对象都是实体 层次结构：场景图、UI 层次结构等 实体管理：实体池、实体禁用等 常见问题问题 1：如何获取实体的 ID？ 解决方案：使用 .id() 方法在创建实体时获取 ID，或使用查询获取实体的 ID。 问题 2：如何禁用实体而不删除它们？ 解决方案：使用 Disabled 组件禁用实体。被禁用的实体会被默认查询过滤器跳过。 问题 3：如何建立实体间的层次结构？ 解决方案：使用 with_children() 或 add_child() 方法建立父子关系。Bevy 会自动管理 ChildOf 和 Children 组件。 性能考虑 实体创建：批量创建实体比逐个创建更高效 实体查询：使用查询过滤器减少查询的实体数量 实体禁用：禁用不需要处理的实体可以提高性能 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例（实体创建） bevy/examples/ecs/entity_disabling.rs - 实体禁用示例 bevy/examples/ecs/hierarchy.rs - 实体层次结构示例 官方文档链接： Bevy Entity 官方文档 Entity 禁用文档 Hierarchy 文档 进一步学习建议： 学习系统（Systems），了解如何处理实体 学习查询（Queries），了解如何查询实体 学习关系系统（Relationships），了解如何建立实体间的关系 索引：返回上级目录"},{"title":"相机系统（Camera）","path":"/Luo-Haomin/wiki/BevyBook/3D_Graphics/相机系统（Camera）.html","content":"相机系统（Camera）概述学习目标： 理解 Bevy 相机系统的基本概念 掌握相机控制器的使用 了解相机投影的使用 学会使用相机轨道和第一人称相机 前置知识要求： Bevy 快速入门 ECS 基础 3D 开发基础 输入处理基础 核心概念什么是相机系统？相机系统是 Bevy 中用于控制视角的功能。相机系统提供了多种相机类型和控制方式，包括轨道相机、第一人称相机、自定义投影等。 为什么需要相机系统？ 视角控制：相机系统可以控制游戏的视角 相机移动：相机系统可以实现相机的移动和旋转 相机投影：相机系统可以自定义相机的投影方式 相机效果：相机系统可以实现相机特效（如屏幕抖动） 相机系统的核心组件Bevy 相机系统包含以下核心组件： Camera3d：3D 相机组件 Camera2d：2D 相机组件 Projection：投影组件 Transform：变换组件，用于控制相机位置和旋转 基础用法相机控制器使用相机控制器实现自由相机。 源代码文件：bevy/examples/helpers/camera_controller.rs 代码示例： use bevy:: input::mouse::AccumulatedMouseMotion, AccumulatedMouseScroll, MouseScrollUnit, prelude::*, window::CursorGrabMode, CursorOptions,;use std::f32::consts::*, fmt;/// 自由相机风格的相机控制器插件。pub struct CameraControllerPlugin;impl Plugin for CameraControllerPlugin fn build(self, app: mut App) app.add_systems(Update, run_camera_controller); /// 相机控制器组件。#[derive(Component)]pub struct CameraController /// 当为 `true` 时启用此 [`CameraController`]。 pub enabled: bool, /// 指示此控制器是否已由 [`CameraControllerPlugin`] 初始化。 pub initialized: bool, /// 俯仰和偏航旋转速度的乘数。 pub sensitivity: f32, /// 向前平移的 [`KeyCode`]。 pub key_forward: KeyCode, /// 向后平移的 [`KeyCode`]。 pub key_back: KeyCode, /// 向左平移的 [`KeyCode`]。 pub key_left: KeyCode, /// 向右平移的 [`KeyCode`]。 pub key_right: KeyCode, /// 向上平移的 [`KeyCode`]。 pub key_up: KeyCode, /// 向下平移的 [`KeyCode`]。 pub key_down: KeyCode, /// 使用 [`run_speed`](CameraController::run_speed) 而不是 /// [`walk_speed`](CameraController::walk_speed) 进行平移的 [`KeyCode`]。 pub key_run: KeyCode, /// 用于抓取鼠标焦点的 [`MouseButton`]。 pub mouse_key_cursor_grab: MouseButton, /// 用于抓取键盘焦点的 [`KeyCode`]。 pub keyboard_key_toggle_cursor_grab: KeyCode, /// 未修改平移速度的乘数。 pub walk_speed: f32, /// 运行平移速度的乘数。 pub run_speed: f32, /// 鼠标滚轮修改 [`walk_speed`](CameraController::walk_speed) /// 和 [`run_speed`](CameraController::run_speed) 的乘数。 pub scroll_factor: f32, /// 用于随时间指数衰减 [`velocity`](CameraController::velocity) 的摩擦因子。 pub friction: f32, /// 此 [`CameraController`] 的俯仰旋转。 pub pitch: f32, /// 此 [`CameraController`] 的偏航旋转。 pub yaw: f32, /// 此 [`CameraController`] 的平移速度。 pub velocity: Vec3,impl Default for CameraController fn default() - Self Self enabled: true, initialized: false, sensitivity: 1.0, key_forward: KeyCode::KeyW, key_back: KeyCode::KeyS, key_left: KeyCode::KeyA, key_right: KeyCode::KeyD, key_up: KeyCode::KeyE, key_down: KeyCode::KeyQ, key_run: KeyCode::ShiftLeft, mouse_key_cursor_grab: MouseButton::Left, keyboard_key_toggle_cursor_grab: KeyCode::KeyM, walk_speed: 5.0, run_speed: 15.0, scroll_factor: 0.1, friction: 0.5, pitch: 0.0, yaw: 0.0, velocity: Vec3::ZERO, 关键要点： 使用 CameraController 组件控制相机 使用 CameraControllerPlugin 插件添加相机控制器系统 使用键盘和鼠标控制相机移动和旋转 使用 CursorGrabMode 控制鼠标抓取模式 说明：相机控制器是相机系统的基础。通过使用相机控制器，可以实现自由相机，控制游戏的视角。 相机轨道使用相机轨道实现轨道相机。 源代码文件：bevy/examples/camera/camera_orbit.rs 代码示例： use std::f32::consts::FRAC_PI_2, ops::Range;use bevy::input::mouse::AccumulatedMouseMotion, prelude::*;#[derive(Debug, Resource)]struct CameraSettings pub orbit_distance: f32, pub pitch_speed: f32, // 将俯仰限制在此范围内 pub pitch_range: Rangef32, pub roll_speed: f32, pub yaw_speed: f32,impl Default for CameraSettings fn default() - Self // 限制俯仰可以防止超过 90° 向上或向下的意外旋转。 let pitch_limit = FRAC_PI_2 - 0.01; Self // 这些值完全是任意的，选择它们是因为它们似乎为这个示例产生合理的结果。 // 根据需要调整。 orbit_distance: 20.0, pitch_speed: 0.003, pitch_range: -pitch_limit..pitch_limit, roll_speed: 1.0, yaw_speed: 0.004, fn main() App::new() .add_plugins(DefaultPlugins) .init_resource::CameraSettings() .add_systems(Startup, (setup, instructions)) .add_systems(Update, orbit) .run();fn orbit( mut camera: Singlemut Transform, WithCamera, settings: ResCameraSettings, mouse_motion: ResAccumulatedMouseMotion, mouse_buttons: ResButtonInputMouseButton,) // 根据鼠标移动更新俯仰和偏航 let mut pitch_delta = 0.0; let mut yaw_delta = 0.0; let mut roll_delta = 0.0; if mouse_motion.is_changed() let delta = mouse_motion.delta(); pitch_delta -= delta.y * settings.pitch_speed; yaw_delta -= delta.x * settings.yaw_speed; // 根据鼠标按钮更新滚动 if mouse_buttons.pressed(MouseButton::Left) roll_delta += settings.roll_speed; if mouse_buttons.pressed(MouseButton::Right) roll_delta -= settings.roll_speed; // 更新相机变换 let mut pitch = camera.rotation.to_euler(EulerRot::YXZ).1; let mut yaw = camera.rotation.to_euler(EulerRot::YXZ).0; let mut roll = camera.rotation.to_euler(EulerRot::YXZ).2; pitch += pitch_delta; pitch = pitch.clamp(settings.pitch_range.start, settings.pitch_range.end); yaw += yaw_delta; roll += roll_delta; // 计算相机位置 let rotation = Quat::from_euler(EulerRot::YXZ, yaw, pitch, roll); let position = rotation * Vec3::new(0.0, 0.0, settings.orbit_distance); camera.translation = position; camera.rotation = rotation; 关键要点： 使用 AccumulatedMouseMotion 获取鼠标移动 使用 ButtonInputMouseButton 获取鼠标按钮状态 使用 Transform 控制相机位置和旋转 使用 Quat::from_euler 创建旋转四元数 说明：相机轨道是相机系统的重要功能。通过使用相机轨道，可以实现轨道相机，围绕场景旋转相机。 自定义投影使用自定义投影实现特殊投影效果。 源代码文件：bevy/examples/camera/custom_projection.rs 代码示例： use bevy::camera::CameraProjection;use bevy::prelude::*;/// 类似于透视投影，但消失点不居中。#[derive(Debug, Clone)]struct ObliquePerspectiveProjection horizontal_obliqueness: f32, vertical_obliqueness: f32, perspective: PerspectiveProjection,/// 为我们的自定义投影实现 [`CameraProjection`] trait：impl CameraProjection for ObliquePerspectiveProjection fn get_clip_from_view(self) - Mat4 let mut mat = self.perspective.get_clip_from_view(); mat.col_mut(2)[0] = self.horizontal_obliqueness; mat.col_mut(2)[1] = self.vertical_obliqueness; mat fn get_clip_from_view_for_sub(self, sub_view: bevy::camera::SubCameraView) - Mat4 let mut mat = self.perspective.get_clip_from_view_for_sub(sub_view); mat.col_mut(2)[0] = self.horizontal_obliqueness; mat.col_mut(2)[1] = self.vertical_obliqueness; mat fn update(mut self, width: f32, height: f32) self.perspective.update(width, height); fn far(self) - f32 self.perspective.far fn get_frustum_corners(self, z_near: f32, z_far: f32) - [Vec3A; 8] self.perspective.get_frustum_corners(z_near, z_far) fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) commands.spawn(( Camera3d::default(), // 使用我们的自定义投影： Projection::custom(ObliquePerspectiveProjection horizontal_obliqueness: 0.2, vertical_obliqueness: 0.6, perspective: PerspectiveProjection::default(), ), Transform::from_xyz(-2.5, 4.5, 9.0).looking_at(Vec3::ZERO, Vec3::Y), )); 关键要点： 使用 CameraProjection trait 实现自定义投影 使用 Projection::custom() 设置自定义投影 使用 get_clip_from_view() 获取投影矩阵 使用 update() 更新投影参数 说明：自定义投影是相机系统的高级功能。通过使用自定义投影，可以实现特殊的投影效果，如斜投影。 进阶用法屏幕抖动使用屏幕抖动实现相机特效。 源代码文件：bevy/examples/camera/2d_screen_shake.rs 关键信息： 使用 Transform 控制相机位置 使用随机数生成抖动效果 使用时间控制抖动持续时间 使用衰减函数平滑抖动 说明：屏幕抖动是相机系统的重要功能。通过使用屏幕抖动，可以实现相机特效，增强游戏体验。 第一人称相机使用第一人称相机实现第一人称视角。 源代码文件：bevy/examples/camera/first_person_view_model.rs 关键信息： 使用 CameraController 控制相机 使用鼠标控制视角 使用键盘控制移动 使用 CursorGrabMode 控制鼠标抓取 说明：第一人称相机是相机系统的重要功能。通过使用第一人称相机，可以实现第一人称视角，增强游戏沉浸感。 实际应用在游戏开发中的应用场景相机系统在游戏开发中有广泛的应用： 视角控制：控制游戏的视角 相机移动：实现相机的移动和旋转 相机投影：自定义相机的投影方式 相机效果：实现相机特效（如屏幕抖动） 相机切换：实现不同相机之间的切换 常见问题问题 1：如何控制相机移动？ 解决方案： 使用 CameraController 组件控制相机 使用键盘和鼠标控制相机移动和旋转 使用 Transform 控制相机位置和旋转 问题 2：如何实现相机轨道？ 解决方案： 使用 AccumulatedMouseMotion 获取鼠标移动 使用 Transform 控制相机位置和旋转 使用 Quat::from_euler 创建旋转四元数 问题 3：如何自定义相机投影？ 解决方案： 使用 CameraProjection trait 实现自定义投影 使用 Projection::custom() 设置自定义投影 使用 get_clip_from_view() 获取投影矩阵 性能考虑 相机控制器：相机控制器更新是高效的，可以频繁使用 相机投影：自定义投影计算可能较慢，应谨慎使用 相机效果：相机效果应适度使用，避免影响性能 相关资源相关源代码文件： bevy/examples/helpers/camera_controller.rs - 相机控制器示例 bevy/examples/camera/camera_orbit.rs - 相机轨道示例 bevy/examples/camera/custom_projection.rs - 自定义投影示例 bevy/examples/camera/2d_screen_shake.rs - 屏幕抖动示例 bevy/examples/camera/first_person_view_model.rs - 第一人称相机示例 官方文档链接： Bevy 相机系统 Bevy 相机示例 进一步学习建议： 学习 3D 开发，了解 3D 渲染基础 学习输入处理，了解输入系统 索引：返回上级目录"},{"title":"核心编程框架（ECS）","path":"/Luo-Haomin/wiki/BevyBook/ECS/核心编程框架（ECS）.html","content":"核心编程框架（ECS）概述学习目标： 理解 ECS（Entity Component System）的核心概念 理解为什么 Bevy 使用 ECS 模式 掌握 ECS 的基本组成部分 理解 ECS 的设计优势 前置知识要求： Bevy 快速入门 Rust 基础语法 理解基本的编程概念 核心概念什么是 ECS？ECS（Entity Component System）是 Bevy 的核心编程范式。所有 Bevy 应用逻辑都基于 ECS 模式构建。 为什么使用 ECS？ 数据导向：功能由数据驱动，而非继承层次 清晰架构：松耦合的功能，避免深层继承 高性能：大规模并行执行，缓存友好 ECS 的核心组成部分： Component（组件）：普通 Rust 数据类型，通常专注于单一功能 Entity（实体）：具有唯一 ID 的组件集合 Resource（资源）：共享的全局数据 System（系统）：在实体、组件和资源上运行逻辑的函数 ECS 设计思想ECS 采用数据导向的设计思想，将数据（组件）和逻辑（系统）分离。这种设计使得： 系统可以独立开发和测试 组件可以灵活组合 系统可以并行执行，提高性能 基础用法ECS 定义源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： //! This is a guided introduction to Bevys Entity Component System (ECS)//! All Bevy app logic is built using the ECS pattern, so definitely pay attention!//!//! Why ECS?//! * Data oriented: Functionality is driven by data//! * Clean Architecture: Loose coupling of functionality / prevents deeply nested inheritance//! * High Performance: Massively parallel and cache friendly//!//! ECS Definitions://!//! Component: just a normal Rust data type. generally scoped to a single piece of functionality//! Examples: position, velocity, health, color, name//!//! Entity: a collection of components with a unique id//! Examples: Entity1 Name(Alice), Position(0, 0) ,//! Entity2 Name(Bill), Position(10, 5) //!//! Resource: a shared global piece of data//! Examples: asset storage, messages, system state//!//! System: runs logic on entities, components, and resources//! Examples: move system, damage system 关键要点： Component（组件）：普通 Rust 数据类型，通常专注于单一功能 示例：位置、速度、生命值、颜色、名称 Entity（实体）：具有唯一 ID 的组件集合 示例：Entity1 { Name(“Alice”), Position(0, 0) } Resource（资源）：共享的全局数据 示例：资源存储、消息、系统状态 System（系统）：在实体、组件和资源上运行逻辑的函数 示例：移动系统、伤害系统 说明：ECS 是 Bevy 的核心编程范式。所有 Bevy 应用逻辑都基于 ECS 模式构建。理解 ECS 是掌握 Bevy 的关键。 为什么使用 ECS？源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： //! Why ECS?//! * Data oriented: Functionality is driven by data//! * Clean Architecture: Loose coupling of functionality / prevents deeply nested inheritance//! * High Performance: Massively parallel and cache friendly 关键要点： 数据导向：功能由数据驱动，而非继承层次 清晰架构：松耦合的功能，避免深层继承 高性能：大规模并行执行，缓存友好 说明：ECS 模式提供了数据导向的设计，功能由数据驱动，而非继承层次。这种设计使得系统可以独立开发和测试，组件可以灵活组合，系统可以并行执行，提高性能。 进阶用法ECS 的优势ECS 模式相比传统面向对象编程有以下优势： 性能优化： 系统可以并行执行 数据布局优化，提高缓存命中率 减少内存分配 代码组织： 系统可以独立开发和测试 组件可以灵活组合 避免深层继承 可扩展性： 易于添加新功能 易于修改现有功能 易于重构 ECS 的适用场景ECS 模式特别适用于： 游戏开发：游戏对象管理、系统组织、性能优化 模拟系统：物理模拟、AI 系统、渲染系统 数据密集型应用：需要高性能和并行处理的应用 实际应用在游戏开发中的应用场景ECS 模式在游戏开发中有广泛的应用： 游戏对象管理：每个游戏对象（如玩家、敌人、道具）都是一个实体，具有不同的组件组合 系统组织：游戏逻辑按系统组织（如移动系统、渲染系统、物理系统） 性能优化：系统可以并行执行，提高游戏性能 常见问题问题 1：ECS 与面向对象编程有什么区别？ 解决方案： ECS 是数据导向的，面向对象是行为导向的 ECS 将数据（组件）和逻辑（系统）分离，面向对象将数据和行为封装在一起 ECS 更适合并行执行，面向对象更适合顺序执行 问题 2：何时使用组件，何时使用资源？ 解决方案： 组件用于实体特有的数据（如位置、速度） 资源用于全局共享的数据（如游戏设置、资源存储） 如果数据是实体特有的，使用组件；如果是全局共享的，使用资源 问题 3：如何设计 ECS 系统？ 解决方案： 将功能拆分为独立的系统 每个系统只访问需要的数据 保持系统和组件的粒度细 避免在单个系统中放置太多功能 性能考虑 系统并行性：保持系统粒度细，只访问需要的数据 数据布局：相关组件应该放在一起，提高缓存命中率 查询优化：只查询需要的组件，减少查询开销 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例 官方文档链接： Bevy ECS 官方文档 ECS 设计模式 Bevy ECS 示例 进一步学习建议： 学习 ECS 基础，了解如何定义组件、实体和系统 学习 ECS 进阶，了解高级功能和最佳实践 阅读 Bevy ECS 源码，深入理解实现原理 索引：返回上级目录"},{"title":"状态管理（State）","path":"/Luo-Haomin/wiki/BevyBook/ECS/状态管理（State）.html","content":"状态管理（State）概述学习目标： 理解 Bevy 状态管理的基本概念 掌握基本状态的使用 了解子状态和计算状态 学会使用自定义状态转换 前置知识要求： Bevy 快速入门 ECS 基础 系统（Systems） 系统调度（Schedule App） 核心概念什么是状态管理？状态管理是 Bevy 中用于控制应用流程的功能。状态管理允许您定义应用的不同状态（如菜单、游戏中、暂停等），并根据状态控制系统的执行。 为什么需要状态管理？ 应用控制流：状态管理可以控制应用的不同阶段 系统组织：状态管理可以组织和管理系统 资源管理：状态管理可以管理不同状态的资源 代码清晰：状态管理可以使代码更清晰、更易维护 状态管理的核心组件Bevy 状态管理包含以下核心组件： States：状态 trait，用于定义状态类型 State：状态资源，用于读取当前状态 NextState：下一状态资源，用于设置下一状态 OnEnter：进入状态时的调度 OnExit：退出状态时的调度 基础用法基本状态创建和使用基本状态。 源代码文件：bevy/examples/state/states.rs 代码示例： use bevy::dev_tools::states::*, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .init_state::AppState() // 或者我们可以使用 .insert_state(AppState::Menu) .add_systems(Startup, setup) // 此系统在我们进入 `AppState::Menu` 时运行，在 `StateTransition` 调度期间。 // 首先运行我们离开的状态的退出调度中的所有系统， // 然后运行我们进入的状态的进入调度中的所有系统。 .add_systems(OnEnter(AppState::Menu), setup_menu) // 相比之下，更新系统存储在 `Update` 调度中。它们只是 // 检查 `StateT` 资源的值，以查看是否应该在每帧运行。 .add_systems(Update, menu.run_if(in_state(AppState::Menu))) .add_systems(OnExit(AppState::Menu), cleanup_menu) .add_systems(OnEnter(AppState::InGame), setup_game) .add_systems( Update, (movement, change_color).run_if(in_state(AppState::InGame)), ) .add_systems(Update, log_transitions::AppState) .run();#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]enum AppState #[default] Menu, InGame,#[derive(Resource)]struct MenuData button_entity: Entity,fn setup(mut commands: Commands) commands.spawn(Camera2d);fn setup_menu(mut commands: Commands) let button_entity = commands .spawn(( Node // 居中按钮 width: percent(100), height: percent(100), justify_content: JustifyContent::Center, align_items: AlignItems::Center, ..default() , children![( Button, Node width: px(150), height: px(65), // 水平居中子文本 justify_content: JustifyContent::Center, // 垂直居中子文本 align_items: AlignItems::Center, ..default() , BackgroundColor(NORMAL_BUTTON), children![( Text::new(Play), TextFont font_size: 33.0, ..default() , TextColor(Color::srgb(0.9, 0.9, 0.9)), )], )], )) .id(); commands.insert_resource(MenuData button_entity );fn menu( mut next_state: ResMutNextStateAppState, mut interaction_query: Query (Interaction, mut BackgroundColor), (ChangedInteraction, WithButton), ,) for (interaction, mut color) in mut interaction_query match *interaction Interaction::Pressed = *color = PRESSED_BUTTON.into(); next_state.set(AppState::InGame); Interaction::Hovered = *color = HOVERED_BUTTON.into(); Interaction::None = *color = NORMAL_BUTTON.into(); fn cleanup_menu(mut commands: Commands, menu_data: ResMenuData) commands.entity(menu_data.button_entity).despawn();fn setup_game(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Sprite::from_image(asset_server.load(branding/icon.png))); 关键要点： 使用 #[derive(States)] 创建状态类型 使用 init_state::T() 初始化状态 使用 OnEnterT 在进入状态时运行系统 使用 OnExitT 在退出状态时运行系统 使用 in_state(T) 条件运行系统 使用 NextStateT 设置下一状态 说明：基本状态是状态管理的基础。通过使用基本状态，可以控制应用的不同阶段，并根据状态控制系统的执行。 进阶用法子状态（SubStates）使用子状态创建更复杂的状态模式。 源代码文件：bevy/examples/state/sub_states.rs 代码示例： use bevy::dev_tools::states::*, prelude::*;#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]enum AppState #[default] Menu, InGame,// 在这种情况下，我们不是派生 `States`，而是派生 `SubStates`#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, SubStates)]// 我们需要添加一个属性来告诉我们源状态是什么// 以及它需要什么值。这将确保除非我们// 在 [`AppState::InGame`] 中，否则 [`IsPaused`] 状态资源// 将不存在。#[source(AppState = AppState::InGame)]#[states(scoped_entities)]enum IsPaused #[default] Running, Paused,fn main() App::new() .add_plugins(DefaultPlugins) .init_state::AppState() .add_sub_state::IsPaused() // 我们在这里设置子状态 .add_systems(Startup, setup) .add_systems(OnEnter(AppState::Menu), setup_menu) .add_systems(Update, menu.run_if(in_state(AppState::Menu))) .add_systems(OnExit(AppState::Menu), cleanup_menu) .add_systems(OnEnter(AppState::InGame), setup_game) .add_systems(OnEnter(IsPaused::Paused), setup_paused_screen) .add_systems( Update, ( // 这里我们不是依赖 [`AppState::InGame`]，而是依赖 // [`IsPaused::Running`]，因为我们不希望在暂停时移动或改变颜色 (movement, change_color).run_if(in_state(IsPaused::Running)), // 另一方面，暂停切换需要无论是否暂停都能工作， // 所以它使用 [`AppState::InGame`] 而不是。 toggle_pause.run_if(in_state(AppState::InGame)), ), ) .add_systems(Update, log_transitions::AppState) .run(); 关键要点： 使用 #[derive(SubStates)] 创建子状态 使用 #[source(AppState = AppState::InGame)] 指定源状态 使用 add_sub_state::T() 添加子状态 子状态只在源状态存在时存在 说明：子状态是状态管理的高级功能。通过使用子状态，可以创建更复杂的状态模式，同时依赖简单的枚举。 计算状态（ComputedStates）使用计算状态创建更复杂的状态模式。 源代码文件：bevy/examples/state/computed_states.rs 关键信息： 使用 ComputedStates trait 创建计算状态 使用 SourceStates 指定源状态 使用 compute 函数计算状态值 计算状态可以从多个源状态计算 说明：计算状态是状态管理的高级功能。通过使用计算状态，可以创建从其他状态计算得出的状态，实现更灵活的状态管理。 自定义状态转换创建自定义状态转换行为。 源代码文件：bevy/examples/state/custom_transitions.rs 关键信息： 使用 StateTransition 调度处理状态转换 使用 StateTransitionEvent 监听状态转换事件 使用 OnReenter 和 OnReexit 创建自定义转换 使用 IdentityTransitionsPlugin 注册自定义转换 说明：自定义状态转换是状态管理的高级功能。通过使用自定义状态转换，可以实现更复杂的状态转换行为。 实际应用在游戏开发中的应用场景状态管理在游戏开发中有广泛的应用： 游戏流程：控制游戏的不同阶段（菜单、游戏中、暂停等） 系统组织：根据状态组织和管理系统 资源管理：管理不同状态的资源 代码清晰：使代码更清晰、更易维护 常见问题问题 1：如何创建状态？ 解决方案： 使用 #[derive(States)] 创建状态类型 使用 init_state::T() 初始化状态 使用 insert_state(T) 插入初始状态 问题 2：如何切换状态？ 解决方案： 使用 NextStateT::set() 设置下一状态 使用 NextStateT::set_if_neq() 仅在状态不同时设置 状态转换在 StateTransition 调度中处理 问题 3：如何根据状态运行系统？ 解决方案： 使用 in_state(T) 条件运行系统 使用 OnEnterT 在进入状态时运行系统 使用 OnExitT 在退出状态时运行系统 性能考虑 状态转换：状态转换在 StateTransition 调度中处理 系统条件：使用 in_state 条件可以减少不必要的系统执行 子状态：子状态只在源状态存在时存在，可以减少资源使用 相关资源相关源代码文件： bevy/examples/state/states.rs - 基本状态示例 bevy/examples/state/sub_states.rs - 子状态示例 bevy/examples/state/computed_states.rs - 计算状态示例 bevy/examples/state/custom_transitions.rs - 自定义状态转换示例 官方文档链接： Bevy 状态管理 Bevy 状态示例 进一步学习建议： 学习系统调度，了解系统执行顺序 学习 ECS 进阶，了解高级功能 索引：返回上级目录"},{"title":"时间系统（Time）","path":"/Luo-Haomin/wiki/BevyBook/ECS/时间系统（Time）.html","content":"时间系统（Time）概述学习目标： 理解 Bevy 时间系统的基本概念 掌握时间资源的使用 了解定时器的使用 学会使用虚拟时间 前置知识要求： Bevy 快速入门 ECS 基础 资源（Resources）基础 核心概念什么是时间系统？时间系统是 Bevy 中用于管理游戏时间的功能。时间系统提供了多种时间类型，包括真实时间、虚拟时间和固定时间步。 为什么需要时间系统？ 游戏逻辑：时间系统可以控制游戏逻辑的执行速度 动画：时间系统可以控制动画的播放速度 物理模拟：时间系统可以控制物理模拟的时间步 游戏暂停：时间系统可以实现游戏暂停功能 时间系统的核心组件Bevy 时间系统包含以下核心组件： Time：真实时间，不受游戏速度影响 Time：虚拟时间，受游戏速度影响 Time：固定时间步，用于物理模拟 Timer：定时器，用于延迟和周期性任务 基础用法时间资源使用时间资源获取时间信息。 源代码文件：bevy/examples/time/time.rs 代码示例： use bevy::app::AppExit, prelude::*;use std:: io::self, BufRead, time::Duration,;fn main() App::new() .add_plugins(MinimalPlugins) .insert_resource(Time::Virtual::from_max_delta(Duration::from_secs(5))) .insert_resource(Time::Fixed::from_duration(Duration::from_secs(1))) .add_systems(PreUpdate, print_real_time) .add_systems(FixedUpdate, print_fixed_time) .add_systems(Update, print_time) .set_runner(runner) .run();fn print_real_time(time: ResTimeReal) println!( PreUpdate: this is real time clock, delta is :? and elapsed is :?, time.delta(), time.elapsed() );fn print_fixed_time(time: ResTime) println!( FixedUpdate: this is generic time clock inside fixed, delta is :? and elapsed is :?, time.delta(), time.elapsed() );fn print_time(time: ResTime) println!( Update: this is generic time clock, delta is :? and elapsed is :?, time.delta(), time.elapsed() ); 关键要点： 使用 TimeReal 获取真实时间 使用 TimeVirtual 获取虚拟时间 使用 TimeFixed 获取固定时间步 使用 time.delta() 获取时间增量 使用 time.elapsed() 获取经过的时间 说明：时间资源是时间系统的基础。通过使用时间资源，可以获取时间信息，控制游戏逻辑的执行速度。 定时器使用定时器实现延迟和周期性任务。 源代码文件：bevy/examples/time/timers.rs 代码示例： use bevy::log::info, prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .init_resource::Countdown() .add_systems(Startup, setup) .add_systems(Update, (countdown, print_when_completed)) .run();#[derive(Component, Deref, DerefMut)]struct PrintOnCompletionTimer(Timer);#[derive(Resource)]struct Countdown percent_trigger: Timer, main_timer: Timer,impl Countdown pub fn new() - Self Self percent_trigger: Timer::from_seconds(4.0, TimerMode::Repeating), main_timer: Timer::from_seconds(20.0, TimerMode::Once), impl Default for Countdown fn default() - Self::new() fn setup(mut commands: Commands) // 向世界添加一个带有定时器的实体 commands.spawn(PrintOnCompletionTimer(Timer::from_seconds( 5.0, TimerMode::Once, )));/// 此系统使用 bevy 的 `Time` 资源来获取每次更新之间的增量，/// 对具有 `PrintOnCompletionTimer` 组件的实体上的 `Timer` 进行计时。fn print_when_completed(time: ResTime, mut query: Querymut PrintOnCompletionTimer) for mut timer in mut query if timer.tick(time.delta()).just_finished() info!(Entity timer just finished); /// 此系统控制倒计时资源内的定时器计时并处理其状态。fn countdown(time: ResTime, mut countdown: ResMutCountdown) countdown.main_timer.tick(time.delta()); // API 鼓励这种定时器状态检查（如果您只检查一个值） // 此外，由于定时器是重复的，`is_finished()` 会完成与 `just_finished` 相同的事情， // 但这在视觉上更有意义。 if countdown.percent_trigger.tick(time.delta()).just_finished() if !countdown.main_timer.is_finished() // 打印主定时器完成的百分比。 info!( Timer is :0.0% complete!, countdown.main_timer.fraction() * 100.0 ); else // 定时器已完成，因此我们暂停百分比输出定时器 countdown.percent_trigger.pause(); info!(Paused percent trigger timer); 关键要点： 使用 Timer::from_seconds() 创建定时器 使用 TimerMode::Once 创建单次定时器 使用 TimerMode::Repeating 创建重复定时器 使用 timer.tick() 更新定时器 使用 timer.just_finished() 检查定时器是否刚完成 使用 timer.is_finished() 检查定时器是否完成 使用 timer.fraction() 获取定时器完成的百分比 说明：定时器是时间系统的重要功能。通过使用定时器，可以实现延迟和周期性任务。 进阶用法虚拟时间使用虚拟时间控制游戏速度。 源代码文件：bevy/examples/time/virtual_time.rs 代码示例： use std::time::Duration;use bevy:: color::palettes::css::*, input::common_conditions::input_just_pressed, prelude::*, time::common_conditions::on_real_timer,;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems( Update, ( move_virtual_time_sprites, move_real_time_sprites, toggle_pause.run_if(input_just_pressed(KeyCode::Space)), change_time_speed::1.run_if(input_just_pressed(KeyCode::ArrowUp)), change_time_speed::-1.run_if(input_just_pressed(KeyCode::ArrowDown)), (update_virtual_time_info_text, update_real_time_info_text) // 在定时器上更新文本以使其更易读 // `on_timer` 运行条件使用 `Virtual` 时间，这意味着它是缩放的 // 并且会根据 `TimeVirtual::relative_speed` 和 `TimeVirtual::is_paused()` 以不同的间隔更新 UI .run_if(on_real_timer(Duration::from_millis(250))), ), ) .run();/// `Real` 时间相关标记#[derive(Component)]struct RealTime;/// `Virtual` 时间相关标记#[derive(Component)]struct VirtualTime;/// 设置示例fn setup(mut commands: Commands, asset_server: ResAssetServer, mut time: ResMutTimeVirtual) // 从双倍 `Virtual` 时间开始，导致一个精灵以另一个精灵的两倍速度移动， // 另一个精灵基于 `Real`（未缩放）时间移动 time.set_relative_speed(2.); commands.spawn(Camera2d); // ... 创建精灵和 UI .../// 使用 `Virtual`（缩放）时间移动精灵fn move_virtual_time_sprites( mut sprite_query: Querymut Transform, (WithSprite, WithVirtualTime), // 默认 `Time` 在常规系统中是 `TimeVirtual`， // 或在固定时间步系统中是 `TimeFixed`，因此 `Time::delta()`、 // `Time::elapsed()` 将返回适当的值 time: ResTime,) for mut transform in sprite_query.iter_mut() // 在 `Virtual` 秒内移动大约屏幕的一半 // 当使用 `TimeVirtual::set_relative_speed` 缩放时间时， // 它会以不同的速度移动，当时间暂停时精灵会保持静止 transform.translation.x = get_sprite_translation_x(time.elapsed_secs()); /// 更新 `TimeVirtual` 的速度，增量为 `DELTA`fn change_time_speedconst DELTA: i8(mut time: ResMutTimeVirtual) let time_speed = (time.relative_speed() + DELTA as f32) .round() .clamp(0.25, 5.); // 设置虚拟时间的速度以加快或减慢速度 time.set_relative_speed(time_speed);/// 暂停或恢复 `Relative` 时间fn toggle_pause(mut time: ResMutTimeVirtual) if time.is_paused() time.unpause(); else time.pause(); 关键要点： 使用 TimeVirtual 获取虚拟时间 使用 time.set_relative_speed() 设置相对速度 使用 time.pause() 暂停时间 使用 time.unpause() 恢复时间 使用 time.is_paused() 检查时间是否暂停 说明：虚拟时间是时间系统的高级功能。通过使用虚拟时间，可以控制游戏速度，实现游戏暂停和加速功能。 实际应用在游戏开发中的应用场景时间系统在游戏开发中有广泛的应用： 游戏逻辑：控制游戏逻辑的执行速度 动画：控制动画的播放速度 物理模拟：控制物理模拟的时间步 游戏暂停：实现游戏暂停功能 定时任务：实现延迟和周期性任务 常见问题问题 1：如何获取时间增量？ 解决方案： 使用 Time::delta() 获取时间增量 使用 Time::delta_secs() 获取时间增量（秒） 使用 Time::delta_secs_f64() 获取时间增量（秒，f64） 问题 2：如何创建定时器？ 解决方案： 使用 Timer::from_seconds() 创建定时器 使用 TimerMode::Once 创建单次定时器 使用 TimerMode::Repeating 创建重复定时器 问题 3：如何控制游戏速度？ 解决方案： 使用 TimeVirtual::set_relative_speed() 设置相对速度 使用 TimeVirtual::pause() 暂停时间 使用 TimeVirtual::unpause() 恢复时间 性能考虑 时间资源：时间资源是轻量级的，可以频繁访问 定时器：定时器更新是高效的，可以大量使用 虚拟时间：虚拟时间计算是高效的，可以用于控制游戏速度 相关资源相关源代码文件： bevy/examples/time/time.rs - 时间系统基础示例 bevy/examples/time/timers.rs - 定时器示例 bevy/examples/time/virtual_time.rs - 虚拟时间示例 官方文档链接： Bevy 时间系统 Bevy 时间示例 进一步学习建议： 学习系统调度，了解固定时间步的使用 学习资源管理，了解资源的生命周期 索引：返回上级目录"},{"title":"系统调度（Schedule & App）","path":"/Luo-Haomin/wiki/BevyBook/ECS/系统调度（Schedule与App）.html","content":"系统调度（Schedule App）概述学习目标： 理解 Schedule 的概念和作用 掌握如何控制系统执行顺序 了解自定义 Schedule 的创建方法 理解 App 的生命周期和运行条件 前置知识要求： 核心编程框架（ECS） 系统（Systems） 资源（Resources） Rust 基础语法 核心概念什么是 Schedule？Schedule 控制系统执行策略和每个 tick 内系统的广泛顺序。每个系统都属于一个 Schedule，Schedule 控制系统的执行顺序。 为什么使用 Schedule？ 执行顺序：Schedule 控制系统的执行顺序 执行策略：Schedule 控制系统的执行策略（并行或顺序） 生命周期：Schedule 控制系统的生命周期（启动、更新、结束等） Schedule 的设计思想Schedule 采用数据导向的设计思想，将系统执行顺序和逻辑分离。这种设计使得： 系统可以灵活组织 系统执行顺序可以明确控制 系统可以并行执行，提高性能 基础用法默认 ScheduleBevy 提供了多个默认 Schedule，如 Startup、Update、Last 等。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： fn main() App::new() // `Startup` 系统在应用启动时恰好运行一次 // 这些通常用于应用初始化代码（例如：添加实体和资源） .add_systems(Startup, startup_system) // `Update` 系统每次更新运行一次 // 这些通常用于实时应用逻辑 .add_systems(Update, print_message_system) // 还有其他 Schedule，如 `Last`，它在每次运行的末尾运行 .add_systems(Last, print_at_end_round) .run(); 关键要点： Startup：启动系统，在应用启动时运行一次 Update：更新系统，每次更新运行一次 Last：最后系统，在每次运行的末尾运行 系统按 Schedule 顺序执行 说明：Bevy 提供了多个默认 Schedule，用于控制系统的执行顺序。Startup 系统在应用启动时运行一次，用于初始化。Update 系统每次更新运行一次，用于游戏逻辑。Last 系统在每次运行的末尾运行，用于清理。 系统执行顺序可以通过 .before() 和 .after() 方法控制系统的执行顺序。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 系统执行顺序//// 每个系统属于一个 `Schedule`，它控制执行策略和每个 tick 内系统的广泛顺序// `Startup` schedule 保存启动系统，它们在 `Update` 运行之前运行一次// `Update` 每次应用更新运行一次，通常是一帧或一tick//// 默认情况下，`Schedule` 中的所有系统并行运行，除非它们需要对数据的可变访问// 这是高效的，但有时顺序很重要// 例如，我们希望我们的游戏结束系统在所有其他系统之后执行// 以确保我们不会意外地多运行一轮游戏//// 你可以使用 `.before` 或 `.after` 方法强制系统之间的显式顺序// 系统不会调度，直到它们具有顺序依赖的所有系统都已完成// 还有其他 Schedule，如 `Last`，它在每次运行的末尾运行.add_systems(Last, print_at_end_round) 关键要点： 默认情况下，系统并行运行 使用 .before() 和 .after() 方法控制顺序 系统不会调度，直到依赖的系统完成 可变访问会阻止并行执行 说明：默认情况下，系统并行运行，除非它们需要对数据的可变访问。使用 .before() 和 .after() 方法可以明确控制系统的执行顺序。系统不会调度，直到它们依赖的所有系统都已完成。 系统集（SystemSet）系统集用于组织相关系统，并控制它们的执行顺序。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： /// 一组相关的系统集，用于控制系统顺序/// 系统可以添加到任意数量的集合中#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]enum MySystems BeforeRound, Round, AfterRound,fn main() App::new() // 我们也可以创建新的系统集，并相对于其他系统集对它们进行排序 // 这是我们游戏的执行顺序： // before_round: new_player_system, new_round_system // round: print_message_system, score_system // after_round: score_check_system, game_over_system .configure_sets( Update, // chain() 将确保集合按列出的顺序运行 ( MySystems::BeforeRound, MySystems::Round, MySystems::AfterRound, ) .chain(), ) // add_systems 函数很强大。你可以轻松定义复杂的系统配置！ .add_systems( Update, ( // 这些 `BeforeRound` 系统将在 `Round` 系统之前运行，这要归功于链式集合配置 ( // 你也可以链式系统！new_round_system 将首先运行，然后是 new_player_system (new_round_system, new_player_system).chain(), exclusive_player_system, ) // 上面元组中的所有系统都将添加到这个集合中 .in_set(MySystems::BeforeRound), // 这个 `Round` 系统将在 `BeforeRound` 系统之后运行，这要归功于链式集合配置 score_system.in_set(MySystems::Round), // 这些 `AfterRound` 系统将在 `Round` 系统之后运行，这要归功于链式集合配置 ( score_check_system, // 除了 chain()，你还可以使用 `before(system)` 和 `after(system)` // 这也适用于集合！ game_over_system.after(score_check_system), ) .in_set(MySystems::AfterRound), ), ) .run(); 关键要点： 使用 SystemSet 组织相关系统 使用 configure_sets() 配置系统集的顺序 使用 .chain() 方法链式系统集 使用 .in_set() 方法将系统添加到系统集 说明：系统集用于组织相关系统，并控制它们的执行顺序。使用 configure_sets() 可以配置系统集的顺序，使用 .chain() 方法可以链式系统集。 进阶用法自定义 Schedule可以创建自定义 Schedule，用于特定的执行策略。 源代码文件：bevy/examples/ecs/custom_schedule.rs 代码示例： use bevy:: app::MainScheduleOrder, ecs::schedule::ExecutorKind, ScheduleLabel, prelude::*,;#[derive(ScheduleLabel, Debug, Hash, PartialEq, Eq, Clone)]struct SingleThreadedUpdate;#[derive(ScheduleLabel, Debug, Hash, PartialEq, Eq, Clone)]struct CustomStartup;fn main() let mut app = App::new(); // 创建一个新的 [`Schedule`] // 为了演示目的，我们将其配置为使用单线程执行器 // 这样此 Schedule 中的系统永远不会并行运行 // 但是，这不是自定义 Schedule 的一般要求 let mut custom_update_schedule = Schedule::new(SingleThreadedUpdate); custom_update_schedule.set_executor_kind(ExecutorKind::SingleThreaded); // 将 Schedule 添加到应用不会自动运行它 // 这只是注册 Schedule，以便系统可以使用 `Schedules` 资源查找它 app.add_schedule(custom_update_schedule); // Bevy `App` 有一个 `main_schedule_label` 字段，它配置应用运行器运行哪个 Schedule // 默认情况下，这是 `Main` // `Main` Schedule 负责运行 Bevy 的主要 Schedule，如 `Update`、`Startup` 或 `Last` // // 我们可以通过修改 `MainScheduleOrder` 资源来配置 `Main` Schedule 运行我们的自定义更新 Schedule // 相对于现有的 Schedule // // 注意，我们在 `main` 中直接修改 `MainScheduleOrder`，而不是在启动系统中 // 原因是 `MainScheduleOrder` 不能从作为 `Main` Schedule 一部分运行的系统修改 let mut main_schedule_order = app.world_mut().resource_mut::MainScheduleOrder(); main_schedule_order.insert_after(Update, SingleThreadedUpdate); // 添加自定义启动 Schedule 的工作方式类似，但需要使用 `insert_startup_after` // 而不是 `insert_after` app.add_schedule(Schedule::new(CustomStartup)); let mut main_schedule_order = app.world_mut().resource_mut::MainScheduleOrder(); main_schedule_order.insert_startup_after(PreStartup, CustomStartup); app.add_systems(SingleThreadedUpdate, single_threaded_update_system) .add_systems(CustomStartup, custom_startup_system) .add_systems(PreStartup, pre_startup_system) .add_systems(Startup, startup_system) .add_systems(First, first_system) .add_systems(Update, update_system) .add_systems(Last, last_system) .run(); 关键要点： 使用 Schedule::new() 创建自定义 Schedule 使用 ScheduleLabel 派生宏定义 Schedule 标签 使用 set_executor_kind() 设置执行器类型 使用 MainScheduleOrder 配置 Schedule 顺序 注意事项： 自定义 Schedule 需要添加到应用 需要配置 MainScheduleOrder 来运行自定义 Schedule 可以使用 ExecutorKind::SingleThreaded 创建单线程 Schedule 最佳实践： 对于需要特定执行策略的系统，使用自定义 Schedule 对于需要单线程执行的系统，使用单线程 Schedule 注意自定义 Schedule 的执行顺序 固定时间步（Fixed Timestep）固定时间步允许系统以固定时间间隔运行，而不是每帧运行。 源代码文件：bevy/examples/ecs/fixed_timestep.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) // 这个系统将每次更新运行一次（它应该匹配你的屏幕刷新率） .add_systems(Update, frame_update) // 将我们的系统添加到固定时间步 Schedule .add_systems(FixedUpdate, fixed_update) // 配置我们的固定时间步 Schedule 每秒运行两次 .insert_resource(Time::Fixed::from_seconds(0.5)) .run();fn frame_update(mut last_time: Localf32, time: ResTime) // 默认 `Time` 这里是 `TimeVirtual` info!( time since last frame_update: , time.elapsed_secs() - *last_time ); *last_time = time.elapsed_secs();fn fixed_update(mut last_time: Localf32, time: ResTime, fixed_time: ResTimeFixed) // 默认 `Time` 这里是 `TimeFixed` info!( time since last fixed_update: , time.elapsed_secs() - *last_time ); info!(fixed timestep: , time.delta_secs()); // 如果我们想看到超步，我们需要专门访问 `TimeFixed` info!( time accrued toward next fixed_update: , fixed_time.overstep().as_secs_f32() ); *last_time = time.elapsed_secs(); 关键要点： 使用 FixedUpdate Schedule 运行固定时间步系统 使用 Time::Fixed::from_seconds() 配置固定时间步 固定时间步系统以固定时间间隔运行 固定时间步适合物理模拟等需要稳定时间步的场景 注意事项： 固定时间步系统以固定时间间隔运行 固定时间步适合物理模拟等需要稳定时间步的场景 注意固定时间步与帧率的区别 最佳实践： 对于物理模拟等需要稳定时间步的系统，使用固定时间步 对于与帧率相关的系统，使用 Update Schedule 注意固定时间步与帧率的区别 运行条件（Run Conditions）运行条件允许控制系统是否应该运行。 源代码文件：bevy/examples/ecs/run_conditions.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .init_resource::InputCounter() .add_systems( Update, ( increment_input_counter // common_conditions 模块有一些有用的运行条件 // 用于检查资源和状态 // 这些包含在 prelude 中 .run_if(resource_exists::InputCounter) // `.or()` 是一个运行条件组合器，只有在第一个条件返回 `false` 时才评估第二个条件 // 这种行为称为短路，是 Rust 中 `||` 运算符的工作方式（以及大多数 C 系列语言） // 在这种情况下，`has_user_input` 运行条件将被评估，因为 `Unused` 资源尚未初始化 .run_if(resource_exists::Unused.or( // 这是一个自定义运行条件，使用返回 `bool` 的系统定义 // 并且具有只读 `SystemParam` // 只有一个运行条件必须返回 `true`，系统才会运行 has_user_input, )), print_input_counter // `.and()` 是一个运行条件组合器，只有在第一个条件返回 `true` 时才评估第二个条件 // 类似于 `` 运算符 // 在这种情况下，短路行为防止第二个运行条件在 `InputCounter` 资源未初始化时 panic .run_if(resource_exists::InputCounter.and( // 这是一个闭包形式的自定义运行条件 // 这对于不需要重用的小型、简单的运行条件很有用 // 所有正常规则仍然适用：所有参数必须是只读的，除了本地参数 |counter: ResInputCounter| counter.is_changed() !counter.is_added(), )), print_time_message // 这个函数返回一个自定义运行条件，很像 common_conditions 模块 // 它只会在 2 秒过去后返回 true .run_if(time_passed(2.0)) // 你可以使用 common_conditions 模块中的 `not` 条件 // 来反转运行条件 // 在这种情况下，如果自应用启动以来经过的时间少于 2.5 秒，它将返回 true .run_if(not(time_passed(2.5))), ), ) .run();/// 如果任何定义的输入刚刚被按下，则返回 true////// 这是一个自定义运行条件，它可以接受任何正常的系统参数/// 只要它们是只读的（除了本地参数可以是可变的）/// 它返回一个 bool，决定系统是否应该运行fn has_user_input( keyboard_input: ResButtonInputKeyCode, mouse_button_input: ResButtonInputMouseButton, touch_input: ResTouches,) - bool keyboard_input.just_pressed(KeyCode::Space) || keyboard_input.just_pressed(KeyCode::Enter) || mouse_button_input.just_pressed(MouseButton::Left) || mouse_button_input.just_pressed(MouseButton::Right) || touch_input.any_just_pressed()/// 这是一个返回闭包的函数，可以用作运行条件////// 这很有用，因为你可以重用相同的运行条件，但使用不同的变量/// 这就是 common_conditions 模块的工作方式fn time_passed(t: f32) - impl FnMut(Localf32, ResTime) - bool move |mut timer: Localf32, time: ResTime| // 计时器计时 *timer += time.delta_secs(); // 如果计时器已经超过时间，返回 true *timer = t 关键要点： 使用 .run_if() 方法添加运行条件 使用 .and() 和 .or() 组合运行条件 使用 not() 反转运行条件 运行条件可以是函数或闭包 注意事项： 运行条件必须返回 bool 运行条件参数必须是只读的（除了本地参数） 只有所有运行条件都返回 true 时，系统才会运行 最佳实践： 对于条件系统执行，使用运行条件 使用 .and() 和 .or() 组合运行条件 注意运行条件的性能影响 系统步进（System Stepping）系统步进允许逐步执行系统，用于调试。 源代码文件：bevy/examples/ecs/system_stepping.rs 代码示例： use bevy::ecs::schedule::Stepping, log::LogPlugin, prelude::*;fn main() let mut app = App::new(); app.add_plugins(LogPlugin::default()) .add_systems( Update, ( update_system_one, // 在这里建立依赖关系以简化下面的描述 update_system_two.after(update_system_one), update_system_three.after(update_system_two), update_system_four, ), ) .add_systems(PreUpdate, pre_update_system); // 添加 Stepping 资源 app.insert_resource(Stepping::new()); // 将 Update Schedule 添加到 Stepping // 启用 Stepping let mut stepping = app.world_mut().resource_mut::Stepping(); stepping.add_schedule(Update).enable(); // 步进一帧 stepping.step_frame(); app.update(); // 继续执行剩余系统 stepping.continue_frame(); app.update(); 关键要点： 使用 Stepping 资源控制系统步进 使用 step_frame() 步进一帧 使用 continue_frame() 继续执行剩余系统 使用 always_run() 和 never_run() 控制特定系统的执行 注意事项： 系统步进需要启用 bevy_debug_stepping 特性 系统步进主要用于调试 注意系统步进对性能的影响 最佳实践： 对于调试，使用系统步进 对于生产环境，禁用系统步进 注意系统步进对性能的影响 非确定性系统顺序默认情况下，Bevy 系统并行运行，除非明确指定顺序，否则它们的相对顺序是非确定性的。 源代码文件：bevy/examples/ecs/nondeterministic_system_order.rs 代码示例： use bevy:: ecs::schedule::LogLevel, ScheduleBuildSettings, prelude::*,;fn main() App::new() // 我们可以按每个 Schedule 修改系统执行顺序歧义的报告策略 // 你必须为每个要检查的 Schedule 执行此操作 // 在已检查的 Schedule 内执行的子 Schedule 不会继承此修改 .edit_schedule(Update, |schedule| schedule.set_build_settings(ScheduleBuildSettings ambiguity_detection: LogLevel::Warn, ..default() ); ) .init_resource::A() .init_resource::B() .add_systems( Update, ( // 这对系统有歧义顺序 // 因为它们的数据访问冲突，并且它们之间没有顺序 reads_a, writes_a, // 这对系统有冲突的数据访问 // 但通过显式顺序解决： // 这里的 .after 关系意味着我们总是在添加之后加倍 adds_one_to_b, doubles_b.after(adds_one_to_b), // 这个系统与 adds_one_to_b 没有歧义 // 由于我们的约束创建的传递顺序： // 如果 A 在 B 之前，B 在 C 之前，那么 A 必须在 C 之前 reads_b.after(doubles_b), // 这个系统将与我们的所有写入系统冲突 // 但我们已经用 adds_one_to_b 静默了它的歧义 // 这应该只在明显的假阳性情况下完成： // 在你的代码中留下注释证明这个决定！ reads_a_and_b.ambiguous_with(adds_one_to_b), ), ) .add_plugins(DefaultPlugins) .run(); 关键要点： 默认情况下，系统并行运行，顺序是非确定性的 使用 .after() 和 .before() 明确指定顺序 使用 .ambiguous_with() 静默歧义 使用 ScheduleBuildSettings 配置歧义检测 注意事项： 非确定性顺序可能导致微妙的错误 使用 .after() 和 .before() 明确指定顺序 注意歧义检测的性能影响 最佳实践： 对于有数据访问冲突的系统，明确指定顺序 使用 .ambiguous_with() 静默明显的假阳性 注意歧义检测的性能影响 实际应用在游戏开发中的应用场景系统调度在游戏开发中有广泛的应用： 游戏逻辑：使用 Update Schedule 运行游戏逻辑 物理模拟：使用 FixedUpdate Schedule 运行物理模拟 初始化：使用 Startup Schedule 运行初始化代码 清理：使用 Last Schedule 运行清理代码 常见问题问题 1：如何控制系统执行顺序？ 解决方案： 使用 .before() 和 .after() 方法控制顺序 使用系统集组织系统 使用 .chain() 方法链式系统 问题 2：如何创建自定义 Schedule？ 解决方案： 使用 Schedule::new() 创建自定义 Schedule 使用 ScheduleLabel 派生宏定义 Schedule 标签 使用 MainScheduleOrder 配置 Schedule 顺序 问题 3：如何控制系统是否运行？ 解决方案： 使用 .run_if() 方法添加运行条件 使用 .and() 和 .or() 组合运行条件 使用 not() 反转运行条件 性能考虑 并行执行：系统可以并行执行，但可变访问会阻止并行 系统顺序：明确指定系统顺序可以提高性能 运行条件：注意运行条件的性能影响 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例（系统调度） bevy/examples/ecs/custom_schedule.rs - 自定义 Schedule 示例 bevy/examples/ecs/fixed_timestep.rs - 固定时间步示例 bevy/examples/ecs/run_conditions.rs - 运行条件示例 bevy/examples/ecs/system_stepping.rs - 系统步进示例 bevy/examples/ecs/nondeterministic_system_order.rs - 非确定性系统顺序示例 官方文档链接： Bevy Schedule 官方文档 App 官方文档 SystemSet 文档 进一步学习建议： 学习系统（Systems），了解如何定义系统 学习资源（Resources），了解如何访问资源 学习 ECS 进阶，了解系统调度的高级功能 索引：返回上级目录"},{"title":"系统（Systems）","path":"/Luo-Haomin/wiki/BevyBook/ECS/系统（Systems）.html","content":"系统（Systems）概述学习目标： 理解系统的概念和作用 掌握如何定义和使用系统 了解系统参数类型 理解系统闭包、泛型系统、一次性系统等高级功能 前置知识要求： 核心编程框架（ECS） 组件（Components） 实体（Entities） Rust 基础语法 核心概念什么是系统？系统是在实体、组件和资源上运行逻辑的函数。系统是 ECS 中的逻辑单元，用于处理游戏逻辑。 为什么使用系统？ 逻辑分离：将游戏逻辑分离为独立的系统 并行执行：系统可以并行执行，提高性能 易于测试：系统可以独立测试 系统的设计思想系统采用数据导向的设计思想，将数据（组件）和逻辑（系统）分离。这种设计使得： 系统可以独立开发和测试 系统可以并行执行，提高性能 系统可以灵活组合，实现复杂的游戏逻辑 基础用法定义系统系统是普通 Rust 函数，用于处理实体、组件和资源。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 这是最简单的系统类型。它只是每次运行时打印 This game is fun!fn print_message_system() println!(This game is fun!);// 系统也可以读取和修改资源。这个系统在每次更新时开始一个新的轮次// 注意：mut 表示资源是可变的// ResGameRules 是只读的。ResMutGameState 可以修改资源fn new_round_system(game_rules: ResGameRules, mut game_state: ResMutGameState) game_state.current_round += 1; println!( Begin round of , game_state.current_round, game_rules.max_rounds );// 这个系统更新所有具有 `Player`、`Score` 和 `PlayerStreak` 组件的实体的分数fn score_system(mut query: Query(Player, mut Score, mut PlayerStreak)) for (player, mut score, mut streak) in mut query let scored_a_point = random::bool(); if scored_a_point // 不可变访问组件通过常规引用完成 - `player` 的类型是 `Player` // 可变访问组件通过 `MutT` 类型完成 - `score` 的类型是 `MutScore` // `MutT` 实现了 `DerefT`，所以可以使用标准字段更新语法 score.value += 1; // 匹配枚举需要解引用 *streak = match *streak PlayerStreak::Hot(n) = PlayerStreak::Hot(n + 1), PlayerStreak::Cold(_) | PlayerStreak::None = PlayerStreak::Hot(1), ; println!( scored a point! Their score is: (), player.name, score.value, *streak ); 关键要点： 系统是普通 Rust 函数 系统可以访问资源（ResT、ResMutT） 系统可以查询组件（QueryT） 系统可以创建和修改实体（Commands） 系统在每次应用更新时运行 说明：系统是 ECS 中的逻辑单元。系统通过查询访问组件，通过 Res 或 ResMut 访问资源。系统可以并行执行，提高性能。 系统参数类型系统可以使用多种参数类型来访问不同的数据。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 这个系统在所有具有 `Player` 和 `Score` 组件的实体上运行// 它还访问 `GameRules` 资源来确定玩家是否获胜fn score_check_system( game_rules: ResGameRules, mut game_state: ResMutGameState, query: Query(Player, Score),) for (player, score) in query if score.value == game_rules.winning_score game_state.winning_player = Some(player.name.clone()); 关键要点： ResT：只读访问资源 ResMutT：可变访问资源 QueryT：查询组件 Commands：创建和修改实体 系统可以同时使用多种参数类型 说明：系统参数必须实现 SystemParam trait。Bevy 提供了多种系统参数类型，如 Res、ResMut、Query、Commands 等。 进阶用法系统闭包系统可以是闭包，允许捕获外部变量。 源代码文件：bevy/examples/ecs/system_closure.rs 代码示例： fn main() // 创建一个简单的闭包 let simple_closure = || // 这是一个什么都不做的闭包 info!(Hello from a simple closure!); ; // 创建一个带有input值的闭包 let complex_closure = |mut value: String| move || info!(Hello from a complex closure! , value); // 我们可以在闭包内修改值。这将在调用之间保存 value = format!(value - updated); ; let outside_variable = bar.to_string(); App::new() .add_plugins(LogPlugin::default()) // 我们可以使用闭包作为系统 .add_systems(Update, simple_closure) // 或者我们可以使用更复杂的闭包，并传递参数来初始化 Local 变量 .add_systems(Update, complex_closure(foo.into())) // 我们也可以内联闭包 .add_systems(Update, || info!(Hello from an inlined closure!); ) // 或使用闭包外部的变量 .add_systems(Update, move || info!( Hello from an inlined closure that captured the outside_variable! , outside_variable ); // 你可以使用 outside_variable 或此闭包内的任何其他变量 // 它们的状态将被保存 ) .run(); 关键要点： 系统可以是闭包 闭包可以捕获外部变量 使用 move 关键字移动变量到闭包中 闭包可以用于简单的系统逻辑 注意事项： 闭包捕获的变量会在系统调用之间保持状态 使用 move 关键字会移动变量到闭包中 注意闭包的生命周期和所有权 最佳实践： 对于简单的系统逻辑，使用闭包 对于复杂的系统逻辑，使用普通函数 注意闭包捕获的变量的生命周期 泛型系统泛型系统允许在不同类型上重用逻辑。 源代码文件：bevy/examples/ecs/generic_system.rs 代码示例： // 类型参数在函数名之后，但在普通参数之前// 这里，`Component` trait 是 T 的 trait 约束，我们的泛型类型fn cleanup_systemT: Component(mut commands: Commands, query: QueryEntity, WithT) for e in query commands.entity(e).despawn(); fn main() App::new() .add_plugins(DefaultPlugins) .init_state::AppState() .add_systems(Startup, setup_system) .add_systems( Update, ( print_text_system, transition_to_in_game_system.run_if(in_state(AppState::MainMenu)), ), ) // 清理系统 // 使用 ::T (turbofish) 语法传递系统应该操作的类型 .add_systems(OnExit(AppState::MainMenu), cleanup_system::MenuClose) .add_systems(OnExit(AppState::InGame), cleanup_system::LevelUnload) .run(); 关键要点： 泛型系统允许在不同类型上重用逻辑 使用 ::T (turbofish) 语法指定类型 泛型类型必须满足 trait 约束 泛型系统可以用于处理相关组件或资源 注意事项： 泛型系统需要为每个类型创建专门的副本 确保为每个类型都注册了系统 泛型系统可以结合用户定义的 trait 使用 最佳实践： 对于处理相关组件或资源的系统，使用泛型系统 结合用户定义的 trait 使用泛型系统 确保为每个类型都注册了系统 一次性系统一次性系统在触发时运行一次，而不是每次更新都运行。 源代码文件：bevy/examples/ecs/one_shot_systems.rs 代码示例： use bevy:: ecs::system::RunSystemOnce, SystemId, prelude::*,;#[derive(Component)]struct Callback(SystemId);#[derive(Component)]struct Triggered;fn setup_with_commands(mut commands: Commands) let system_id = commands.register_system(system_a); commands.spawn((Callback(system_id), A));fn setup_with_world(world: mut World) // 我们可以手动运行一次 world.run_system_once(system_b).unwrap(); // 或使用 Callback let system_id = world.register_system(system_b); world.spawn((Callback(system_id), B));/// 用 `Triggered` 组件标记具有我们想要运行的回调的实体fn trigger_system( mut commands: Commands, query_a: SingleEntity, WithA, query_b: SingleEntity, WithB, input: ResButtonInputKeyCode,) if input.just_pressed(KeyCode::KeyA) let entity = *query_a; commands.entity(entity).insert(Triggered); if input.just_pressed(KeyCode::KeyB) let entity = *query_b; commands.entity(entity).insert(Triggered); /// 如果实体也有 `Triggered` 组件，则运行与每个 `Callback` 组件关联的系统////// 这可以在独占系统中完成，而不是使用 `Commands`（如果首选）fn evaluate_callbacks(query: Query(Entity, Callback), WithTriggered, mut commands: Commands) for (entity, callback) in query.iter() commands.run_system(callback.0); commands.entity(entity).remove::Triggered(); fn system_a(entity_a: SingleEntity, WithText, mut writer: TextUiWriter) *writer.text(*entity_a, 3) = String::from(A); info!(A: One shot system registered with Commands was triggered);fn system_b(entity_b: SingleEntity, WithText, mut writer: TextUiWriter) *writer.text(*entity_b, 3) = String::from(B); info!(B: One shot system registered with World was triggered); 关键要点： 一次性系统在触发时运行一次 使用 register_system() 注册系统 使用 run_system() 或 run_system_once() 运行系统 一次性系统可以用于推送式逻辑 注意事项： 一次性系统可以减少很少运行的系统开销 一次性系统可以提高调度灵活性 一次性系统可以用于事件驱动的逻辑 最佳实践： 对于很少运行的系统，使用一次性系统 对于事件驱动的逻辑，使用一次性系统 注意一次性系统的生命周期管理 系统管道系统管道允许将多个系统连接在一起，将第一个系统的输出传递给下一个系统。 源代码文件：bevy/examples/ecs/system_piping.rs 代码示例： // 这个系统通过尝试解析 Message 资源产生 Resultusize 输出fn parse_message_system(message: ResMessage) - Resultusize, ParseIntError message.parse::usize()// 这个系统接受 Resultusize 输入，并打印解析的值或错误消息// 尝试将 Message 资源更改为不是整数的内容。你应该看到错误消息被打印fn handler_system(In(result): InResultusize, ParseIntError) match result Ok(value) = println!(parsed message: value), Err(err) = println!(encountered an error: err:?), fn main() App::new() .insert_resource(Message(42.to_string())) .add_systems( Update, ( parse_message_system.pipe(handler_system), data_pipe_system.map(|out| info!(out)), parse_message_system.map(|out| debug!(out:?)), ), ) .run(); 关键要点： 使用 .pipe() 方法将系统连接在一起 使用 .map() 方法转换系统输出 系统管道允许将多个系统连接在一起 系统管道可以用于错误处理和数据转换 注意事项： 系统管道要求系统输出类型匹配下一个系统的输入类型 系统管道可以用于错误处理 系统管道可以用于数据转换 最佳实践： 对于需要错误处理的系统，使用系统管道 对于需要数据转换的系统，使用系统管道 注意系统管道的类型匹配 独占系统独占系统提供对 ECS World 的完全直接访问。它们不能与其他系统并行运行，因为它们可以访问任何东西并做任何事情。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 如果你真的需要完整、立即的读写访问世界或资源，你可以使用独占系统// 警告：这些会阻止所有其他系统的并行执行，直到它们完成// 所以如果你想要最大化并行性，通常应该避免它们fn exclusive_player_system(world: mut World) // 这与 new_player_system 做同样的事情 let total_players = world.resource_mut::GameState().total_players; let should_add_player = let game_rules = world.resource::GameRules(); let add_new_player = random::bool(); add_new_player total_players game_rules.max_players ; // 随机添加一个新玩家 if should_add_player println!(Player has joined the game!, total_players + 1); world.spawn(( Player name: format!(Player , total_players + 1), , Score value: 0 , PlayerStreak::None, )); let mut game_state = world.resource_mut::GameState(); game_state.total_players += 1; 关键要点： 独占系统提供对 World 的完全访问 独占系统不能与其他系统并行运行 独占系统应该尽量避免，以最大化并行性 独占系统可以用于需要完全访问的场景 注意事项： 独占系统会阻止所有其他系统的并行执行 独占系统应该尽量避免 独占系统可以用于需要完全访问的场景 最佳实践： 尽量避免使用独占系统 只在必要时使用独占系统 考虑使用 Commands 代替独占系统 可失败系统参数可失败系统参数在无法获取时会跳过系统，而不是导致错误。 源代码文件：bevy/examples/ecs/fallible_params.rs 代码示例： // 这个系统只在恰好有一个匹配实体时运行fn track_targets( // `Single` 确保系统只在恰好有一个匹配实体时运行 mut player: Single(mut Transform, Player), // `OptionSingle` 永远不会阻止系统运行，但如果没有恰好一个匹配实体，它将是 `None` enemy: OptionSingleTransform, (WithEnemy, WithoutPlayer), time: ResTime,) let (player_transform, player) = mut *player; if let Some(enemy_transform) = enemy // 找到敌人，旋转并朝它移动 // ... else // 找到 0 个或多个敌人，继续搜索 // ... // 这个系统只在至少有一个匹配实体时运行fn move_targets(mut enemies: Populated(mut Transform, mut Enemy), time: ResTime) for (mut transform, mut target) in mut *enemies // ... 关键要点： SingleD, F：必须有恰好一个匹配实体，否则系统会被静默跳过 OptionSingleD, F：必须有零个或一个匹配实体，如果有多个，系统会被静默跳过 PopulatedD, F：必须至少有一个匹配实体，否则系统会被静默跳过 可失败系统参数可以用于条件系统执行 注意事项： 可失败系统参数在无法获取时会跳过系统 其他系统参数（如 Query）永远不会失败验证 可失败系统参数可以用于条件系统执行 最佳实践： 对于需要恰好一个实体的系统，使用 Single 对于需要零个或一个实体的系统，使用 OptionSingle 对于需要至少一个实体的系统，使用 Populated 系统错误处理系统可以返回 Result 来处理错误。 源代码文件：bevy/examples/ecs/error_handling.rs 代码示例： use bevy::ecs::error::warn;fn main() let mut app = App::new(); // 默认情况下，返回错误的可失败系统会 panic // // 我们可以通过设置自定义错误处理器来改变这一点，它适用于整个应用 // （你也可以为特定的 `World` 设置它） // 这里我们使用内置错误处理器之一 // Bevy 为 `panic`、`error`、`warn`、`info`、`debug`、`trace` 和 `ignore` 提供内置处理器 app.set_error_handler(warn); app.add_plugins(DefaultPlugins); app.add_systems(Startup, setup); app.add_systems(Startup, failing_commands); // 单个系统也可以通过管道输出结果来处理： app.add_systems( PostStartup, failing_system.pipe(|result: InResult| let _ = result.0.inspect_err(|err| info!(captured error: err)); ), ); // 可失败观察者也被支持 app.add_observer(fallible_observer); app.run();/// 一个调用多个可失败函数并使用问号运算符的系统的示例fn setup( mut commands: Commands, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) - Result // ... Ok(())/// 这个系统总是失败验证，因为我们从未创建同时具有 `Player` 和 `Enemy` 组件的实体fn failing_system(world: mut World) - Result world // `get_resource` 返回 `OptionT`，所以我们使用 `ok_or` 将其转换为 `Result` // 然后我们可以调用 `?` 来传播错误 .get_resource::UninitializedResource() // 我们可以在这里提供 `str`，因为 `BevyError` 实现了 `Fromstr` .ok_or(Resource not initialized)?; Ok(()) 关键要点： 系统可以返回 Result(), BevyError 来处理错误 使用 set_error_handler() 设置错误处理器 使用 .pipe() 方法处理系统错误 可失败系统可以用于错误处理 注意事项： 默认情况下，返回错误的系统会 panic 可以设置自定义错误处理器 系统错误可以通过管道处理 最佳实践： 对于可能失败的操作，使用可失败系统 设置适当的错误处理器 使用系统管道处理错误 实际应用在游戏开发中的应用场景系统在游戏开发中有广泛的应用： 游戏逻辑：移动系统、伤害系统、AI 系统等 渲染系统：渲染系统、UI 系统等 物理系统：物理模拟、碰撞检测等 常见问题问题 1：何时使用普通系统，何时使用独占系统？ 解决方案： 大多数情况下使用普通系统 只在需要完全访问 World 时使用独占系统 考虑使用 Commands 代替独占系统 问题 2：如何控制系统的执行顺序？ 解决方案： 使用 .before() 和 .after() 方法控制顺序 使用系统集（SystemSet）组织系统 使用系统管道连接系统 问题 3：如何处理系统错误？ 解决方案： 使用可失败系统返回 Result 设置适当的错误处理器 使用系统管道处理错误 性能考虑 系统粒度：保持系统粒度细，只访问需要的数据 并行执行：系统可以并行执行，但可变访问会阻止并行 系统数量：避免过多的小系统，考虑合并相关系统 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例（系统定义） bevy/examples/ecs/system_closure.rs - 系统闭包示例 bevy/examples/ecs/generic_system.rs - 泛型系统示例 bevy/examples/ecs/one_shot_systems.rs - 一次性系统示例 bevy/examples/ecs/system_piping.rs - 系统管道示例 bevy/examples/ecs/system_param.rs - 自定义系统参数示例 bevy/examples/ecs/error_handling.rs - 系统错误处理示例 bevy/examples/ecs/fallible_params.rs - 可失败系统参数示例 官方文档链接： Bevy System 官方文档 SystemParam 文档 进一步学习建议： 学习查询（Queries），了解如何访问组件 学习资源（Resources），了解如何访问资源 学习系统调度（Schedule App），了解如何控制系统执行 索引：返回上级目录"},{"title":"组件（Components）","path":"/Luo-Haomin/wiki/BevyBook/ECS/组件（Components）.html","content":"组件（Components）概述学习目标： 理解组件的概念和作用 掌握如何定义和使用组件 了解组件类型和存储方式 理解不可变组件的使用场景 前置知识要求： 核心编程框架（ECS） Rust 基础语法 理解基本的 Rust 类型系统 核心概念什么是组件？组件是普通 Rust 数据类型，通过 #[derive(Component)] 标记。组件是 ECS 中最基本的数据单元，每个组件代表实体的一个属性或特征。 为什么使用组件？ 数据导向：功能由数据驱动，而非继承层次 灵活组合：组件可以灵活组合，创建不同的实体 性能优化：组件存储优化，提高缓存命中率 组件的设计思想组件采用数据导向的设计思想，将数据（组件）和逻辑（系统）分离。这种设计使得： 系统可以独立开发和测试 组件可以灵活组合 系统可以并行执行，提高性能 基础用法定义组件组件是普通 Rust 数据类型，通过 #[derive(Component)] 标记。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 我们的游戏将有一些玩家。每个玩家都有一个名称来标识他们#[derive(Component)]struct Player name: String,// 每个玩家也有一个分数。这个组件保存分数#[derive(Component)]struct Score value: usize,// 枚举也可以用作组件// 这个组件跟踪玩家连续得分或未得分的轮数#[derive(Component)]enum PlayerStreak Hot(usize), None, Cold(usize), 关键要点： 组件是普通 Rust 结构体或枚举 使用 #[derive(Component)] 标记组件 组件通常专注于单一功能（如位置、分数、名称） 枚举也可以用作组件 说明：组件是 ECS 中最基本的数据单元。每个组件代表实体的一个属性或特征。例如，Player 组件表示实体是一个玩家，Score 组件表示实体的分数。 组件类型组件可以是结构体或枚举，可以是任何实现了 Component trait 的类型。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 结构体组件#[derive(Component)]struct Player name: String,// 枚举组件#[derive(Component)]enum PlayerStreak Hot(usize), None, Cold(usize),// 元组结构体组件#[derive(Component)]struct Position(f32, f32);// 单元结构体组件#[derive(Component)]struct Marker; 关键要点： 组件可以是结构体、枚举、元组结构体或单元结构体 组件必须实现 Component trait 使用 #[derive(Component)] 自动实现 Component trait 说明：组件可以是任何 Rust 数据类型，只要实现了 Component trait。使用 #[derive(Component)] 可以自动实现 Component trait。 进阶用法不可变组件不可变组件一旦插入到 ECS 中，就只能查看或移除，不能修改。替换是允许的，因为这等同于移除和插入。 源代码文件：bevy/examples/ecs/immutable_components.rs 代码示例： /// 这是可变组件，默认情况/// 这通过组件实现 [`Component`] 来表示，其中 [`Component::Mutability`] 是 [`Mutable`]#[derive(Component)]pub struct MyMutableComponent(bool);/// 这是不可变组件。一旦插入到 ECS 中，它只能被查看或移除/// 替换也是允许的，因为这等同于移除和插入////// 添加 `#[component(immutable)]` 属性可以防止在派生宏中实现 [`ComponentMutability = Mutable`]#[derive(Component)]#[component(immutable)]pub struct MyImmutableComponent(bool);fn demo_1(world: mut World) // 不可变组件可以像可变组件一样插入 let mut entity = world.spawn((MyMutableComponent(false), MyImmutableComponent(false))); // 但是可变组件可以被修改... let mut my_mutable_component = entity.get_mut::MyMutableComponent().unwrap(); my_mutable_component.0 = true; // ...不可变组件不能。下面的代码无法编译，因为 `MyImmutableComponent` 被声明为不可变 // let mut my_immutable_component = entity.get_mut::MyImmutableComponent().unwrap(); // 相反，你可以获取或替换不可变组件来更新其值 let mut my_immutable_component = entity.take::MyImmutableComponent().unwrap(); my_immutable_component.0 = true; entity.insert(my_immutable_component); 关键要点： 使用 #[component(immutable)] 属性定义不可变组件 不可变组件不能被修改，只能查看或移除 替换不可变组件是允许的，等同于移除和插入 不可变组件可以完全捕获所有变更，通过组件钩子保持 ECS 的其他部分同步 注意事项： 不可变组件不能使用 get_mut() 方法 必须使用 take() 和 insert() 方法来更新不可变组件 不可变组件适合用于标识符、名称等不应该改变的数据 最佳实践： 对于不应该改变的数据（如名称、ID），使用不可变组件 对于需要频繁修改的数据，使用可变组件 使用不可变组件配合组件钩子来维护索引 组件存储组件可以存储在不同的存储类型中，影响性能和内存使用。 关键要点： Table 存储：默认存储类型，适合大多数组件 SparseSet 存储：适合不经常使用的组件 存储类型影响查询性能和内存使用 说明：Bevy 使用两种主要的组件存储类型：Table 和 SparseSet。Table 存储适合大多数组件，提供良好的缓存局部性。SparseSet 存储适合不经常使用的组件，提供更灵活的内存布局。 实际应用在游戏开发中的应用场景组件在游戏开发中有广泛的应用： 游戏对象属性：位置、速度、生命值、颜色等 游戏状态：玩家状态、敌人状态、道具状态等 标识符：名称、ID、标签等 常见问题问题 1：何时使用结构体组件，何时使用枚举组件？ 解决方案： 结构体组件用于存储多个相关数据（如位置、速度） 枚举组件用于表示状态或选项（如玩家状态、游戏状态） 问题 2：何时使用不可变组件？ 解决方案： 对于不应该改变的数据（如名称、ID），使用不可变组件 对于需要频繁修改的数据，使用可变组件 使用不可变组件配合组件钩子来维护索引 问题 3：如何选择组件存储类型？ 解决方案： 大多数组件使用默认的 Table 存储 不经常使用的组件可以考虑使用 SparseSet 存储 根据实际性能需求选择存储类型 性能考虑 组件布局：相关组件应该放在一起，提高缓存命中率 组件大小：保持组件大小合理，避免过大的组件 组件数量：避免在单个实体上添加过多组件 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例（组件定义） bevy/examples/ecs/immutable_components.rs - 不可变组件示例 官方文档链接： Bevy Component 官方文档 Component 存储文档 进一步学习建议： 学习实体（Entities），了解如何将组件附加到实体 学习查询（Queries），了解如何访问组件 学习 ECS 进阶，了解组件生命周期钩子等高级功能 索引：返回上级目录"},{"title":"资源（Resources）","path":"/Luo-Haomin/wiki/BevyBook/ECS/资源（Resources）.html","content":"资源（Resources）概述学习目标： 理解资源的概念和作用 掌握如何定义和使用资源 了解资源的初始化方法 理解资源的生命周期管理 前置知识要求： 核心编程框架（ECS） 组件（Components） 系统（Systems） Rust 基础语法 核心概念什么是资源？资源是共享的全局数据，可以在任何系统中访问。资源是全局唯一的，不需要附加到实体上。 为什么使用资源？ 全局状态：资源用于存储全局状态，如游戏设置、配置信息等 共享数据：资源可以在任何系统中访问，便于共享数据 性能优化：资源访问比查询更高效 资源的设计思想资源采用数据导向的设计思想，将全局数据（资源）和逻辑（系统）分离。这种设计使得： 系统可以高效访问全局数据 资源可以在任何系统中访问 资源可以灵活管理全局状态 基础用法定义资源资源是普通 Rust 数据类型，通过 #[derive(Resource)] 标记。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 这个资源保存游戏信息#[derive(Resource, Default)]struct GameState current_round: usize, total_players: usize, winning_player: OptionString,// 这个资源提供游戏的规则#[derive(Resource)]struct GameRules winning_score: usize, max_rounds: usize, max_players: usize, 关键要点： 资源是普通 Rust 结构体或枚举 使用 #[derive(Resource)] 标记资源 使用 Default trait 可以自动初始化资源 资源用于存储全局状态 说明：资源用于存储全局状态，如游戏设置、配置信息等。与组件不同，资源是全局唯一的，不需要附加到实体上。 访问资源使用 ResT 和 ResMutT 访问资源。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 系统也可以读取和修改资源。这个系统在每次更新时开始一个新的轮次// 注意：mut 表示资源是可变的// ResGameRules 是只读的。ResMutGameState 可以修改资源fn new_round_system(game_rules: ResGameRules, mut game_state: ResMutGameState) game_state.current_round += 1; println!( Begin round of , game_state.current_round, game_rules.max_rounds );// 这个系统在所有具有 `Player` 和 `Score` 组件的实体上运行// 它还访问 `GameRules` 资源来确定玩家是否获胜fn score_check_system( game_rules: ResGameRules, mut game_state: ResMutGameState, query: Query(Player, Score),) for (player, score) in query if score.value == game_rules.winning_score game_state.winning_player = Some(player.name.clone()); 关键要点： 使用 ResT 只读访问资源 使用 ResMutT 可变访问资源 资源可以在任何系统中访问 可变访问会阻止并行执行 说明：资源访问与组件访问类似。使用 ResT 可以只读访问资源，使用 ResMutT 可以可变访问资源。资源可以在任何系统中访问，便于共享数据。 进阶用法资源初始化资源可以通过多种方式初始化。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： fn main() App::new() // 实现 Default 或 FromWorld trait 的资源可以这样添加： .init_resource::GameState() // 或者使用 insert_resource 插入资源 .insert_resource(GameRules max_rounds: 10, winning_score: 4, max_players: 4, ) .add_systems(Startup, startup_system) .add_systems(Update, new_round_system) .run();fn startup_system(mut commands: Commands, mut game_state: ResMutGameState) // 创建游戏规则资源 commands.insert_resource(GameRules max_rounds: 10, winning_score: 4, max_players: 4, ); // 设置总玩家数为 2 game_state.total_players = 2; 关键要点： 使用 init_resource::T() 初始化实现 Default 或 FromWorld trait 的资源 使用 insert_resource() 插入资源 使用 Commands::insert_resource() 在系统中插入资源 资源可以在应用构建时或系统运行时初始化 注意事项： init_resource() 要求资源实现 Default 或 FromWorld trait insert_resource() 可以插入任何资源 资源可以在应用构建时或系统运行时初始化 最佳实践： 对于有默认值的资源，使用 init_resource() 对于需要自定义初始化的资源，使用 insert_resource() 在启动系统中初始化资源 资源变更检测资源支持变更检测，可以检测资源的变化。 源代码文件：bevy/examples/ecs/change_detection.rs 代码示例： /// 资源的变更检测概念与组件类似fn change_resource(time: ResTime, mut my_resource: ResMutMyResource) if rand::rng().random_bool(0.1) let new_resource = MyResource(time.elapsed_secs().round()); info!(New value: new_resource:?); // 为了避免在值未实际改变时触发变更检测，可以使用 `set_if_neq` 方法 // 该方法要求资源实现 PartialEq my_resource.set_if_neq(new_resource); fn change_detection( changed_components: QueryRefMyComponent, ChangedMyComponent, my_resource: ResMyResource,) // ... if my_resource.is_changed() warn!( Change detected! \\t- value: :? \\t- added: \\t- changed: \\t- changed by: , my_resource, my_resource.is_added(), my_resource.is_changed(), my_resource.changed_by() // 与组件一样，需要 `track_location` 特性 ); 关键要点： 使用 is_changed() 检查资源是否已变更 使用 is_added() 检查资源是否新添加 使用 set_if_neq() 避免不必要的变更检测 使用 changed_by() 获取变更位置（需要 track_location 特性） 注意事项： 资源的变更检测与组件类似 使用 set_if_neq() 避免不必要的变更检测 changed_by() 需要 track_location 特性 最佳实践： 对于实现 PartialEq 的资源，使用 set_if_neq() 避免不必要的变更检测 使用变更检测响应资源变化 注意变更检测的性能影响 实际应用在游戏开发中的应用场景资源在游戏开发中有广泛的应用： 游戏设置：游戏配置、难度设置等 全局状态：游戏状态、分数、时间等 资源管理：资源服务器、资源缓存等 常见问题问题 1：何时使用资源，何时使用组件？ 解决方案： 资源用于全局共享的数据（如游戏设置、资源服务器） 组件用于实体特有的数据（如位置、速度） 如果数据是全局唯一的，使用资源；如果是实体特有的，使用组件 问题 2：如何初始化资源？ 解决方案： 对于有默认值的资源，使用 init_resource() 对于需要自定义初始化的资源，使用 insert_resource() 在启动系统中初始化资源 问题 3：如何检测资源变化？ 解决方案： 使用 is_changed() 检查资源是否已变更 使用 is_added() 检查资源是否新添加 使用 set_if_neq() 避免不必要的变更检测 性能考虑 资源访问：资源访问比查询更高效 变更检测：注意变更检测的性能影响 资源数量：避免过多的资源，考虑合并相关资源 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例（资源定义和使用） bevy/examples/ecs/change_detection.rs - 变更检测示例（资源变更检测） 官方文档链接： Bevy Resource 官方文档 Resource 初始化文档 进一步学习建议： 学习系统（Systems），了解如何在系统中访问资源 学习系统调度（Schedule App），了解资源的生命周期 学习 ECS 进阶，了解资源的高级功能 索引：返回上级目录"},{"title":"UI & Audio & Window（界面、音频与窗口）","path":"/Luo-Haomin/wiki/BevyBook/UI_Audio_Window/README.html","content":"UI Audio Window（界面、音频与窗口）本部分介绍如何在 Bevy 中创建用户界面、处理音频和管理窗口。 内容列表1. 窗口管理 窗口创建与配置 窗口属性（大小、标题、全屏） 窗口事件处理 多窗口支持 透明窗口 窗口截图 学习目标：能够创建和管理应用程序窗口 2. 用户界面（UI） UI 系统概述 UI 组件（Button、Text、Image 等） UI 布局（Flexbox、Grid） UI 样式（Style） UI 交互（点击、悬停） UI 状态管理 学习目标：能够创建完整的用户界面 3. 音频系统 音频资源加载 背景音乐（BGM） 音效（SFX） 音频控制（播放、暂停、音量、速度） 3D 音频（空间音频） 音频轨道 学习目标：能够创建完整的音频系统 学习建议 UI 设计：学习现代 UI 设计原则 响应式设计：考虑不同屏幕尺寸的适配 音频设计：理解音频在游戏中的作用 用户体验：关注 UI 和音频的用户体验 相关资源 Bevy UI 官方文档 Bevy Audio 官方文档 UI 示例 音频示例 下一步完成本部分学习后，建议继续学习： Architecture（架构设计） - 组织完整的游戏项目 Advanced（高级主题） - 深入高级功能 索引：返回主目录"},{"title":"查询（Queries）","path":"/Luo-Haomin/wiki/BevyBook/ECS/查询（Queries）.html","content":"查询（Queries）概述学习目标： 理解查询的概念和作用 掌握如何定义和使用查询 了解查询过滤器的使用方法 理解自定义查询参数和查询组合 前置知识要求： 核心编程框架（ECS） 组件（Components） 实体（Entities） 系统（Systems） Rust 基础语法 核心概念什么是查询？查询用于访问具有特定组件的实体。查询会自动过滤出具有指定组件的实体，并允许系统对这些实体进行操作。 为什么使用查询？ 自动过滤：查询自动过滤出具有指定组件的实体 高效访问：查询提供高效的组件访问方式 并行执行：查询可以并行执行，提高性能 查询的设计思想查询采用数据导向的设计思想，将数据（组件）和逻辑（系统）分离。这种设计使得： 系统可以高效访问组件 查询可以并行执行，提高性能 查询可以灵活组合，实现复杂的查询需求 基础用法基本查询使用 QueryT 查询具有特定组件的实体。 源代码文件：bevy/examples/ecs/ecs_guide.rs 代码示例： // 这个系统更新所有具有 `Player`、`Score` 和 `PlayerStreak` 组件的实体的分数fn score_system(mut query: Query(Player, mut Score, mut PlayerStreak)) for (player, mut score, mut streak) in mut query let scored_a_point = random::bool(); if scored_a_point // 不可变访问组件通过常规引用完成 - `player` 的类型是 `Player` // 可变访问组件通过 `MutT` 类型完成 - `score` 的类型是 `MutScore` // `MutT` 实现了 `DerefT`，所以可以使用标准字段更新语法 score.value += 1; // 匹配枚举需要解引用 *streak = match *streak PlayerStreak::Hot(n) = PlayerStreak::Hot(n + 1), PlayerStreak::Cold(_) | PlayerStreak::None = PlayerStreak::Hot(1), ; println!( scored a point! Their score is: (), player.name, score.value, *streak ); // 这个系统在所有具有 `Player` 和 `Score` 组件的实体上运行// 它还访问 `GameRules` 资源来确定玩家是否获胜fn score_check_system( game_rules: ResGameRules, mut game_state: ResMutGameState, query: Query(Player, Score),) for (player, score) in query if score.value == game_rules.winning_score game_state.winning_player = Some(player.name.clone()); 关键要点： 使用 QueryT 查询具有特定组件的实体 T 表示不可变访问组件 mut T 表示可变访问组件 查询可以同时访问多个组件 使用 MutT 类型进行可变访问 说明：查询是访问组件的主要方式。查询会自动过滤出具有指定组件的实体，并允许系统对这些实体进行操作。查询可以并行执行，提高性能。 查询过滤器使用查询过滤器进一步过滤查询结果。 源代码文件：bevy/examples/ecs/change_detection.rs 代码示例： /// 查询过滤器如 [`ChangedT`] 和 [`AddedT`] 确保只有匹配这些过滤器的实体/// 才会被查询返回////// 使用 [`RefT`] 系统参数允许你访问变更检测信息，但不会过滤查询fn change_detection( changed_components: QueryRefMyComponent, ChangedMyComponent, my_resource: ResMyResource,) for component in changed_components // 默认情况下，你只能知道组件被改变了 // 但如果有多个系统修改同一个组件，如何知道是哪个系统导致的改变？ warn!( Change detected! \\t- value: :? \\t- added: \\t- changed: \\t- changed by: , component, component.is_added(), component.is_changed(), // 如果启用 `track_location` 特性，可以解锁 `changed_by()` 方法 // 它返回组件或资源被改变的文件和行号 // 不建议在发布的游戏中使用，但对调试很有用！ component.changed_by() ); 关键要点： 使用 ChangedT 过滤器查询已变更的组件 使用 AddedT 过滤器查询新添加的组件 使用 WithT 过滤器查询具有特定组件的实体 使用 WithoutT 过滤器查询不具有特定组件的实体 使用 RefT 访问变更检测信息，但不过滤查询 说明：查询过滤器用于进一步过滤查询结果。使用 ChangedT 过滤器可以只查询已变更的组件，这对于性能优化很重要。使用 AddedT 过滤器可以只查询新添加的组件。 进阶用法自定义查询参数使用 QueryData 派生宏定义自定义查询类型，避免使用元组。 源代码文件：bevy/examples/ecs/custom_query_param.rs 代码示例： use bevy:: ecs::query::QueryData, QueryFilter, prelude::*,;#[derive(Component, Debug)]struct ComponentA;#[derive(Component, Debug)]struct ComponentB;#[derive(Component, Debug)]struct ComponentC;#[derive(Component, Debug)]struct ComponentD;/// 虽然常规元组查询在大多数简单场景中工作得很好/// 但使用声明为命名结构体的自定义查询可以带来以下优势：/// - 它们有助于避免解构或使用 `q.0, q.1, ...` 访问模式/// - 使用结构体添加、移除组件或更改项目顺序大大减少了维护负担/// - 命名结构体支持组合模式，使查询类型更容易重用/// - 你可以绕过查询元组存在的 15 个组件的限制#[derive(QueryData)]#[query_data(derive(Debug))]struct ReadOnlyCustomQueryT: Component + Debug, P: Component + Debug entity: Entity, a: static ComponentA, b: Optionstatic ComponentB, nested: NestedQuery, optional_nested: OptionNestedQuery, optional_tuple: Option(static ComponentB, static ComponentZ), generic: GenericQueryT, P, empty: EmptyQuery,#[derive(QueryData)]#[query_data(derive(Debug))]struct NestedQuery c: static ComponentC, d: Optionstatic ComponentD,#[derive(QueryData)]#[query_data(derive(Debug))]struct GenericQueryT: Component, P: Component generic: (static T, static P),#[derive(QueryFilter)]struct CustomQueryFilterT: Component, P: Component _c: WithComponentC, _d: WithComponentD, _or: Or(AddedComponentC, ChangedComponentD, WithoutComponentZ), _generic_tuple: (WithT, WithP),fn print_components_read_only( query: Query ReadOnlyCustomQueryComponentC, ComponentD, CustomQueryFilterComponentC, ComponentD, ,) println!(Print components (read_only):); for e in query println!(Entity: , e.entity); println!(A: :?, e.a); println!(B: :?, e.b); println!(Nested: :?, e.nested); println!(Optional nested: :?, e.optional_nested); println!(Optional tuple: :?, e.optional_tuple); println!(Generic: :?, e.generic); println!(); 关键要点： 使用 QueryData 派生宏定义自定义查询类型 自定义查询类型可以避免使用元组 自定义查询类型可以支持组合模式 自定义查询类型可以绕过 15 个组件的限制 使用 QueryFilter 派生宏定义自定义过滤器类型 注意事项： 自定义查询类型需要实现 QueryData trait 自定义过滤器类型需要实现 QueryFilter trait 使用 #[query_data(mutable)] 属性定义可变查询 最佳实践： 对于复杂的查询，使用自定义查询类型 对于需要重用的查询，使用自定义查询类型 对于超过 15 个组件的查询，使用自定义查询类型 查询组合查询组合用于处理实体间的交互，如碰撞检测。 源代码文件：bevy/examples/ecs/iter_combinations.rs 代码示例： use bevy::prelude::*;const GRAVITY_CONSTANT: f32 = 0.001;#[derive(Component, Default)]struct Mass(f32);#[derive(Component, Default)]struct Acceleration(Vec3);fn interact_bodies(mut query: Query(Mass, GlobalTransform, mut Acceleration)) let mut iter = query.iter_combinations_mut(); while let Some([(Mass(m1), transform1, mut acc1), (Mass(m2), transform2, mut acc2)]) = iter.fetch_next() let delta = transform2.translation() - transform1.translation(); let distance_sq: f32 = delta.length_squared(); let f = GRAVITY_CONSTANT / distance_sq; let force_unit_mass = delta * f; acc1.0 += force_unit_mass * *m2; acc2.0 -= force_unit_mass * *m1; 关键要点： 使用 iter_combinations_mut() 获取可变组合迭代器 使用 fetch_next() 获取下一对实体 查询组合会跳过重复的组合（如 (A, B) 和 (B, A)） 查询组合用于处理实体间的成对交互 注意事项： 查询组合用于处理实体间的成对交互 查询组合会跳过重复的组合 查询组合对于大量实体可能较慢 最佳实践： 使用查询组合处理碰撞检测、物理交互等场景 注意性能影响，对于大量实体考虑使用空间分区 考虑使用并行查询组合提高性能 并行查询并行查询使用并行迭代器提高系统执行效率。 源代码文件：bevy/examples/ecs/parallel_query.rs 代码示例： use bevy::ecs::batching::BatchingStrategy, prelude::*;#[derive(Component, Deref)]struct Velocity(Vec2);// 根据速度移动精灵fn move_system(mut sprites: Query(mut Transform, Velocity)) // 在 ComputeTaskPool 上并行计算每个精灵的新位置 // // 此示例仅用于演示目的。对于像加法这样便宜的操作，在只有 128 个元素时 // 使用 ParallelIterator 通常不会比使用普通 Iterator 更快 // 有关何时使用或不使用 ParallelIterator 的更多信息，请参阅 ParallelIterator 文档 sprites .par_iter_mut() .for_each(|(mut transform, velocity)| transform.translation += velocity.extend(0.0); );// 在窗口外反弹精灵fn bounce_system(window: QueryWindow, mut sprites: Query(Transform, mut Velocity)) let Ok(window) = window.single() else return; ; let width = window.width(); let height = window.height(); let left = width / -2.0; let right = width / 2.0; let bottom = height / -2.0; let top = height / 2.0; // 也可以覆盖默认批次大小 // 在这种情况下，选择批次大小为 32 以限制 ParallelIterator 的开销 // 因为取反向量非常便宜 sprites .par_iter_mut() .batching_strategy(BatchingStrategy::fixed(32)) .for_each(|(transform, mut v)| if !(left transform.translation.x transform.translation.x right bottom transform.translation.y transform.translation.y top) // 为简单起见，只反转速度；不使用真实的反弹 v.0 = -v.0; ); 关键要点： 使用 par_iter_mut() 获取并行迭代器 使用 batching_strategy() 自定义批处理策略 并行查询适用于计算密集型操作 对于简单操作，并行查询可能不会更快 注意事项： 并行查询适用于计算密集型操作 对于简单操作，并行查询可能不会更快 可以使用 batching_strategy() 自定义批处理策略 最佳实践： 只在计算密集型操作时使用并行查询 对于简单操作，使用普通查询 根据操作复杂度调整批处理策略 实际应用在游戏开发中的应用场景查询在游戏开发中有广泛的应用： 游戏对象访问：访问玩家、敌人、道具等游戏对象 碰撞检测：使用查询组合检测实体间的碰撞 性能优化：使用并行查询提高系统执行效率 常见问题问题 1：如何查询具有多个组件的实体？ 解决方案：使用元组查询多个组件，如 Query(ComponentA, ComponentB)。 问题 2：如何查询不具有特定组件的实体？ 解决方案：使用 WithoutT 过滤器，如 QueryComponentA, WithoutComponentB。 问题 3：如何优化查询性能？ 解决方案： 只查询需要的组件 使用查询过滤器减少查询的实体数量 对于计算密集型操作，使用并行查询 性能考虑 查询优化：只查询需要的组件，减少查询开销 并行执行：查询可以并行执行，但可变访问会阻止并行 查询组合：注意性能影响，考虑使用空间分区 相关资源相关源代码文件： bevy/examples/ecs/ecs_guide.rs - ECS 完整指南示例（查询使用） bevy/examples/ecs/change_detection.rs - 变更检测示例（查询过滤器） bevy/examples/ecs/custom_query_param.rs - 自定义查询参数示例 bevy/examples/ecs/iter_combinations.rs - 查询组合示例 bevy/examples/ecs/parallel_query.rs - 并行查询示例 官方文档链接： Bevy Query 官方文档 QueryData 文档 QueryFilter 文档 进一步学习建议： 学习系统（Systems），了解如何在系统中使用查询 学习组件（Components），了解如何定义组件 学习 ECS 进阶，了解查询的高级功能 索引：返回上级目录"},{"title":"窗口管理","path":"/Luo-Haomin/wiki/BevyBook/UI_Audio_Window/窗口.html","content":"窗口管理概述学习目标： 理解窗口管理的基本概念 掌握窗口的创建和配置 了解窗口属性的设置 学会处理多窗口场景 前置知识要求： Bevy 快速入门 ECS 基础 核心概念什么是窗口管理？窗口管理是 Bevy 中用于创建和管理应用程序窗口的功能。Bevy 支持创建多个窗口、配置窗口属性、处理窗口事件等。 为什么需要窗口管理？ 用户界面：窗口是应用程序的用户界面 多窗口支持：可以创建多个窗口来显示不同的内容 窗口配置：可以配置窗口的大小、标题、主题等属性 窗口事件：可以处理窗口事件，如关闭、调整大小等 窗口管理的核心组件Bevy 窗口管理包含以下核心组件： Window：窗口组件，包含窗口的配置信息 WindowPlugin：窗口插件，负责创建和管理窗口 WindowRef：窗口引用，用于引用特定的窗口 WindowLevel：窗口层级，控制窗口的显示顺序 基础用法窗口创建和配置创建和配置窗口。 源代码文件：bevy/examples/window/window_settings.rs 代码示例： use bevy::prelude::*;use bevy::window::PresentMode, WindowLevel, WindowTheme;fn main() App::new() .add_plugins(DefaultPlugins.set(WindowPlugin primary_window: Some(Window title: 我的窗口.into(), name: Some(bevy.app.into()), resolution: (800, 600).into(), present_mode: PresentMode::AutoVsync, window_theme: Some(WindowTheme::Dark), enabled_buttons: bevy::window::EnabledButtons maximize: false, ..Default::default() , visible: false, ..default() ), ..default() )) .add_systems(Update, make_visible) .run();fn make_visible(mut window: Singlemut Window, frames: ResFrameCount) if frames.0 == 3 window.visible = true; 关键要点： 可以通过 WindowPlugin 配置主窗口 可以设置窗口的标题、大小、主题等属性 可以控制窗口的可见性 可以禁用窗口按钮（如最大化按钮） 说明：窗口创建和配置是应用程序的基础。通过配置窗口属性，可以创建符合需求的用户界面。 窗口属性设置设置窗口的各种属性。 源代码文件：bevy/examples/window/window_settings.rs 代码示例： use bevy::prelude::*;use bevy::window::CursorGrabMode, CursorIcon, PresentMode, WindowLevel;fn toggle_vsync(input: ResButtonInputKeyCode, mut window: Singlemut Window) if input.just_pressed(KeyCode::KeyV) window.present_mode = if matches!(window.present_mode, PresentMode::AutoVsync) PresentMode::AutoNoVsync else PresentMode::AutoVsync ; info!(PRESENT_MODE: :?, window.present_mode); fn switch_level(input: ResButtonInputKeyCode, mut window: Singlemut Window) if input.just_pressed(KeyCode::KeyT) window.window_level = match window.window_level WindowLevel::AlwaysOnBottom = WindowLevel::Normal, WindowLevel::Normal = WindowLevel::AlwaysOnTop, WindowLevel::AlwaysOnTop = WindowLevel::AlwaysOnBottom, ; info!(WINDOW_LEVEL: :?, window.window_level); fn toggle_cursor(input: ResButtonInputKeyCode, mut window: Singlemut Window) if input.just_pressed(KeyCode::KeyC) window.cursor_options.grab_mode = match window.cursor_options.grab_mode CursorGrabMode::None = CursorGrabMode::Locked, CursorGrabMode::Locked = CursorGrabMode::Confined, CursorGrabMode::Confined = CursorGrabMode::None, ; info!(CURSOR_GRAB_MODE: :?, window.cursor_options.grab_mode); 关键要点： 可以在运行时动态修改窗口属性 可以切换 VSync 模式 可以设置窗口层级 可以控制鼠标光标的抓取模式 说明：窗口属性设置允许在运行时动态调整窗口行为。这对于创建交互式应用程序非常有用。 多窗口支持创建和管理多个窗口。 源代码文件：bevy/examples/window/multiple_windows.rs 代码示例： use bevy::prelude::*;use bevy::window::RenderTarget, WindowRef;fn setup_scene(mut commands: Commands, asset_server: ResAssetServer) // 创建第一个窗口的相机 let first_window_camera = commands .spawn(( Camera3d::default(), Transform::from_xyz(0.0, 0.0, 6.0).looking_at(Vec3::ZERO, Vec3::Y), )) .id(); // 创建第二个窗口 let second_window = commands .spawn(Window title: 第二个窗口.to_owned(), ..default() ) .id(); // 创建第二个窗口的相机 let second_window_camera = commands .spawn(( Camera3d::default(), Transform::from_xyz(6.0, 0.0, 0.0).looking_at(Vec3::ZERO, Vec3::Y), Camera target: RenderTarget::Window(WindowRef::Entity(second_window)), ..default() , )) .id(); 关键要点： 可以创建多个窗口 每个窗口可以有独立的相机 使用 RenderTarget::Window 来指定相机渲染到哪个窗口 使用 WindowRef::Entity 来引用窗口实体 说明：多窗口支持允许创建复杂的应用程序界面。例如，可以创建一个主窗口显示游戏内容，另一个窗口显示调试信息。 进阶用法窗口事件处理处理窗口事件，如关闭、调整大小等。 源代码文件：bevy/examples/window/window_resizing.rs 关键信息： 可以监听窗口关闭事件 可以监听窗口调整大小事件 可以监听窗口焦点变化事件 可以使用 EventReader 来处理窗口事件 说明：窗口事件处理允许应用程序响应窗口状态的变化。这对于创建响应式应用程序非常重要。 透明窗口创建透明窗口。 源代码文件：bevy/examples/window/transparent_window.rs 关键信息： 可以创建透明窗口 需要设置窗口的透明度属性 透明窗口可以用于创建特殊效果 某些平台可能不支持透明窗口 说明：透明窗口可以用于创建特殊的视觉效果，如覆盖层、HUD 等。 窗口截图捕获窗口截图。 源代码文件：bevy/examples/window/screenshot.rs 关键信息： 可以捕获窗口截图 可以使用 Window::screenshot() 方法 截图可以保存为文件 可以捕获特定帧的截图 说明：窗口截图功能可以用于创建游戏截图、调试信息等。 实际应用在游戏开发中的应用场景窗口管理在游戏开发中有广泛的应用： 游戏窗口：创建游戏主窗口 调试窗口：创建调试信息窗口 设置窗口：创建设置界面窗口 多显示器支持：在不同显示器上显示不同内容 常见问题问题 1：如何创建全屏窗口？ 解决方案：可以设置窗口的 mode 属性为 WindowMode::Fullscreen。 问题 2：如何处理窗口关闭事件？ 解决方案：可以监听 WindowCloseRequested 事件，并在事件处理中执行清理操作。 问题 3：如何在不同窗口之间切换？ 解决方案：可以使用 WindowRef 来引用不同的窗口，并使用 Camera 的 target 属性来指定渲染目标。 性能考虑 窗口数量：尽量减少窗口数量以提高性能 窗口大小：合理设置窗口大小以平衡性能和视觉效果 VSync：根据需求启用或禁用 VSync 窗口事件：避免在窗口事件处理中执行耗时操作 相关资源相关源代码文件： bevy/examples/window/window_settings.rs - 窗口设置示例 bevy/examples/window/multiple_windows.rs - 多窗口示例 bevy/examples/window/transparent_window.rs - 透明窗口示例 bevy/examples/window/window_resizing.rs - 窗口调整大小示例 bevy/examples/window/screenshot.rs - 窗口截图示例 官方文档链接： Bevy Window 官方文档 窗口示例 进一步学习建议： 学习 UI，了解如何在窗口中创建用户界面 学习输入处理，了解如何处理窗口输入事件 学习相机系统，了解如何在窗口中渲染内容 索引：返回上级目录"},{"title":"用户界面（UI）","path":"/Luo-Haomin/wiki/BevyBook/UI_Audio_Window/UI.html","content":"用户界面（UI）概述学习目标： 理解 UI 系统的基本概念 掌握按钮的创建和使用 学会创建和更新文本 了解 Flexbox 和 Grid 布局 掌握 UI 样式和交互 前置知识要求： Bevy 快速入门 ECS 基础 窗口管理基础 核心概念什么是 UI 系统？UI 系统是 Bevy 中用于创建用户界面的功能。Bevy 的 UI 系统支持按钮、文本、布局、样式等多种 UI 元素。 为什么需要 UI 系统？ 用户交互：UI 系统提供用户交互界面 信息显示：UI 系统可以显示游戏信息 菜单系统：UI 系统可以创建菜单和设置界面 HUD：UI 系统可以创建游戏 HUD UI 系统的核心组件Bevy UI 系统包含以下核心组件： Node：UI 节点，用于布局和样式 Button：按钮组件，用于用户交互 Text：文本组件，用于显示文本 BackgroundColor：背景颜色组件 BorderColor：边框颜色组件 Interaction：交互状态组件 基础用法创建按钮创建和使用按钮。 源代码文件：bevy/examples/ui/button.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .init_resource::InputFocus() .add_systems(Startup, setup) .add_systems(Update, button_system) .run();const NORMAL_BUTTON: Color = Color::srgb(0.15, 0.15, 0.15);const HOVERED_BUTTON: Color = Color::srgb(0.25, 0.25, 0.25);const PRESSED_BUTTON: Color = Color::srgb(0.35, 0.75, 0.35);fn button_system( mut input_focus: ResMutInputFocus, mut interaction_query: Query ( Entity, Interaction, mut BackgroundColor, mut BorderColor, mut Button, Children, ), ChangedInteraction, , mut text_query: Querymut Text,) for (entity, interaction, mut color, mut border_color, mut button, children) in mut interaction_query let mut text = text_query.get_mut(children[0]).unwrap(); match *interaction Interaction::Pressed = input_focus.set(entity); **text = Press.to_string(); *color = PRESSED_BUTTON.into(); *border_color = BorderColor::all(RED); button.set_changed(); Interaction::Hovered = input_focus.set(entity); **text = Hover.to_string(); *color = HOVERED_BUTTON.into(); *border_color = BorderColor::all(Color::WHITE); button.set_changed(); Interaction::None = input_focus.clear(); **text = Button.to_string(); *color = NORMAL_BUTTON.into(); *border_color = BorderColor::all(Color::BLACK); fn setup(mut commands: Commands, assets: ResAssetServer) commands.spawn(Camera2d); commands.spawn(button(assets));fn button(asset_server: AssetServer) - impl Bundle ( Node width: percent(100), height: percent(100), align_items: AlignItems::Center, justify_content: JustifyContent::Center, ..default() , children![( Button, Node width: px(150), height: px(65), border: UiRect::all(px(5)), justify_content: JustifyContent::Center, align_items: AlignItems::Center, ..default() , BorderColor::all(Color::WHITE), BorderRadius::MAX, BackgroundColor(Color::BLACK), children![( Text::new(Button), TextFont font: asset_server.load(fonts/FiraSans-Bold.ttf), font_size: 40.0, ..default() , )], )], ) 关键要点： 使用 Button 组件创建按钮 使用 Interaction 组件检测交互状态 可以响应 Pressed、Hovered、None 三种交互状态 需要设置 InputFocus 资源以支持无障碍功能 说明：按钮是 UI 系统中最常用的交互元素。通过检测交互状态，可以创建响应式的按钮效果。 创建文本创建和更新文本。 源代码文件：bevy/examples/ui/text.rs 代码示例： use bevy::prelude::*;fn setup(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(Camera2d); // 创建单个文本 commands.spawn(( Text::new(hello bevy!), TextFont font: asset_server.load(fonts/FiraSans-Bold.ttf), font_size: 67.0, ..default() , TextShadow::default(), TextLayout::new_with_justify(Justify::Center), Node position_type: PositionType::Absolute, bottom: px(5), right: px(5), ..default() , )); // 创建多段文本 commands .spawn(( Text::new(FPS: ), TextFont font: asset_server.load(fonts/FiraSans-Bold.ttf), font_size: 42.0, ..default() , )) .with_child(( TextSpan::default(), TextFont font_size: 33.0, ..default() , TextColor(GOLD.into()), ));fn text_update_system( diagnostics: ResDiagnosticsStore, mut query: Querymut Text, WithFpsText,) for mut text in mut query if let Some(fps) = diagnostics.get(FrameTimeDiagnosticsPlugin::FPS) if let Some(value) = fps.smoothed() text.0 = format!(value:.2); 关键要点： 使用 Text 组件创建文本 可以使用 TextFont 设置字体和大小 可以使用 TextColor 设置文本颜色 可以使用 TextSpan 创建多段文本 可以在系统中更新文本内容 说明：文本是 UI 系统中用于显示信息的重要元素。通过更新文本内容，可以显示游戏状态、分数等信息。 Flexbox 布局使用 Flexbox 布局 UI 元素。 源代码文件：bevy/examples/ui/flex_layout.rs 代码示例： use bevy::prelude::*;fn spawn_layout(mut commands: Commands, asset_server: ResAssetServer) let font = asset_server.load(fonts/FiraSans-Bold.ttf); commands.spawn(Camera2d); commands .spawn(( Node width: percent(100), height: percent(100), flex_direction: FlexDirection::Column, align_items: AlignItems::Center, padding: UiRect::all(Val::Px(12.0)), row_gap: Val::Px(12.0), ..Default::default() , BackgroundColor(Color::BLACK), )) .with_children(|builder| builder .spawn(Node flex_direction: FlexDirection::Row, ..default() ) .with_children(|builder| // 添加子元素 ); ); 关键要点： 使用 Node 组件创建布局容器 使用 flex_direction 设置布局方向（Column 或 Row） 使用 align_items 设置对齐方式 使用 justify_content 设置内容分布 使用 padding、row_gap、column_gap 设置间距 说明：Flexbox 布局是创建响应式 UI 的重要工具。通过设置不同的布局属性，可以创建各种 UI 布局。 进阶用法Grid 布局使用 Grid 布局 UI 元素。 源代码文件：bevy/examples/ui/grid.rs 关键信息： 可以使用 Grid 组件创建网格布局 可以设置网格的行和列 可以设置网格项的跨行和跨列 可以设置网格间距和对齐方式 说明：Grid 布局适合创建表格、仪表板等复杂的 UI 布局。 UI 样式设置 UI 元素的样式。 关键信息： 可以使用 BackgroundColor 设置背景颜色 可以使用 BorderColor 设置边框颜色 可以使用 BorderRadius 设置圆角 可以使用 TextShadow 设置文本阴影 可以使用 TextLayout 设置文本布局 说明：UI 样式可以让界面更加美观和易用。通过设置不同的样式属性，可以创建各种视觉效果。 UI 交互处理 UI 元素的交互。 关键信息： 使用 Interaction 组件检测交互状态 可以响应 Pressed、Hovered、None 三种状态 可以使用 InputFocus 资源支持无障碍功能 可以使用 Button 组件的 set_changed() 方法更新状态 说明：UI 交互是创建响应式界面的关键。通过检测交互状态，可以创建各种交互效果。 实际应用在游戏开发中的应用场景UI 系统在游戏开发中有广泛的应用： 游戏菜单：创建主菜单、设置菜单等 HUD：创建游戏 HUD，显示分数、生命值等 对话框：创建对话和提示界面 设置界面：创建设置和配置界面 常见问题问题 1：如何创建响应式布局？ 解决方案：使用 Flexbox 或 Grid 布局，并使用百分比或相对单位设置大小。 问题 2：如何处理 UI 点击事件？ 解决方案：使用 Interaction 组件检测交互状态，并在系统中处理交互逻辑。 问题 3：如何更新 UI 文本？ 解决方案：在系统中查询文本组件，并使用 Text 的 set() 方法更新内容。 性能考虑 UI 元素数量：尽量减少 UI 元素数量以提高性能 文本更新频率：避免频繁更新文本内容 布局计算：合理使用布局属性以减少计算开销 交互检测：只在需要时检测交互状态 相关资源相关源代码文件： bevy/examples/ui/button.rs - 按钮示例 bevy/examples/ui/text.rs - 文本示例 bevy/examples/ui/flex_layout.rs - Flexbox 布局示例 bevy/examples/ui/grid.rs - Grid 布局示例 bevy/examples/ui/directional_navigation.rs - 方向导航示例 官方文档链接： Bevy UI 官方文档 UI 示例 进一步学习建议： 学习窗口管理，了解如何在窗口中创建 UI 学习输入处理，了解如何处理 UI 输入事件 学习动画系统，了解如何对 UI 元素进行动画处理 索引：返回上级目录"},{"title":"音频系统","path":"/Luo-Haomin/wiki/BevyBook/UI_Audio_Window/音频.html","content":"音频系统概述学习目标： 理解音频系统的基本概念 掌握音频资源的加载和播放 学会控制音频播放（播放、暂停、音量、速度） 了解 3D 空间音频的使用 前置知识要求： Bevy 快速入门 ECS 基础 资源管理基础 核心概念什么是音频系统？音频系统是 Bevy 中用于播放音频的功能。Bevy 的音频系统支持背景音乐、音效、3D 空间音频等多种音频类型。 为什么需要音频系统？ 游戏体验：音频可以增强游戏体验 反馈：音频可以提供游戏反馈 氛围：音频可以营造游戏氛围 沉浸感：3D 空间音频可以增强沉浸感 音频系统的核心组件Bevy 音频系统包含以下核心组件： AudioPlayer：音频播放器，用于播放音频 AudioSink：音频接收器，用于控制音频播放 PlaybackSettings：播放设置，用于配置音频播放 SpatialListener：空间监听器，用于 3D 空间音频 基础用法加载和播放音频加载和播放音频资源。 源代码文件：bevy/examples/audio/audio.rs 代码示例： use bevy::prelude::*;fn main() App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run();fn setup(asset_server: ResAssetServer, mut commands: Commands) commands.spawn(AudioPlayer::new( asset_server.load(sounds/Windless Slopes.ogg), )); 关键要点： 使用 AssetServer 加载音频资源 使用 AudioPlayer 组件播放音频 音频资源支持多种格式（OGG、WAV 等） 音频播放是异步的，不会阻塞游戏运行 说明：音频加载和播放是音频系统的基础。通过加载音频资源并创建音频播放器，可以播放背景音乐和音效。 音频控制控制音频播放（播放、暂停、音量、速度）。 源代码文件：bevy/examples/audio/audio_control.rs 代码示例： use bevy::prelude::*;fn setup(mut commands: Commands, asset_server: ResAssetServer) commands.spawn(( AudioPlayer::new(asset_server.load(sounds/Windless Slopes.ogg)), MyMusic, ));#[derive(Component)]struct MyMusic;fn pause( keyboard_input: ResButtonInputKeyCode, music_controller: QueryAudioSink, WithMyMusic,) let Ok(sink) = music_controller.single() else return; ; if keyboard_input.just_pressed(KeyCode::Space) sink.toggle_playback(); fn mute( keyboard_input: ResButtonInputKeyCode, mut music_controller: Querymut AudioSink, WithMyMusic,) let Ok(mut sink) = music_controller.single_mut() else return; ; if keyboard_input.just_pressed(KeyCode::KeyM) sink.toggle_mute(); fn volume( keyboard_input: ResButtonInputKeyCode, mut music_controller: Querymut AudioSink, WithMyMusic,) let Ok(mut sink) = music_controller.single_mut() else return; ; if keyboard_input.pressed(KeyCode::Equal) sink.set_volume((sink.volume() + 0.1).min(1.0)); if keyboard_input.pressed(KeyCode::Minus) sink.set_volume((sink.volume() - 0.1).max(0.0)); 关键要点： 使用 AudioSink 组件控制音频播放 可以使用 toggle_playback() 切换播放暂停 可以使用 toggle_mute() 切换静音 可以使用 set_volume() 设置音量 可以使用 set_speed() 设置播放速度 说明：音频控制允许在运行时动态调整音频播放。这对于创建音频设置界面、响应游戏状态变化等非常有用。 3D 空间音频使用 3D 空间音频创建沉浸式音频体验。 源代码文件：bevy/examples/audio/spatial_audio_3d.rs 代码示例： use bevy::prelude::*;fn setup( mut commands: Commands, asset_server: ResAssetServer, mut meshes: ResMutAssetsMesh, mut materials: ResMutAssetsStandardMaterial,) // 创建音频发射器 commands.spawn(( Mesh3d(meshes.add(Sphere::new(0.2).mesh().uv(32, 18))), MeshMaterial3d(materials.add(Color::from(BLUE))), Transform::from_xyz(0.0, 0.0, 0.0), Emitter::default(), AudioPlayer::new(asset_server.load(sounds/Windless Slopes.ogg)), PlaybackSettings::LOOP.with_spatial(true), )); // 创建空间监听器 let listener = SpatialListener::new(4.0); // 4.0 是两耳之间的距离 commands.spawn(( Transform::default(), Visibility::default(), listener, ));fn update_listener( keyboard: ResButtonInputKeyCode, mut listener: Querymut Transform, WithSpatialListener,) let Ok(mut transform) = listener.single_mut() else return; ; let speed = 2.0; if keyboard.pressed(KeyCode::ArrowUp) transform.translation.z -= speed; if keyboard.pressed(KeyCode::ArrowDown) transform.translation.z += speed; if keyboard.pressed(KeyCode::ArrowLeft) transform.translation.x -= speed; if keyboard.pressed(KeyCode::ArrowRight) transform.translation.x += speed; 关键要点： 使用 SpatialListener 组件创建空间监听器 使用 PlaybackSettings::LOOP.with_spatial(true) 启用空间音频 空间监听器的位置影响音频的感知位置 音频发射器的位置影响音频的来源位置 说明：3D 空间音频可以创建沉浸式的音频体验。通过设置音频发射器和监听器的位置，可以模拟真实的声音传播效果。 进阶用法音频播放设置配置音频播放设置。 关键信息： 可以使用 PlaybackSettings 配置播放设置 可以设置循环播放、音量、速度等 可以启用空间音频 可以设置播放延迟 说明：音频播放设置允许精细控制音频播放行为。这对于创建各种音频效果非常有用。 音频轨道管理多个音频轨道。 源代码文件：bevy/examples/audio/soundtrack.rs 关键信息： 可以创建多个音频轨道 可以在不同轨道之间切换 可以同时播放多个轨道 可以控制每个轨道的音量 说明：音频轨道允许管理复杂的音频场景。例如，可以创建背景音乐轨道、音效轨道等。 实际应用在游戏开发中的应用场景音频系统在游戏开发中有广泛的应用： 背景音乐：播放游戏背景音乐 音效：播放游戏音效，如脚步声、爆炸声等 3D 音频：创建沉浸式的 3D 音频体验 音频反馈：提供游戏反馈，如按钮点击声等 常见问题问题 1：如何循环播放音频？ 解决方案：使用 PlaybackSettings::LOOP 设置循环播放。 问题 2：如何同时播放多个音频？ 解决方案：创建多个 AudioPlayer 实体，每个实体播放不同的音频。 问题 3：如何实现 3D 空间音频？ 解决方案：使用 SpatialListener 和 PlaybackSettings::LOOP.with_spatial(true) 启用空间音频。 性能考虑 音频数量：尽量减少同时播放的音频数量 音频格式：选择合适的音频格式以平衡质量和文件大小 音频压缩：使用压缩音频格式以减少内存使用 空间音频：只在需要时启用空间音频以提高性能 相关资源相关源代码文件： bevy/examples/audio/audio.rs - 音频播放示例 bevy/examples/audio/audio_control.rs - 音频控制示例 bevy/examples/audio/spatial_audio_3d.rs - 3D 空间音频示例 bevy/examples/audio/soundtrack.rs - 音频轨道示例 官方文档链接： Bevy Audio 官方文档 音频示例 进一步学习建议： 学习资源管理，了解如何加载和管理音频资源 学习输入处理，了解如何通过输入控制音频播放 学习 3D 开发，了解如何将 3D 空间音频与 3D 场景结合 索引：返回上级目录"}]